(null

    ;compute the entropy of the influence weights of the context's influential cases
    ; context_values: optional list of context values to react to
    ; case_id: optional case id in the model to react to
    ; context_features: list of context features to react to
    ; use_case_weights: optional flag default true. if false, case weights will not be used during the react
    ; weight_feature: optional, default '.case_weight'. name of feature whose values to use as case weights
    #ComputeInfluenceWeightEntropy
    (declare
        (assoc
            context_values (null)
            case_id (null)
            context_features (list)
            use_case_weights (true)
            weight_feature ".case_weight"

            ;internal only
            react_kwargs (assoc)
        )

        (if (not use_case_weights)
            (assign weight_feature ".none"))
        
        (assign (assoc
            react_kwargs (assoc
                context_features context_features
                use_case_weights use_case_weights
                weight_feature weight_feature
                details (assoc influential_cases (true) )
            )
        ))
        
        (if 
            ;if context_values are not null, we are reacting to a new case
            (not (= context_values (null)))
            (accum "react_kwargs" (assoc
                context_values context_values
            ))
            ;elif case_id is not null, we are reacting to an existing case
            (not (= case_id (null)))
            (accum "react_kwargs" (assoc
                case_indices
                    (retrieve_from_entity case_id (list ".session" ".session_training_index") )
                preserve_feature_values context_features
                leave_case_out (true)
            ))
        )

        ;compute the entropy of the influence weights as retrieved by react
        (entropy (map
            (lambda (get (current_value) ".influence_weight") )

            (get (call React react_kwargs) "influential_cases")
        ))
    )

    ;used to compute and store the influence weight entropies for call cases contained in the Trainee in #Analyze
    ; context_features: list of context features to use when determining influential cases.
    #ComputeAndStoreInfluenceWeightEntropies
    (let 
        (assoc
            influence_weight_entropy_map
                ||(map
                    (lambda
                        (call ComputeInfluenceWeightEntropy (assoc
                            case_id (current_index 1)
                            context_features context_features
                        ))
                    )
                    (zip (call AllCases))
                )
        )

        (call StoreCaseValues (assoc
            case_values_map influence_weight_entropy_map
            label_name internalLabelInfluenceWeightEntropy
        ))

        (assign_to_entities (assoc hasInfluenceWeightEntropies (true)))
    )

    ;initialize parameters and internal features related to auto ablation
    ; weight_feature: optional, default '.case_weight'. name of feature whose values to use as case weights
    #InitializeAutoAblate
    (declare
        (assoc
            weight_feature ".case_weight"
        )

        (if (not hasPopulatedCaseWeight)
            (seq
                (assign_to_entities (assoc hasPopulatedCaseWeight (true)))
                (call CreateCaseWeights (assoc
                    feature_name weight_feature
                ))
            )
        )
    )

    ;determine whether a new case (one that is not in the Trainee) should be ablated (trained as weights) or kept.
    ; context_values: list of context values to react to
    ; context_features: list of context features to react to
    #ShouldNewCaseBeAblated
    (declare
        (assoc
            context_features (list)
            context_values (list)

            ;internal
            max_influence_weight_entropy_to_keep .infinity
        )

        ;If we do not have influence weight entropies stored, ablation cannot happen.
        ; So, always return 1 when that is the case.
        (if
            (not (and hasInfluenceWeightEntropies))
            (conclude 1)
        )

        (assign (assoc
            max_influence_weight_entropy_to_keep
                (compute_on_contained_entities (list
                    (query_exists internalLabelInfluenceWeightEntropy)
                    (query_quantile internalLabelInfluenceWeightEntropy autoAblateEntropyThresholdQuantile ".case_weight")
                ))
        ))

        (+
            (or
                (> max_influence_weight_entropy_to_keep
                    (call ComputeInfluenceWeightEntropy (assoc
                        context_values context_values
                        context_features context_features
                    ))
                    
                )
                ; This is probably unnecessary but in case we cannot compute the requested influence weight
                ; quartile return 1 as well.
                (= max_influence_weight_entropy_to_keep .nan)
            )
        )
    )
)