(null

    #ComputeInfluenceWeightEntropyUsingContext
    (declare
        (assoc
            context_values (list)
            context_features (list)
            use_case_weights (true)
            weight_feature ".case_weight"
        )

        ;compute the entropy of the influence weights as retrieved by react.
        (entropy (map
            (lambda (get (current_value) ".influence_weight"))

            (get
                (call React (assoc
                    context_features context_features
                    context_values context_values
                    details (assoc
                        influential_cases (true)
                    )
                    use_case_weights use_case_weights
                    weight_feature weight_feature

                ))
                "influential_cases"
            )
        ))
    )

    #ComputeInfluenceWeightEntropyUsingCaseID
    (declare
        (assoc
            case_id (null)
            context_features (list)
            use_case_weights (true)
            weight_feature ".case_weight"

            case_session_training_index (null)
        )

        ;retrieve the sesssion training index from the case and use it as input to a react.
        (assign (assoc
            case_session_training_index
                (retrieve_from_entity case_id (list ".session" ".session_training_index"))
        ))

        ;compute the entropy of the influence weights as retrieved by react.
        (entropy (map
            (lambda (get (current_value) ".influence_weight"))

            (get
                (call React (assoc
                    context_features context_features
                    case_indices case_session_training_index
                    preserve_feature_values context_features
                    leave_case_out (true)
                    details (assoc
                        influential_cases (true)
                    )
                    use_case_weights use_case_weights
                    weight_feature weight_feature

                ))
                "influential_cases"
            )
        ))
    )

    #ComputeAndStoreInfluenceWeightEntropies
    (let 
        (assoc
            influence_weight_entropy_map
                ||(map
                    (lambda
                        (call ComputeInfluenceWeightEntropyUsingCaseID (assoc
                            case_id (current_index 1)
                            context_features context_features
                        ))
                    )
                    (zip (call AllCases))
                )
            influence_weight_entropy_label ".influence_weight_entropy"
        )

        (call StoreCaseValues (assoc
            case_values_map influence_weight_entropy_map
            label_name influence_weight_entropy_label
        ))

        (assign_to_entities (assoc hasInfluenceWeightEntropies (true)))
    )

    #InitializeAutoAblate
    (declare
        (assoc
            weight_feature ".case_weight"
        )

        (if (not hasPopulatedCaseWeight)
            (seq
                (assign_to_entities (assoc hasPopulatedCaseWeight (true)))
                (call StoreCaseValues (assoc
                    case_values_map (zip (call AllCases) 1)
                    label_name weight_feature
                ))
            )
        )
    )

    #DetermineNewCaseForAblation
    (declare
        (assoc
            context_features (list)
            context_values (list)

            max_influence_weight_entropy_to_keep .infinity
        )

        ;If we do not have influence weight entropies stored, ablation cannot happen.
        ; So, always return 1 when that is the case.
        (if
            (not (and hasInfluenceWeightEntropies))
            (conclude 1)
        )

        (assign (assoc
            max_influence_weight_entropy_to_keep
                (compute_on_contained_entities (list
                    (query_exists ".influence_weight_entropy")
                    (query_quantile ".influence_weight_entropy" autoAblateEntropyThresholdQuantile ".case_weight")
                ))
        ))

        (if
            (or
                (<= max_influence_weight_entropy_to_keep
                    (call ComputeInfluenceWeightEntropyUsingContext (assoc
                        context_values context_values
                        context_features context_features
                    ))
                )
                ;else
                ; This is probably unnecessary but in case we cannot compute the requested influence weight
                ; quartile return 1 as well.
                (= max_influence_weight_entropy_to_keep .nan)
            )
            1
            0
        )
    )
)