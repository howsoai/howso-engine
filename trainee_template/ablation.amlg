(null

	;compute the entropy of the influence weights of the context's influential cases
	; context_values: optional list of context values to react to
	; case_id: optional case id in the model to react to
	; context_features: list of context features to react to
	; use_case_weights: optional flag default true. if false, case weights will not be used during the react
	; weight_feature: optional, default '.case_weight'. name of feature whose values to use as case weights
	#ComputeInfluenceWeightEntropy
	(declare
		(assoc
			context_values (null)
			case_id (null)
			context_features (list)
			use_case_weights (true)
			weight_feature autoAblationWeightFeature

			;internal only
			react_kwargs (assoc)
		)

        (if (not use_case_weights)
            (assign (assoc weight_feature ".none"))
        )
        
        (assign (assoc
            react_kwargs
                (assoc
                    context_features context_features
                    use_case_weights use_case_weights
                    weight_feature weight_feature
                    details (assoc influential_cases (true) )
                )
        ))
        
        (if 
            ;if context_values are not null, we are reacting to a new case
            (!= context_values (null))

			(accum "react_kwargs" (assoc context_values context_values) )
			;elif case_id is not null, we are reacting to an existing case
			(!= case_id (null))
			(accum "react_kwargs" (assoc
				case_indices (retrieve_from_entity case_id (list ".session" ".session_training_index") )
				preserve_feature_values context_features
				leave_case_out (true)
			))
		)

		;compute the entropy of the influence weights as retrieved by react
		; TODO - 19101: streamline this code to directly use the query engine
		(entropy (map
			(lambda (get (current_value) ".influence_weight") )
			(get (call React react_kwargs) "influential_cases")
		))
	)

	;used to compute and store the influence weight entropies for all cases contained in the Trainee in #Analyze
	; context_features: list of context features to use when determining influential cases.
	; label_name: optional name of the feature to store influence weight entropies in.
	#ComputeAndStoreInfluenceWeightEntropies
	(let 
		(assoc
			influence_weight_entropy_map
				||(map
					(lambda
						(call ComputeInfluenceWeightEntropy (assoc
							case_id (current_index 1)
							context_features context_features
							use_case_weights use_case_weights
							weight_feature weight_feature
						))
					)
					(zip (call AllCases))
				)
		)

		(call StoreCaseValues (assoc
			case_values_map influence_weight_entropy_map
			label_name
				(if (= (null) label_name)
					internalLabelInfluenceWeightEntropy
					label_name
				)
		))

		(accum_to_entities (assoc revision 1))
		(assign_to_entities (assoc hasInfluenceWeightEntropies (true)))
	)

	;initialize parameters and internal features related to auto ablation
	; weight_feature: optional, default '.case_weight'. name of feature whose values to use as case weights
	#InitializeautoAblation
	(declare
		(assoc weight_feature autoAblationWeightFeature)
		
		(assign_to_entities (assoc hasPopulatedCaseWeight (true)) )
		(accum_to_entities (assoc revision 1) )
		(call CreateCaseWeights (assoc feature_name weight_feature) )
	)

	;determine whether a new case (one that is not in the Trainee) should be ablated (trained as weights) or kept.
	; a return value of 1 indicates that a case should be kept and a return value of 0 indicates that the case should be ablated.
	; context_values: list of context values to react to
	; context_features: list of context features to react to
	#ShouldNewCaseBeAblated
	(declare
		(assoc
			context_features (list)
			context_values (list)

			;internal
			max_influence_weight_entropy_to_keep .infinity
		)

		;If we do not have influence weight entropies stored, ablation cannot happen.
		; So, always return 1 when that is the case.  The same is true for when there
		; are not enough cases in the model.
		(if
			(or 
				(not (and hasInfluenceWeightEntropies autoAblationEnabled) )
				(< (call GetNumTrainingCases) autoAblationMinModelSize )
			)
			(conclude 1)
		)

		(assign (assoc
			max_influence_weight_entropy_to_keep
				(compute_on_contained_entities (list
					(query_exists internalLabelInfluenceWeightEntropy)
					(query_quantile internalLabelInfluenceWeightEntropy autoAblationInfluenceWeightEntropyThreshold ".case_weight")
				))
		))

		(+
			(or
				(> max_influence_weight_entropy_to_keep
					(call ComputeInfluenceWeightEntropy (assoc
						context_values context_values
						context_features context_features
					))
					
				)
				; This is probably unnecessary but in case we cannot compute the requested influence weight
				; quantile return 1 as well.
				(= max_influence_weight_entropy_to_keep .nan)
			)
		)
	)

	#CaseOutsideThresholds
	(let
		(assoc
			action_features
				(filter
					(lambda (or 
						(contains_value autoAblationExactPredictionFeatures (current_value))
						(contains_index autoAblationTolerancePredictionThresholdMap (current_value))
						(contains_index autoAblationRelativePredictionThresholdMap (current_value))
						(contains_value autoAblationResidualPredictionFeatures (current_value))
					))
					features
				)
			feature_value_map (zip features feature_values)
		)

		(if
			(= (null)
				autoAblationExactPredictionFeatures
				autoAblationTolerancePredictionThresholdMap
				autoAblationRelativePredictionThresholdMap
				autoAblationResidualPredictionFeatures
				autoAblationConvictionLowerThreshold
				autoAblationConvictionUpperThreshold
			)
			(conclude 1)
		)

		(declare (assoc
			action_values (unzip feature_value_map action_features)
			residual_map (assoc)
		))

		(or ;evaluate in order and return the first true block

			;if the model is too small, skip ablatement, return true to force training
			(< (call GetNumTrainingCases) autoAblationMinModelSize)

			;if we have action_features, need to react first
			(if (!= (list) action_features)
				;store the reaction to reuse for both
				(let
					(assoc
						reaction_values
							(map
								(lambda (let
									(assoc
										feature (current_index 1)
										;flag set if this feature uses residual as its threshold type
										ablate_by_feature_residuals
											(contains_index (zip autoAblationResidualPredictionFeatures) (current_index 1) )
									)
									(declare (assoc
										context_features (filter (lambda (!= feature (current_value))) features)
									))

									;react to each of the action features, using all other features as contexts
									(declare (assoc
										reaction
											(call ReactDiscriminative (assoc
												return_action_values_only (true)
												context_features context_features
												context_values (unzip feature_value_map context_features)
												action_features (list feature)
												details
													(if ablate_by_feature_residuals
														(assoc "feature_residuals" (true))
													)
												substitute_output (false)
												skip_encoding (true)
												skip_decoding (true)
											))
									))

									;output the predicted value
									(if ablate_by_feature_residuals
										(seq
											;store the residual min and max tolerance for this feature
											(accum (assoc
												residual_map
													(associate feature (assoc
														"min" (get reaction (list "feature_residuals" feature))
														"max" (get reaction (list "feature_residuals" feature))
													))
											))

											(first (get reaction "action_values"))
										)

										(first reaction)
									)

								))
								(zip action_features)
							)
					)

					(or
						;if we filter out any values outside of the defined thresholds (that should be trained on)
						;allow training because these values are not being predicted by the system
						(!=
							(size action_values)
							;if an action_value is same as/within threshold of prediction, it will not be filtered out
							;so if this list is the same size as the original action_values, all action values were predicted correctly
							;but if it's not the same size, the action values are different enough to be trained on
							(size (filter
								(lambda (let
									(assoc
										action_feature (current_index 1)
										action_value (get feature_value_map (current_index 1))
									)
									(declare (assoc
										threshold_type
											(if
												(contains_value autoAblationExactPredictionFeatures action_feature)
												"exact"
												(contains_index autoAblationTolerancePredictionThresholdMap action_feature)
												"tolerance"
												(contains_value autoAblationResidualPredictionFeatures action_feature)
												"residual"
												(contains_index autoAblationRelativePredictionThresholdMap action_feature)
												"relative"
												(null)
											)
									))

									(if (= threshold_type "exact")
										(= action_value (current_value))

										;for discrete or residual, set the min and max and check if actual value is outside of those bounds
										(or (= threshold_type "tolerance") (= threshold_type "residual") )
										(let
											(assoc
												min
													(if (= threshold_type "tolerance")
														(get autoAblationTolerancePredictionThresholdMap (list action_feature 0))
														(get residual_map (list (get action_features (current_index 1)) "min"))
													)
												max
													(if (= threshold_type "tolerance")
														(get autoAblationTolerancePredictionThresholdMap (list action_feature 1))
														(get residual_map (list (get action_features (current_index 1)) "max"))
													)
											)
											(and (>= (current_value) (- action_value min)) (<= (current_value) (+ action_value max)))
										)

										;PERCENT is (last threshold)
										(= threshold_type "relative")
										(<=
											(/ (abs (- (current_value) action_value)) (current_value))
											(get autoAblationRelativePredictionThresholdMap action_feature)
										)

										;if threshold_type is explicitly undefined, treat it as outside of bounds and filter out the value
										;thus forcing this case to be trained
										(= threshold_type (null))
										(false)
									)
								))
								reaction_values
							))
						)
					)
				)
			)

			;conviction thresholds
			(if
				(or (!= autoAblationConvictionLowerThreshold (null)) (!= autoAblationConvictionUpperThreshold (null)))
				(let
					(assoc
						conviction_value
							(get
								(call ReactGroup (assoc
									features features
									new_cases (list feature_values)
									skip_encoding (true)
								))
								"familiarity_conviction_addition"
							)
					)

					(or
						;if both threshold values set, must be within both, otherwise check only the provided one
						(if (and (!= (null) autoAblationConvictionLowerThreshold) (!= (null) autoAblationConvictionUpperThreshold))
							(and (< conviction_value autoAblationConvictionUpperThreshold) (> conviction_value autoAblationConvictionLowerThreshold))

							(!= (null) autoAblationConvictionLowerThreshold)
							(> conviction_value autoAblationConvictionLowerThreshold)

							(< conviction_value autoAblationConvictionUpperThreshold)
						)

						;if the model is empty, ReactGroup returns 0, force training
						(= conviction_value 0)
					)
				)
				;else
				0
			)
		)
	)
)