(null

	;Helper method to create the actual full name path by interleaving ".trainee_container" with each name in the path
	#ConvertChildPathToActualPath
	(weave (range traineeContainer 1 (size path) 1) path)


	;return full path to specified subtrainee in the format of (list ".trainee_container" child1 ".trainee_container" child2)
	;parameters:
	; name_path: optional,  list of strings specifying the user-friendly path to the child subtrainee.
	;		May be an incomplete path as long as it uniquely identifies the trainee.
	; id: optional, unique id of the subtrainee. Ignored if namp_path is specified.
	#ResolveChildPath
	(seq
		;use id instead of name_path if provided only id
		(if (and (= 0 (size name_path)) id)
			(conclude
				(if (contains_index containedTraineeIdToNamePathMap id)
					(call ConvertChildPathToActualPath (assoc
						path (get containedTraineeIdToNamePathMap id)
					))

					"Invalid trainee id specified."
				)
			)
		)

		(declare (assoc name (apply "concat" name_path) ))

		;keep all those paths that match the provided name
		(declare (assoc
			matching_paths
				(filter
					(lambda (= name (substr (current_index) name)) )
					containedTraineeNamePathStringToListMap
				)
		))

		(if (= 1 (size matching_paths))
			(conclude
				(call ConvertChildPathToActualPath (assoc
					path (first (values matching_paths))
				))
			)

			(= 0 (size matching_paths))
			(conclude "Invalid name path specified.")
		)

		;if there is more than one matching path, either name_path refers to a non-leaf node
		;or it's too ambiguous.  If it's a non-leaf node, one of the matching_paths will have it as the last name listed in the path
		(assign (assoc
			matching_paths
				(filter
					(lambda (= (last name_path) (last (current_value))))
					matching_paths
				)
		))

		(if (= 1 (size matching_paths))
			(call ConvertChildPathToActualPath (assoc
				path (first (values matching_paths))
			))

			"Ambiguous name path specified, more than one trainee matches the specified name path."
		)
	)

	;Return the flag whether the subtrainee at the provided full path is stored inside (true) or independently (false)
	#IsChildInternal
	(get
		childTraineeIsContainedMap
		(apply "concat" (filter (lambda (!= traineeContainer (current_value))) child_trainee_path))
	)

	;Method to update this trainee's Parent's is_contained status
	;parameters:
	; child_trainee_path: path to child trainee
	; is_contained: boolean, true means this child is contained inside traineeContainer, false means it is stored and loaded independently
	#UpdateParentsIsContainedMap
	(let
		(assoc
			childs_contained_trainees_map (retrieve_from_entity child_trainee_path "containedTraineeNamePathStringToListMap")
			childs_is_contained_trainees_map (retrieve_from_entity child_trainee_path "childTraineeIsContainedMap")
		)

		;keep only those trainees that are still contained inside the child trainee
		(assign (assoc
			childs_contained_trainees_map
				(filter
					(lambda (get childs_is_contained_trainees_map (current_index)))
					childs_contained_trainees_map
				)
		))

		(declare (assoc
			pretty_path (filter (lambda (!= traineeContainer (current_value))) child_trainee_path)
			all_pretty_paths_to_update (list)
			trainee_path (null)
		))

		(while (size pretty_path)
			(assign (assoc
				all_pretty_paths_to_update
					(append
						(list (apply "concat" pretty_path))
						(map
							(lambda (apply "concat" (append pretty_path (current_value)) ))
							(values childs_contained_trainees_map)
						)
					)
			))

			(map
				(lambda (let
					(assoc child_pretty_path (current_value 1))
					(accum_to_entities trainee_path (assoc childTraineeIsContainedMap (associate child_pretty_path is_contained) ))
				))
				all_pretty_paths_to_update
			)

			(if (= (null) trainee_path) (assign (assoc trainee_path (list) )) )
			(accum (assoc trainee_path (list traineeContainer (first pretty_path)) ))
			(assign (assoc pretty_path (tail pretty_path)))
		)
	)

	;Renames all paths to a contained child trainee
	;
	;parameters:
	;  child_trainee_path: path to child trainee in the format of a list with repeating pars of [".trainee_container" child_name]
	;  new_name_path: the new path to child trainee in the format of a list with repeating pars of [".trainee_container" new_child_name]
	#RenameChildTraineePaths
	(let
		(assoc
			old_pretty_path (filter (lambda (!= traineeContainer (current_value))) child_trainee_path)
			new_name (tail new_name_path)
		)

		(declare (assoc
			child_id (get containedTraineeNamePathStringToIdMap (apply "concat" old_pretty_path ))
			subtrainee_contained_map (retrieve_from_entity child_trainee_path "childTraineeIsContainedMap")
			contained_trainee_path_map (retrieve_from_entity child_trainee_path "containedTraineeNamePathStringToListMap")
		))

		(call RemoveChildTraineePaths (assoc
			child_trainee_path child_trainee_path
		))

		(call AddChildTraineePaths (assoc
			child_name new_name
			child_id child_id
			child_trainee_path new_name_path
		))

		;rename paths to child trainees from all contained entities in the path,
		;iterating by 2s to include an instance of 'traineeContainer' for each child
		(range
			(lambda (let
				(assoc next_trainee_path (trunc child_trainee_path (current_index 1)) )
				(call_entity next_trainee_path "RenameChildTraineePaths" (assoc
					child_trainee_path (tail child_trainee_path (- (current_index 1)))
					new_name_path (tail new_name_path (- (current_index 1)))
				))
			))
			2 (- (size child_trainee_path) 1) 2
		)
	)

	;store path to any child trainee to enable quick access to any subtrainee given its name
	;parmeters:
	; child_name: name of child trainee to add
	; child_id: optional, unique id of child trainee to add
	; child_trainee_path: path to child trainee in the format of a list with repeating pars of [".trainee_container" child_name]
	;	for each layer of hierarchy. e.g., (list ".trainee_container" first_child ".trainee_container" grand_child) for a 2 level hirearchy
	; is_contained: boolean, default true, meaning this child is contained inside traineeContainer, false means it is stored and loaded independently
	#AddChildTraineePaths
	(declare
		(assoc is_contained (true))


		;filter out all the traineeContainer to leave just the trainee names in the path
		(declare (assoc
			pretty_path (filter (lambda (!= traineeContainer (current_value))) child_trainee_path)
			hierarchy_map (retrieve_from_entity "hierarchyMap")
		))

		(declare (assoc string_path (apply "concat" pretty_path ) ))

		(accum_to_entities (assoc
			containedTraineeNamePathStringToListMap (associate string_path pretty_path)
			childTraineeIsContainedMap (associate string_path is_contained )
		))

		(if child_id
			(accum_to_entities (assoc
				containedTraineeIdToNamePathMap (associate child_id pretty_path)
				containedTraineeNamePathStringToIdMap (associate string_path child_id)
			))
		)

		;remove the child itself from the pretty path
		(assign (assoc pretty_path (trunc pretty_path)))

		;(accum_to_entities) opcode doesn't support nested layer accumulation of assoc keys, use (accum) on a local
		;copy of the hierarchy map instead and then update hierarchyMap with the edited copy
		(accum "hierarchy_map" pretty_path (associate child_name (assoc)) )
		(assign_to_entities (assoc hierarchyMap hierarchy_map))

		;this is the parent of the child, set the parentId for the child
		(if (and (= 0 (size pretty_path)) traineeId)
			(assign_to_entities (list traineeContainer child_name) (assoc parentId traineeId))
		)

		;add path to child trainee to all contained entities in the path,
		;iterating by 2s to include an instance of 'traineeContainer' for each child
		;child_trainee_path is in the format of: (list traineeContainer child1 traineeContainer child2 etc..)
		(range
			(lambda (let
				(assoc index (current_index 1) )

				;use the first 'index' ids in child_trainee_path to call the method
				(call_entity (trunc child_trainee_path index) "AddChildTraineePaths" (assoc
					child_name child_name
					child_id child_id
					;pass in the child_trainee_path with the first 'index' ids removed
					child_trainee_path (tail child_trainee_path (- index))
				))
			))
			2 (- (size child_trainee_path) 1) 2
		)
	)

	;Removes paths to any child trainee
	;parameters:
	; child_trainee_path: path to child trainee to remove in the format of: (list traineeContainer child1 traineeContainer child2 etc..)
	#RemoveChildTraineePaths
	(seq
		(declare (assoc
			pretty_path (filter (lambda (!= traineeContainer (current_value))) child_trainee_path)
		))
		(declare (assoc
			child_id (get containedTraineeNamePathStringToIdMap pretty_path)
		))

		(assign_to_entities (assoc
			containedTraineeNamePathStringToListMap (remove containedTraineeNamePathStringToListMap pretty_path)
			containedTraineeNamePathStringToIdMap (remove containedTraineeNamePathStringToIdMap pretty_path)
			containedTraineeIdToNamePathMap (remove containedTraineeIdToNamePathMap child_id)
			childTraineeIsContainedMap (remove childTraineeIsContainedMap pretty_path)
		))

		;find the parent of the child by grabbing the third-to-last value from the path
		(declare (assoc
			parent_trainee
				(if (> (size child_trainee_path) 2)
					(get child_trainee_path -3)
					(null)
				)
		))

		(assign_to_entities (assoc
			hierarchyMap
				;remove the child_trainee from the hierarchyMap assoc regardless how many layers deep in it is
				(if parent_trainee
					(let
						(assoc hierarchy_map (retrieve_from_entity "hierarchyMap"))

						(set
							hierarchy_map
							(trunc pretty_path)
							(remove (get hierarchy_map (trunc pretty_path)) (last pretty_path))
						)
					)

					;else remove the child trainee directly from this trainee
					(remove hierarchyMap (last pretty_path))
				)
		))

		;remove path to child trainee from all contained entities in the path,
		;iterating by 2s to include an instance of 'traineeContainer' for each child
		(range
			(lambda (let
				(assoc next_trainee_path (trunc child_trainee_path (current_index 1)) )
				(call_entity next_trainee_path "RemoveChildTraineePaths" (assoc
					child_trainee_path (tail child_trainee_path (- (current_index 1)))
				))
			))
			2 (- (size child_trainee_path) 1) 2
		)
	)




)