(null


	;outputs a pair of [trainee_path:list, is_contained_locally:boolean]
	#GetTraineePath
	(if (contains_index containedTraineePathMap trainee)
		(list
			(get containedTraineePathMap trainee)
			(get childTraineeIsContainedMap trainee)
		)
	)

	;Method to update the location of child trainee, whether it's contained or stored independently
	;This method can be called by the traineeContainer child entity directly by a child trainee to update its own location
	;
	;parameters:
	; child_trainee: id of child trainee whole location to update
	; is_contained: boolean, if true the child_trainee is stored as a contained entity under traineeContainer,
	;	if false it is stored as an independent trainee
	#^UpdateChildTraineeIsContainedMap
	(seq
		(accum_to_entities (assoc childTraineeIsContainedMap (associate child_trainee is_contained) ))
		;iterate up the hierarchy and update all the parents' is_contained flag for this child_trainee
		(if parentId
			(call_container "UpdateParentsIsContainedMap" (assoc
				child_trainee child_trainee
				is_contained is_contained
			))
		)
	)

	;Method to update this trainee's Parent's is_contained status
	;parameters:
	; child_trainee: id of this trainee
	; is_contained: boolean, true means this child is contained inside traineeContainer, false means it is stored and loaded independently
	#UpdateParentsIsContainedMap
	(call_container "UpdateParentsIsContainedMap" (assoc child_trainee child_trainee is_contained is_contained ))

	;store path to any child trainee to enable quick access to any subtrainee given its id
	;parmeters:
	; child_trainee: id of child trainee to add
	; parent_trainee: id of parent trainee under which to add child
	; child_trainee_path: path to child trainee in the format of a list with repeating pars of [".trainee_container" child_trainee]
	;	for each layer of hierarchy. e.g., (list ".trainee_container" first_child ".trainee_container" grand_child) for a 2 level hirearchy
	; is_contained: boolean, default true, meaning this child is contained inside traineeContainer, false means it is stored and loaded independently
	#AddChildTraineePaths
	(declare
		(assoc is_contained (true))

		;child_trainee_path is in the format of: (list traineeContainer child1 traineeContainer child2 etc..)
		(accum_to_entities (assoc
			containedTraineePathMap (associate child_trainee child_trainee_path)
			childTraineeIsContainedMap (associate child_trainee is_contained )
		))

		;filter out all the traineeContainer to leave just the trainee ids in the path, not including the child itself
		(declare (assoc
			direct_path (filter (lambda (!= traineeContainer (current_value))) (trunc child_trainee_path))
			hierarchy_map (retrieve_from_entity "hierarchyMap")
		))
		;(accum_to_entities) opcode doesn't support nested layer accumulation of assoc keys, use (accum) on a local
		;copy of the hierarchy map instead and then update hierarchyMap with the edited copy
		(accum "hierarchy_map" direct_path (associate child_trainee (assoc)) )
		(assign_to_entities (assoc hierarchyMap hierarchy_map))

		;this is the parent of the child, set the parentId for the child
		(if (= 0 (size direct_path))
			(assign_to_entities (list traineeContainer child_trainee) (assoc parentId parent_trainee))
		)

		;add path to child trainee to all contained entities in the path,
		;iterating by 2s to include an instance of 'traineeContainer' for each child
		(range
			(lambda (let
				(assoc index (current_index 1) )

				;use the first 'index' ids in child_trainee_path to call the method
				(call_entity (trunc child_trainee_path index) "AddChildTraineePaths" (assoc
					child_trainee child_trainee
					parent_trainee parent_trainee
					;pass in the child_trainee_path with the first 'index' ids removed
					child_trainee_path (tail child_trainee_path (- index))
				))
			))
			2 (- (size child_trainee_path) 1) 2
		)
	)

	;Removes paths to any child trainee
	;parameters:
	; child_trainee: id of child trainee to remove
	#RemoveChildTraineePaths
	(seq
		(declare (assoc child_trainee_path (get containedTraineePathMap child_trainee) ))

		;child_trainee_path is in the format of: (list traineeContainer child1 traineeContainer child2 etc..)
		(assign_to_entities (assoc
			containedTraineePathMap (remove containedTraineePathMap child_trainee)
			childTraineeIsContainedMap (remove childTraineeIsContainedMap child_trainee)
		))

		;find the parent of the child by grabbing the third-to-last value from the path
		(declare (assoc
			parent_trainee
				(if (> (size child_trainee_path) 2)
					(get child_trainee_path -3)
					(null)
				)
		))

		;remove the child_trainee from the hierarchyMap assoc based on its parent_trainee, regardless how many layers deep in it is
		(assign_to_entities (assoc
			hierarchyMap
				(if parent_trainee
					;the (remove) opcode doesn't support nested layer removal of assoc keys, so use (rewrite) instead
					(rewrite
						(lambda
							(if (= parent_trainee (current_index))
								(remove (current_value) child_trainee)
								(current_value)
							)
						)
						hierarchyMap
					)

					;else remove the child_trainee directly from this trainee
					(remove hierarchyMap child_trainee)
				)
		))

		;remove path to child trainee from all contained entities in the path,
		;iterating by 2s to include an instance of 'traineeContainer' for each child
		(range
			(lambda (let
				(assoc next_trainee_path (trunc child_trainee_path (current_index 1)) )
				(call_entity next_trainee_path "RemoveChildTraineePaths" (assoc
					child_trainee child_trainee
				))
			))
			2 (- (size child_trainee_path) 1) 2
		)
	)




)