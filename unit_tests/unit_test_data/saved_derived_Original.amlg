(let
	(assoc
		new_entity (first
				(create_entities
					(lambda

						;this is a template of a trainee for Howso
						;it provides the management functions for the trainee
						;
						; a trainee has the following structure of contained entities:
						; 	cases : system generated entity ids
						;   sessions : user specified session ids
						;
						;	each case has the following labels:
						; 		features : model specific feature and its value
						;		.session : session id of case when it was trained
						;		.session_training_index : 0-based index of the case, ordered by training during the session;  is not changed
						;
						;   optional built-in features that cases may have are:
						;	   .case_weight : weight of this case
						;	   .imputed : list of imputed features
						;	   .case_edit_history : assoc of edits to this case
						;
						;	each session has the following labels:
						;		.replay_steps : list of case ids in the order they were trained
						;		.indices_map : map of each cases's session_training_index to its case_id
						;		.metadata : arbitrary dictionary of metadata
						;
						; 	case (entity name = case_id) : { .session: session_id, .session_training_index: trained_instance_index}
						; 	session (entity name = session_id) : { .replay_steps: [ case_id(s) ], .indices_map { s_t_i -> case_id },  .trained_instance_count: number, .metadata: {} }
						(null

							;case labels that are not features and are used for internal processing should be prepended with a period
							##internalLabelSession ".session"
							##internalLabelSessionTrainingIndex ".session_training_index"
							##internalLabelImputed ".imputed"
							##internalLabelCaseEditHistory ".case_edit_history"

							;all the characters that may not be the first character of a feature when training a dataset
							##untrainableFeatureCharacterSet
							(assoc
								! (null)
								"." (null)
								^ (null)
								"#" (null)
							)

							;all the reserved characters that may not be the first character of a feature in any flow
							##reservedFeatureCharacterSet
							(assoc ! (null) ^ (null) "#" (null))

							;returns array of ids of all cases that exist in this trained model
							;by finding all the entities that have a reference to replay sessions
							##AllCases
							(declare
								(assoc
									start_offset 0
									rand_seed (null)
									num (null)
								)
								(if
									(!= (null) num)
									(if
										(!= (null) rand_seed)
										(contained_entities
											(list
												(query_exists internalLabelSession)
												(query_select
													num
													start_offset
													rand_seed
												)
											)
										)
										(contained_entities
											(list
												(query_exists internalLabelSession)
												(query_select
													num
													start_offset
												)
											)
										)
									)

									;else return all
									(contained_entities
										(list
											(query_exists internalLabelSession)
										)
									)
								)
							)

							;returns array of ids of sampled cases with replacement
							##SampleCases
							(declare
								(assoc rand_seed (null) num (null))
								(if
									(!= (null) num)
									(if
										(!= (null) rand_seed)
										(contained_entities
											(list
												(query_exists internalLabelSession)
												(query_sample
													num
													rand_seed
												)
											)
										)
										(contained_entities
											(list
												(query_exists internalLabelSession)
												(query_sample
													num
													(rand)
												)
											)
										)
									)

									;else return samples with replacement on all cases
									(contained_entities
										(list
											(query_exists internalLabelSession)
											(query_sample
												(call GetNumTrainingCases)
												(rand)
											)
										)
									)
								)
							)

							;returns the total number of training cases -- if data is properly cleaned up
							##GetNumTrainingCases
							(compute_on_contained_entities
								(list
									(query_exists internalLabelSession)
									(query_count)
								)
							)

							;parameters: session and session_index
							##GetCaseGivenReplaySession
							(get
								(retrieve_from_entity session ".replay_steps")
								session_index
							)

							;returns an array of ids of all replay sessions that exist in this trained model
							##GetSessionIds
							(contained_entities
								(list
									(query_exists ".replay_steps")
								)
							)

							;returns a list of all of the training sessions, assoc of id->session_id, and whatever other attributes specified.
							;
							;parameters:
							; attributes: optional list of metadata attributes to return from the session
							##GetSessions
							(map
								(lambda
									(let
										(assoc
											session_id (current_value 1)
										)
										(append
											(assoc id session_id)
											(if
												(>
													(size
														attributes
													)
													0
												)

												; create an assoc of attribute -> metadata attribute value
												(zip
													attributes
													(map
														(lambda
															(get
																(retrieve_from_entity
																	session_id
																	".metadata"
																)
																(current_value)
															)
														)
														attributes
													)
												)
												(assoc)
											)
										)
									)
								)
								(call GetSessionIds)
							)

							;set session metadata for a specified session_id.
							;
							;parameters:
							; session_id: id of session to modify.
							; metadata: any arbitrary metadata.
							##SetSessionMetadata
							(declare
								(assoc session_id "none")

								;update this session id's metadata
								(assign_to_entities
									session_id
									(assoc ".metadata" metadata)
								)
							)

							;return list of all session indices for a specified session.
							;session indeces are 0-based index of number of the case for the session used for replays; may change if cases are removed
							;parameters:
							; session : id of session
							##GetSessionIndices
							(indices
								(retrieve_from_entity session ".replay_steps")
							)

							;return list of all session training indices for a specified session.
							;session training indices are 0-based index of the case, ordered by training during the session; is not changed
							;parameters:
							; session : id of session
							##GetSessionTrainingIndices
							(map
								(lambda
									(retrieve_from_entity (current_value) internalLabelSessionTrainingIndex)
								)

								;list of all cases trained for specified session
								(retrieve_from_entity session ".replay_steps")
							)

							;returns assoc with features and cases - a list of lists of all feature values. Retrieves all feature values for cases for
							;all (unordered) sessions in the order they were trained within each session.  If a session is specified, only that session's
							;cases wil be output.
							;
							;parameters:
							; features: list of features to retrieve
							; skip_decoding: set flag to skip decoding feature values into their nominal values for output
							; session: optional session from which to get cases
							; case_indices: optional, list of pair (list) of session id and index, where index is the original 0-based session_training_index of the
							;		case as it was trained. If specified with session, ignores session.
							##RetrieveAllCases
							(declare
								(assoc
									skip_decoding 0
									session (null)
									features (list)
									case_indices (null)
								)
								(if
									(and
										(=
											0
											(size features)
										)
										(>
											(size defaultFeatures)
											0
										)
									)
									(assign
										(assoc features defaultFeatures)
									)
								)

								;if the features list is only 'imputed', pre-pend default fetaures to it if that list is defined
								(if
									(and
										(=
											(size features)
											1
										)
										(=
											internalLabelImputed
											(first features)
										)
										(>
											(size defaultFeatures)
											0
										)
									)
									(assign
										(assoc
											features (append
													defaultFeatures
													features
												)
										)
									)
								)

								;map of accumulated session -> case index id map
								(declare
									(assoc session_indices_map (assoc))
								)
								(declare
									(assoc
										has_datetime_features hasDateTimeFeatures
										cases (if
												(>=
													(size
														case_indices
													)
													1
												)
												(map
													(lambda
														(let
															(assoc
																case_index (last
																		(current_value
																			1
																		)
																	)
																session_id (first
																		(current_value
																			1
																		)
																	)
															)

															;if session_indices_map doesn't have this session, add it
															(if
																(not
																	(contains_index
																		session_indices_map
																		session_id
																	)
																)
																(accum
																	(assoc
																		session_indices_map (associate
																				session_id
																				(retrieve_from_entity
																					session_id
																					".indices_map"
																				)
																			)
																	)
																)
															)

															;get case id from the session's .indices_map
															(get
																session_indices_map
																(list
																	session_id
																	case_index
																)
															)
														)
													)
													case_indices
												)
												(!=
													(null)
													session
												)

												;get all the case ids in the order they were stored for the specified session
												(retrieve_from_entity
													session
													".replay_steps"
												)

												;else get all the cases from all the sessions
												(apply
													"append"
													(map
														(lambda
															(retrieve_from_entity
																(current_value)
																".replay_steps"
															)
														)
														(call
															GetSessionIds
														)
													)
												)
											)
										has_rounded_features hasRoundedFeatures
									)
								)
								(declare
									(assoc
										case_values_list (weave
												(lambda
													(let
														(assoc
															case_feature_values (retrieve_from_entity
																	(first
																		(current_value
																			1
																		)
																	)
																	features
																)
														)
														(if
															(=
																(size
																	case_feature_values
																)
																(size
																	features
																)
															)
															(list
																case_feature_values
															)

															;else don't output anything, filtering out any values that don't match features
															(list)
														)
													)
												)
												cases

												;use weave as a map-filter by specifying null as the second list
												(null)
											)
									)
								)

								;output a map with features and cases
								(assoc
									cases (if
											(and
												hasEncodedFeatures
												(not skip_decoding)
											)

											;decode nominal features if necessary
											(map
												(lambda
													(call
														ConvertToOutput
														(assoc
															feature_values (current_value
																	1
																)
															has_datetime_features has_datetime_features
															features features
															has_rounded_features has_rounded_features
														)
													)
												)
												case_values_list
											)

											;else round if needed
											has_rounded_features
											(map
												(lambda
													(call
														RoundContinuousFeatures
														(assoc
															feature_values (current_value
																	1
																)
															features features
														)
													)
												)
												case_values_list
											)

											;else just return the values
											case_values_list
										)
									features features
								)
							)

							;retrieves the values of the specified entities (defaults to all cases) based on the feature
							; returns an assoc with keys being the entity ids and values being the values of the feature
							##RetrieveCaseValues
							(declare
								(assoc
									entities (call AllCases)
									feature ""
								)
								(map
									(lambda
										(get_value
											(retrieve_from_entity (current_index) feature)
										)
									)
									(zip entities)
								)
							)

							;Compute and store case weights for all cases if there are any features with the id_feature attribute set to true
							;Each case weights as the reciprocal of the count of the id feature value in the dataset.  If there are multiple
							;id features, the product of the weights of all the id features is the case weight, which is stored
							;in each case into the .case_weight feature
							##ComputeAndStoreIdFeatureCaseWeights
							(let
								(assoc id_features (list))

								;accumulate a list of id features that are explicitly not unique, since uniqueness preserves id-based weighting
								(map
									(lambda
										(if
											(and
												(get
													featureAttributes
													(list
														(current_value
															1
														)
														"id_feature"
													)
												)
												(not
													(contains_index
														uniqueNominalsMap
														(current_value)
													)
												)
											)
											(accum
												(assoc
													id_features (current_value
															1
														)
												)
											)
										)
									)
									(indices categoricalFeaturesSet)
								)
								(if
									(=
										0
										(size id_features)
									)
									(conclude)
								)

								;if model has ID features, set the hasPopulatedCaseWeight flag
								(assign_to_entities
									(assoc hasPopulatedCaseWeight (true))
								)
								(declare
									(assoc
										feature_case_weight_map (map
												(lambda
													(let
														(assoc
															feature (current_index
																	1
																)
														)

														;store class counts as weights (reciprocal of count) for all cases for each id feature
														(map
															(lambda
																(/
																	1
																	(current_value)
																)
															)

															;grab the un-weighted count of each class
															(compute_on_contained_entities
																(list
																	(query_value_masses
																		feature
																		(null)

																		;as numeric value
																		(or
																			(not
																				(contains_index
																					nominalsSet
																					feature
																				)
																			)
																			(contains_index
																				nonStringNominalFeaturesMap
																				feature
																			)
																		)
																	)
																)
															)
														)
													)
												)
												(zip id_features)
											)
										all_cases_map (zip
												(call AllCases)
											)
									)
								)
								(if
									(=
										1
										(size id_features)
									)
									(let
										(assoc
											feature (first id_features)
										)

										;store .case_weight to be same as the weight for the one id feature
										(call
											StoreCaseValues
											(assoc
												case_values_map (map
														(lambda
															(get
																feature_case_weight_map
																(list
																	feature
																	(retrieve_from_entity
																		(current_index
																			1
																		)
																		feature
																	)
																)
															)
														)
														all_cases_map
													)
												label_name ".case_weight"
											)
										)
									)

									;else there are several id features, compute and store .case_weight
									;as the product of all id feature case weights for each case
									(call
										StoreCaseValues
										(assoc
											case_values_map (map
													(lambda
														(let
															(assoc
																case_id (current_index
																		1
																	)
															)

															;multiply all the case weights for all the id features
															(apply
																"*"

																;list of all the case weights for all the id features
																(map
																	(lambda
																		(get
																			feature_case_weight_map
																			(list
																				(current_value
																					1
																				)
																				(retrieve_from_entity
																					case_id
																					(current_value
																						1
																					)
																				)
																			)
																		)
																	)
																	id_features
																)
															)
														)
													)
													all_cases_map
												)
											label_name ".case_weight"
										)
									)
								)
							)

							;compute and cache all the expected values for all the features
							; parameters:
							; features: list of features
							; use_case_weights: flag, if true will also compute cache values using the specified weight_feature
							##CacheExpectedValuesAndProbabilities
							(declare
								(assoc features (list) use_case_weights (false))
								(accum_to_entities
									(assoc
										expectedValuesMap (assoc
												".none" ||(map
														(lambda
															(let
																(assoc
																	feature (current_index
																			1
																		)
																)
																(call
																	CalculateFeatureExpectedValue
																	(assoc
																		output_instead_of_store (true)
																		output_nominal_class_counts (contains_index
																				categoricalFeaturesSet
																				feature
																			)
																		weight_feature ".none"
																		feature feature
																	)
																)
															)
														)

														;iterate over all unique provided context and action features
														(zip
															features
														)
													)
											)
									)
								)
								(if
									use_case_weights
									(accum_to_entities
										(assoc
											expectedValuesMap (associate
													weight_feature
													||(map
														(lambda
															(let
																(assoc
																	feature (current_index
																			1
																		)
																)
																(call
																	CalculateFeatureExpectedValue
																	(assoc
																		output_instead_of_store (true)
																		output_nominal_class_counts (contains_index
																				categoricalFeaturesSet
																				feature
																			)
																		weight_feature weight_feature
																		feature feature
																	)
																)
															)
														)

														;iterate over all unique provided context and action features
														(zip
															features
														)
													)
												)
										)
									)
								)
								(accum_to_entities
									(assoc
										nominalClassProbabilitiesMap (assoc
												".none" ||(map
														(lambda
															(let
																(assoc
																	feature (current_index
																			1
																		)
																)
																(call
																	ComputeModelNominalClassProbabilities
																	(assoc
																		weight_feature ".none"
																		feature feature
																		store_global_probabilities (false)
																	)
																)
															)
														)

														;iterate over all unique provided context and action features that are categorical
														(zip
															(filter
																(lambda
																	(contains_index
																		categoricalFeaturesSet
																		(current_value)
																	)
																)
																features
															)
														)
													)
											)
									)
								)
								(if
									use_case_weights
									(accum_to_entities
										(assoc
											nominalClassProbabilitiesMap (associate
													weight_feature
													||(map
														(lambda
															(let
																(assoc
																	feature (current_index
																			1
																		)
																)
																(call
																	ComputeModelNominalClassProbabilities
																	(assoc
																		weight_feature weight_feature
																		feature feature
																		store_global_probabilities (false)
																	)
																)
															)
														)

														;iterate over all unique provided context and action features that are categorical
														(zip
															(filter
																(lambda
																	(contains_index
																		categoricalFeaturesSet
																		(current_value)
																	)
																)
																features
															)
														)
													)
												)
										)
									)
								)
								(declare
									(assoc
										num_cases (call GetNumTrainingCases)
									)
								)

								;process all features, caching their min, max values as well as how many nulls there are and the ratio of cases / non-nulls
								(accum_to_entities
									(assoc
										featureNullRatiosMap (map
												(lambda
													(let
														(assoc
															min 0
															feature (current_index
																	1
																)
															max 0
															num_nulls 0
														)
														(assign
															(assoc
																min (retrieve_from_entity
																		(first
																			(contained_entities
																				(list
																					(query_min
																						feature
																						1
																					)
																				)
																			)
																		)
																		feature
																	)
																max (retrieve_from_entity
																		(first
																			(contained_entities
																				(list
																					(query_max
																						feature
																						1
																					)
																				)
																			)
																		)
																		feature
																	)
																num_nulls (size
																		(contained_entities
																			(list
																				(query_equals
																					feature
																					(null)
																				)
																			)
																		)
																	)
															)
														)
														(assoc
															non_null_ratio (/
																	num_cases
																	(-
																		num_cases
																		num_nulls
																	)
																)
															min min
															null_residual (if
																	(contains_index
																		cyclicFeaturesMap
																		feature
																	)
																	(get
																		cyclicFeaturesMap
																		feature
																	)
																	(-
																		max
																		min
																	)
																)
															max max
															num_nulls num_nulls
														)
													)
												)
												(zip features)
											)
									)
								)

								;cache counts of ordinal features
								(if
									(and
										(>
											(size ordinalFeatures)
											0
										)
										staleOrdinalValuesCount
									)
									(call UpdateOrdinalFeaturesMap)
								)
							)

							;increments entity's label_name by the value specified by increment
							##IncrementEntityCaseValue
							(declare
								(assoc
									entities (null)
									increment 1
									label_name ""
								)
								(map
									(lambda
										(if
											(contains_label (current_value) label_name)

											;has label, just increment
											(assign_to_entities
												(current_value)
												(associate
													label_name
													(+
														(retrieve_from_entity
															(current_value
																1
															)
															label_name
														)
														increment
													)
												)
											)

											;else need to append the label to the entity
											(assign_entity_roots
												(current_value)
												(set_type
													(append
														(values
															(retrieve_entity_root
																(current_value)
																1
															)
														)
														(list
															(set_labels
																increment
																(list
																	label_name
																)
															)
														)
													)
													(null)
												)
											)
										)
									)
									entities
								)
							)

							;set the list of ordinal features, or clears it if empty list is specified
							;parameters:
							; ordinal_features: list of ordinal features
							##SetOrdinalFeatures
							(declare
								(assoc ordinal_features (list))
								(if
									(=
										0
										(size ordinal_features)
									)
									(assign_to_entities
										(assoc
											ordinalFeatures (list)
											categoricalFeaturesSet (remove
													categoricalFeaturesSet
													ordinalFeatures
												)
											ordinalNumericFeaturesSet (assoc)
										)
									)
									(assign_to_entities
										(assoc
											ordinalFeatures ordinal_features
											categoricalFeaturesSet (append
													categoricalFeaturesSet
													(zip
														ordinal_features
													)
												)
											ordinalNumericFeaturesSet (remove
													(zip
														ordinal_features
													)
													(indices
														ordinalStringToOrdinalMap
													)
												)
										)
									)
								)

								;returns whether or not the trainee has ordinalFeatures
								(if
									(>
										(size ordinalFeatures)
										0
									)
									(true)
									(false)
								)
							)

							; set the list of nominal features. If nominal features already exist, appends to them. passing in an empty list disables nominal features
							;parameters
							; nominal_features: list of nominal features
							##SetNominalFeatures
							(declare
								(assoc nominal_features (list))

								;clear the nominals if empty list is passed in
								(if
									(=
										0
										(size nominal_features)
									)
									(assign_to_entities
										(assoc
											categoricalFeaturesSet (remove
													categoricalFeaturesSet
													(indices
														nominalsSet
													)
												)
											nominalsSet (assoc)
										)
									)

									;else set the nominal value maps
									(assign_to_entities
										(assoc
											categoricalFeaturesSet (append
													categoricalFeaturesSet
													(zip
														nominal_features
													)
												)
											nominalsSet (zip nominal_features)
										)
									)
								)

								;invalidate cached class probabilities
								(assign_to_entities
									(assoc nominalClassProbabilitiesMap (assoc))
								)
							)

							;decodes raw enumerated feature values into their nominal values for all nominal features in a list of cases and returns the list of cases with the values
							;parameters
							; cases: list of cases (assocs of features->values)
							##ConvertToOutputFromCaseList
							(declare

								;each case is an assoc of feature -> raw feature value
								(assoc cases (list))
								(declare
									(assoc
										has_datetime_features hasDateTimeFeatures
										has_string_ordinals hasStringOrdinals
										has_rounded_features hasRoundedFeatures
										has_booleans hasBooleans
									)
								)
								(map
									(lambda
										(let
											(assoc
												case_values (values
														(current_value
															1
														)
													)
												case_features (indices
														(current_value
															1
														)
													)
											)

											;output the case with the values decoded
											(zip
												case_features
												(call
													ConvertToOutput
													(assoc
														feature_values case_values
														has_datetime_features has_datetime_features
														has_string_ordinals has_string_ordinals
														features case_features
														has_rounded_features has_rounded_features
														has_booleans has_booleans
													)
												)
											)
										)
									)
									cases
								)
							)

							;decodes raw enumerated feature values into their nominal values for the provided list of features and values, returns the decoded list of values
							;parameters
							; features: list of features
							; feature_values: corresponding list of values for each features
							; has_rounded_features: flag, if true will round features that need rounding
							; has_datetime_features: flag, if true will decode features to the specified format
							; has_string_ordinals: flag, if true will decode string ordinal features from ordinal value to string
							; original_context_map: optional, map of original context feature -> original context values, used to output original unencoded nominal values
							##ConvertToOutput
							(declare
								(assoc
									feature_values (list)
									has_datetime_features hasDateTimeFeatures
									has_string_ordinals hasStringOrdinals
									original_context_map (assoc)
									features (list)
									has_rounded_features hasRoundedFeatures
									has_booleans hasBooleans
								)
								(let
									(assoc
										decoded_values (map
												(lambda
													(if
														(and
															has_rounded_features
															(contains_index
																featureRoundingMap
																(current_value)
															)
														)
														(let
															(assoc
																rounded_value (get
																		feature_values
																		(current_index
																			1
																		)
																	)
															)

															;leave nulls as-is to prevent them from becoming .nan
															(if
																(=
																	(null)
																	rounded_value
																)
																(null)
																(seq
																	(assign
																		(assoc
																			rounded_value
																				;generate a statement in the format of (round <value> <significant_digits> <decimal_points>)
																				(apply
																					"round"
																					(append
																						rounded_value
																						(get
																							featureRoundingMap
																							(current_value
																								1
																							)
																						)
																					)
																				)
																		)
																	)
																	(if
																		(contains_index
																			cyclicFeaturesMap
																			(current_value)
																		)
																		(mod
																			rounded_value
																			(get
																				cyclicFeaturesMap
																				(current_value)
																			)
																		)
																		rounded_value
																	)
																)
															)
														)
														(and
															has_datetime_features
															(contains_index
																featureDateTimeMap
																(current_value)
															)
														)

														;decode datetime from number into readable date of specified locale
														(if
															(!=
																(null)
																(get
																	feature_values
																	(current_index)
																)
															)
															(format
																(get
																	feature_values
																	(current_index)
																)
																"number"
																(get
																	featureDateTimeMap
																	(list
																		(current_value
																			1
																		)
																		"date_time_format"
																	)
																)
																""
																(get
																	featureDateTimeMap
																	(list
																		(current_value
																			1
																		)
																		"locale"
																	)
																)
															)
															(null)
														)
														(and
															has_string_ordinals
															(contains_index
																ordinalOrdinalToStringMap
																(current_value)
															)
														)
														(get
															ordinalOrdinalToStringMap
															(list
																(current_value
																	1
																)
																(get
																	feature_values
																	(current_index
																		1
																	)
																)
															)
														)
														(and
															has_booleans
															(=
																"boolean"
																(get
																	nonStringNominalFeaturesMap
																	(current_value)
																)
															)
														)
														(if
															(!=
																(null)
																(get
																	feature_values
																	(current_index)
																)
															)
															(=
																1
																(get
																	feature_values
																	(current_index)
																)
															)
															(null)
														)

														;else return the original value
														(get
															feature_values
															(current_index)
														)
													)
												)
												features
											)
									)
									(if
										(and hasSubstituteFeatureValues substitute_output)
										(call
											SubstituteFeatureValues
											(assoc
												feature_values decoded_values
												features features
											)
										)

										;else output the decoded values
										decoded_values
									)
								)
							)

							;output the time delta value decoded per feature definition
							;parameters:
							; feature: feature for which to decode the time delta
							; feature_value: input value in seconds
							##DecodeTimeDelta
							(declare
								(assoc feature "" feature_value (null))
								(declare
									(assoc
										delta_format (get
												featureDateTimeMap
												(list
													feature
													"time_delta_format"
												)
											)
									)
								)
								(if
									(or
										(= delta_format (null))
										(= delta_format "seconds")
									)
									feature_value
									(= delta_format "milliseconds")
									(* feature_value 1000)
									(= delta_format "minutes")
									(/ feature_value 60)
									(= delta_format "hours")
									(/ feature_value 3600)
									(= delta_format "days")
									(/ feature_value 86400)
									(= delta_format "weeks")
									(/ feature_value 604800)
									(= delta_format years)
									(/ feature_value 31556925.445)

									;if provided an invalid input, default is output as seconds
									feature_value
								)
							)

							;rounds any continuous features per the rounding attributes set in featureRoundingMap
							;parameters
							; features: list of features
							; feature_values: corresponding list of values for each features
							##RoundContinuousFeatures
							(declare
								(assoc feature_values (list) features (list))
								(map
									(lambda
										(if
											(contains_index featureRoundingMap (current_value))
											(let
												(assoc
													rounded_value (get
															feature_values
															(current_index
																1
															)
														)
												)

												;leave nulls as-is to prevent them from becoming .nan
												(if
													(=
														(null)
														rounded_value
													)
													(null)
													(seq
														(assign
															(assoc
																rounded_value
																	;generate a statement in the format of (round <value> <significant_digits> <decimal_points>)
																	(apply
																		"round"
																		(append
																			rounded_value
																			(get
																				featureRoundingMap
																				(current_value
																					1
																				)
																			)
																		)
																	)
															)
														)
														(if
															(contains_index
																cyclicFeaturesMap
																(current_value)
															)
															(mod
																rounded_value
																(get
																	cyclicFeaturesMap
																	(current_value)
																)
															)
															rounded_value
														)
													)
												)
											)
											(get feature_values (current_index))
										)
									)
									features
								)
							)

							;encodes nominal features into enumerated values which are what is stored for each case, if a nominal value has no encoding, it's set to -1
							;returns a list of encoded feature values
							;
							;parameters:
							; features: list of features
							; feature_values: current values of each feature
							##ConvertFromInput
							(declare
								(assoc feature_values (list) features (list))
								(assign
									(assoc
										feature_values (map
												(lambda
													(if
														(contains_index
															encodingNeededFeaturesSet
															(current_value)
														)
														(if
															(=
																(null)
																(get
																	feature_values
																	(current_index)
																)
															)
															(null)
															(if

																;stringify all nominal values
																(contains_index
																	stringNominalFeaturesSet
																	(current_value)
																)
																(concat
																	(get
																		feature_values
																		(current_index)
																	)
																)

																;if it's a datetime, encode datetime by converting string date time into seconds
																(contains_index
																	featureDateTimeMap
																	(current_value)
																)
																(format
																	(get
																		feature_values
																		(current_index)
																	)
																	(get
																		featureDateTimeMap
																		(list
																			(current_value
																				1
																			)
																			"date_time_format"
																		)
																	)
																	"number"
																	(get
																		featureDateTimeMap
																		(list
																			(current_value
																				1
																			)
																			"locale"
																		)
																	)
																	""
																)

																;else it's a string ordinal, convert from string to ordinal value
																(contains_index
																	ordinalStringToOrdinalMap
																	(current_value)
																)
																(get
																	ordinalStringToOrdinalMap
																	(list
																		(current_value
																			1
																		)
																		(get
																			feature_values
																			(current_index
																				1
																			)
																		)
																	)
																)
																(=
																	"boolean"
																	(get
																		nonStringNominalFeaturesMap
																		(current_value)
																	)
																)
																(+
																	(get
																		feature_values
																		(current_index)
																	)
																)

																;else return the value as-is
																(get
																	feature_values
																	(current_index)
																)
															)
														)

														;else return the value as-is
														(get
															feature_values
															(current_index)
														)
													)
												)
												features
											)
									)
								)

								;return the updated values
								feature_values
							)

							;update ordinalFeaturesValuesMap label by storing the sorted list of unique ordinal values for each ordinal feature
							##UpdateOrdinalFeaturesMap
							(seq

								;for each ordinal feature, pull all the values, make the list unique by zipping it and then sort and store
								(declare
									(assoc
										ordinal_features_values_map (map
												(lambda
													(call
														UpdateOrdinalFeaturesMapForFeature
														(assoc
															feature (current_index
																	1
																)
														)
													)
												)
												(zip ordinalFeatures)
											)
									)
								)
								(declare
									(assoc
										ordinal_features_ranges_map (map
												(lambda

													;if featue is cyclic, the range is the cycle length
													(if
														(contains_index
															cyclicFeaturesMap
															(current_index)
														)
														(get
															cyclicFeaturesMap
															(current_index)
														)

														;else it's the range of the values
														(-
															(last
																(current_value)
															)
															(first
																(current_value)
															)
														)
													)
												)
												ordinal_features_values_map
											)
									)
								)

								;store both maps and clear the stale flag since ordinalFeaturesValuesMap is now up-to-date
								(assign_to_entities
									(assoc
										ordinalFeaturesValuesMap ordinal_features_values_map
										ordinalFeaturesRangesMap ordinal_features_ranges_map
										staleOrdinalValuesCount (false)
									)
								)
							)

							;update ordinalFeaturesValuesMap label for a specified feature if store_values is true
							;outputs the list of sorted_feature_values for this feature
							;parameters:
							; feature: name of feature for which to output sorted feature values
							; store_values: flag, when true will update the model with the new values as well
							##UpdateOrdinalFeaturesMapForFeature
							(declare
								(assoc store_values (false))

								;pull all the values for this feature, make the list unique by zipping it and then sort the indices to store as a sorted unique
								;list of feature values
								(declare
									(assoc
										sorted_feature_values (sort
												(map

													;convert the indices to numbers since ordinals are numeric
													(lambda
														(+
															(current_value)
														)
													)

													;indices of the zipped list give us only unique ordinal values
													(indices

														;retrieve the list of all unique ordinal values from all the cases
														(compute_on_contained_entities
															(list
																(query_value_masses
																	feature
																)
															)
														)
													)
												)
											)
									)
								)
								(if
									store_values
									(accum_to_entities
										(assoc
											ordinalFeaturesValuesMap (associate
													feature
													sorted_feature_values
												)
											ordinalFeaturesRangesMap (associate
													feature
													(if
														(contains_index
															cyclicFeaturesMap
															feature
														)
														(get
															cyclicFeaturesMap
															feature
														)
														(-
															(last
																sorted_feature_values
															)
															(first
																sorted_feature_values
															)
														)
													)
												)
										)
									)
								)

								;output sorted values for this ordinal feature
								sorted_feature_values
							)

							;set cyclic feature lengths.  if passed in an empty assoc, clears out cyclic features.  all cycles start at 0
							;parameters:
							; features: assoc of feature -> cycle length
							;example: (assoc "day" 7 "degrees" 360)
							##SetCyclicFeatures
							(declare
								(assoc features (assoc))
								(if
									(=
										0
										(size features)
									)
									(assign_to_entities
										(assoc
											hasCyclicFeatures 0
											cyclicFeaturesMap (null)
										)
									)
									(assign_to_entities
										(assoc
											hasCyclicFeatures 1
											cyclicFeaturesMap features
										)
									)
								)

								;model definition has changed so clear out these cached value
								(assign_to_entities
									(assoc
										averageModelCaseEntropyRemoval (null)
										averageModelCaseEntropyAddition (null)
										averageModelCaseDistanceContribution (null)
										storedCaseConvictionsFeatureAddition (null)
									)
								)

								;returns whether or not the trainee has cyclic features
								hasCyclicFeatures
							)

							;convert string date to epoch
							;
							;parameters:
							; date: date passed in as a string
							; feature: name of feature corresponding to the datetime format for the date
							; feature_datetime_map: optional map of feature -> datetime format, if unspecified uses model's featureDateTimeMap
							##ConvertDateToEpoch
							(declare
								(assoc
									date ""
									feature ""
									feature_datetime_map featureDateTimeMap
								)
								(format
									date
									(get
										feature_datetime_map
										(list feature "date_time_format")
									)
									"number"
									(get
										feature_datetime_map
										(list feature "locale")
									)
									""
								)
							)

							;helper method that returns a full signed 64 bit integer as a string
							; note that this does not generate the full range; it does not generate the top 6,854,775,807 values due to rounding
							##GenerateInt64String
							(let
								(assoc
									least_significant (floor
											(rand 10000000000)
										)
									most_significant (floor
											(rand 922337204)
										)
								)

								;zeros to prepend the least significant with
								(declare
									(assoc
										prepend_zeros (-
												9
												(floor
													(log
														least_significant
														10
													)
												)
											)
									)
								)
								(if
									(= 0 most_significant)
									least_significant

									;in the off chance that 0s need prepending
									(if
										prepend_zeros
										(apply
											"concat"
											(append
												most_significant
												(map
													"0"
													(range
														1
														prepend_zeros
													)
												)
												least_significant
											)
										)
										(concat most_significant least_significant)
									)
								)
							)

							;replaces feature values with their corresponding substitution for the provided list of features and values, returns the substituted list of values
							;parameters
							; features: list of features
							; feature_values: corresponding list of values for each features
							##SubstituteFeatureValues
							(declare
								(assoc feature_values (list) features (list))
								(map
									(lambda

										;if this has a substitution, return that
										(if
											(and
												(contains_index
													substitutionValueMap
													(current_value)
												)
												(!=
													(null)
													(get
														feature_values
														(current_index)
													)
												)
											)

											;walk the map via feature and the value to get the substitution value
											(if
												(contains_index
													substitutionValueMap
													(list
														(current_value
															1
														)
														(get
															feature_values
															(current_index
																1
															)
														)
													)
												)
												(get
													substitutionValueMap
													(list
														(current_value
															1
														)
														(get
															feature_values
															(current_index
																1
															)
														)
													)
												)

												;else no substitution is stored for this value, create one and return that
												(let
													(assoc
														new_sub (call
																GenerateInt64String
															)
													)

													;ensure the value is unique; if it's not, generate a new value
													(while
														(contains_index
															substitutionValueMap
															new_sub
														)
														(assign
															(assoc
																new_sub (call
																		GenerateInt64String
																	)
															)
														)
													)
													new_sub
												)
											)

											;else this feature has no substitutions or value is null, just return the raw value
											(get feature_values (current_index))
										)
									)
									features
								)
							)

							;replaces substituted feature values with their corresponding actual nominal values, returns the list of un-substituted values
							;parameters
							; features: list of features
							; feature_values: list of values for each features
							##UnsubstituteFeatureValues
							(declare
								(assoc feature_valuse (list) features (list))
								(map
									(lambda

										;if this has a substitution, return that
										(if
											(and
												(contains_index
													unSubstituteValueMap
													(current_value)
												)
												(!=
													(null)
													(get
														feature_values
														(current_index)
													)
												)
											)

											;walk the map via feature and the value to get the substitution value
											(if
												(contains_index
													unSubstituteValueMap
													(list
														(current_value
															1
														)
														(get
															feature_values
															(current_index
																1
															)
														)
													)
												)
												(get
													unSubstituteValueMap
													(list
														(current_value
															1
														)
														(get
															feature_values
															(current_index
																1
															)
														)
													)
												)

												;else no substitution is stored for this value, return raw value
												(get
													feature_values
													(current_index)
												)
											)

											;else this feature has no substitutions or value is null, just return the raw value
											(get feature_values (current_index))
										)
									)
									features
								)
							)

							;parameters:
							; substitution_value_map: assoc of feature -> assoc of value -> substitution
							;	If this map is null, all substitutions will be disabled and cleared
							;	If any feature in the substitution_value_map has a missing or empty assoc of substitutions, substitution values will immeditally be generated
							##SetSubstituteFeatureValues
							(seq
								(assign_to_entities
									(assoc
										substitutionValueMap (map
												(lambda
													(let
														(assoc
															generated_substitutions_map (assoc)
															sub_feature (current_index
																	1
																)
															sub_feature_map (current_value
																	1
																)
														)

														;if the substitution map has no substitution values specified for a feature, generate them here
														(if
															(or
																(=
																	sub_feature_map
																	(null)
																)
																(=
																	sub_feature_map
																	(assoc)
																)
															)
															(let
																(assoc
																	all_unique_feature_values (indices
																			(compute_on_contained_entities
																				(list
																					(query_value_masses
																						sub_feature
																						(null)
																						(contains_index
																							nonStringNominalFeaturesMap
																							sub_feature
																						)
																					)
																				)
																			)
																		)
																)
																(assign
																	(assoc
																		generated_substitutions_map (zip
																				(map
																					(lambda
																						(call
																							GenerateInt64String
																						)
																					)
																					(range
																						1
																						(size
																							all_unique_feature_values
																						)
																					)
																				)
																			)
																	)
																)

																;if by some small chance any duplicates were generated, accumulate enough new uniques to replace the dupes
																(while
																	(<
																		(size
																			generated_substitutions_map
																		)
																		(size
																			all_unique_feature_values
																		)
																	)

																	;accumulate-append new generated subsitutions to the map, dupclicates will be clobbered
																	(accum
																		(assoc
																			generated_substitutions_map
																				;random new substitution that is almost a full signed 64 bit integer
																				(associate
																					(call
																						GenerateInt64String
																					)
																					(null)
																				)
																		)
																	)
																)

																;store an assoc of all unique feature values -> unique generated substitution values
																(zip
																	all_unique_feature_values
																	(indices
																		generated_substitutions_map
																	)
																)
															)

															;store the provided substitution map, but first populate any missing substitutions with generated ones
															(let

																;pull the list of all the unique nominal classes
																(assoc
																	missing_values
																		;filter out all nominal values to leave only the missing ones that are not in the user provided map
																		(filter
																			(lambda
																				(not
																					(contains_index
																						sub_feature_map
																						(current_value)
																					)
																				)
																			)

																			;iterate over all the known nominal values
																			(indices
																				(compute_on_contained_entities
																					(list
																						(query_value_masses
																							sub_feature
																							(null)
																							(contains_index
																								nonStringNominalFeaturesMap
																								sub_feature
																							)
																						)
																					)
																				)
																			)
																		)
																)
																(if
																	(>
																		(size
																			missing_values
																		)
																		0
																	)
																	(seq
																		(assign
																			(assoc
																				generated_substitutions_map (zip
																						(map
																							(lambda
																								(call
																									GenerateInt64String
																								)
																							)
																							(range
																								1
																								(size
																									missing_values
																								)
																							)
																						)
																					)
																			)
																		)

																		;if by some small chance any duplicates were generated, accumulate enough new uniques to replace the dupes
																		(while
																			(<
																				(size
																					generated_substitutions_map
																				)
																				(size
																					missing_values
																				)
																			)

																			;accumulate-append new generated subsitutions to the map, dupclicates will be clobbered
																			(accum
																				(assoc
																					generated_substitutions_map
																						;random new substitution that is almost a full signed 64 bit integer
																						(associate
																							(call
																								GenerateInt64String
																							)
																							(null)
																						)
																				)
																			)
																		)

																		;append the autogenerated substitutions for the missing values to the provided map
																		(accum
																			(assoc
																				sub_feature_map (zip
																						missing_values
																						(indices
																							generated_substitutions_map
																						)
																					)
																			)
																		)
																	)
																)
																sub_feature_map
															)
														)
													)
												)
												substitution_value_map
											)
										hasSubstituteFeatureValues (>
												(size substitution_value_map)
												0
											)
									)
								)

								;store the backwards map for each feature as well
								(assign_to_entities
									(assoc
										hasEncodedFeatures (if
												hasSubstituteFeatureValues
												(true)
												(or
													hasBooleans
													hasRoundedFeatures
													(size
														ordinalOrdinalToStringMap
													)
													(size
														featureDateTimeMap
													)
												)
											)
										unSubstituteValueMap (map
												(lambda
													(zip
														(values
															(current_value)
														)
														(indices
															(current_value)
														)
													)
												)
												substitutionValueMap
											)
									)
								)
								(accum_to_entities
									(assoc revision 1)
								)
								(true)
							)

							;returns the substitution map
							##GetSubstituteFeatureValues
							(retrieve_from_entity "substitutionValueMap")

							;records an entire session in one call, does not do any filtering.
							; parameters:
							; input_cases : list of cases, ie a list of lists of values.
							; features : the list of features.
							; derived_features: optional list of features to derive in the specified order. If this list is not provided, features with
							;	   the 'auto_derive_on_train' feature attribute set to True will be auto-derived. If provided an empty list, will not derive any features.
							;	   Any derived_features that are already in the 'features' list will not be derived since their values are being explicitly provided.
							; session: the session label to record these cases to.  If not specified, refers to this entity's label of same name.
							; input_is_substituted : flag, if set to true assumes provided categorical (nominal or ordinal) feature values already been substituted.
							; ablatement_params: assoc of feature -> threshold_type
							; 	threshold_type is one of:
							;		['exact'] - don't train if prediction matches exactly
							;		['tolerance', MIN, MAX] - don't train if prediction >= (case value - MIN) and prediction <= (case value + MAX)
							;		['relative', PERCENT] - don't train if abs(prediction - case value) / prediction <= PERCENT
							;		['residual'] - don't train if if abs(prediction - case value) <= feature residual
							; series: optional, name of series to pull features and case values from internal series storage.  If specified, trains on all cases that are
							;		stored in the internal series store for the specified series. The trained feature set is the combined features from storage
							;		and the passed in features.  If input_cases is of length one, the value(s) of this case are appended to all cases in the series.
							;		If input_cases is the same length as the series, the value of each case in input_cases is applied in order to each of the cases in the
							;		series.
							; allow_training_reserved_features: flag, If true, skips check whether specified feature names start with reserved characters.
							; accumulate_weight_feature: name of feature into which to accumulate neighbors' influences as weight for ablated cases. If unspecified, will not accumulate weights.
							; train_weights_only: flag, if set to true, and accmuulate_weight_feature is provided, will not train on the cases, but instead accumulate all of their neighbor weights.
							##Train
							(declare
								(assoc
									derived_features (null)
									input_cases (list)
									allow_training_reserved_features (false)
									series (null)
									accumulate_weight_feature (null)
									input_is_substituted (false)
									session (null)
									features (list)
									ablatement_params (null)
									train_weights_only (false)
								)

								;unsure that session is set to some string value
								(if
									(= (null) session)
									(assign
										(assoc session "none")
									)
								)

								;empty ablatement params should just be null
								(if
									(= (assoc) ablatement_params)
									(assign
										(assoc ablatement_params (null))
									)
								)

								;create the training session if it does not already exist
								(if
									(not
										(contains_entity session)
									)

									;overwrite the session variable in case creating a new session without a name
									(assign
										(assoc
											session (first
													(create_entities
														session
														(lambda
															(null
																###.replay_steps
																(list)
																###.indices_map
																(assoc)
																###.trained_instance_count 0
																###.metadata
																(assoc)
															)
														)
													)
												)
										)
									)
								)

								;recorded data for the current session
								(declare
									(assoc
										reserved_feature_names (if
												allow_training_reserved_features
												(list)

												;filter out any normal features, leaving only invalid feature names that start with reserved characters
												(filter
													(lambda
														(contains_index
															untrainableFeatureCharacterSet
															(first
																(current_value)
															)
														)
													)
													features
												)
											)
										cur_session_data (retrieve_from_entity session ".replay_steps")
									)
								)

								;if any features are in the reserved list, can't train, output the error message
								(if
									(>
										(size reserved_feature_names)
										0
									)
									(conclude
										(assoc
											num_trained 0
											error (concat
													"The following features should not start with characters '.' '^' '!' or '#' : "

													;change list of features into a space-separated list of feature names
													(apply
														"concat"
														(weave
															reserved_feature_names
															(map
																" "
																(range
																	1
																	(size
																		reserved_feature_names
																	)
																)
															)
														)
													)
												)
											status (null)
											ablated_indices (list)
										)
									)
								)
								(declare
									(assoc
										series_cases (if
												(!=
													(null)
													series
												)
												(get
													seriesStore
													series
												)
											)
										status_output (null)
										cur_session_case_indices_map (retrieve_from_entity session ".indices_map")
										ablated_indices_list (list)
										message (null)
										trained_instance_count (retrieve_from_entity session ".trained_instance_count")
									)
								)
								(if
									(!= (null) series)
									(if
										(=
											(size series_cases)
											0
										)
										(assign
											(assoc
												input_cases (null)
												message "Specified series does not exist"
											)
										)

										;if input cases don't match the number of cases stored in series
										(and
											(>
												(size input_cases)
												1
											)
											(!=
												(size input_cases)
												(size series_cases)
											)
										)
										(assign
											(assoc
												input_cases (null)
												message "input_cases do not match length of specified series"
											)
										)
									)
								)

								;if bad input, ie, size of series does not match the training input_cases, don't train anything
								(if
									(= (null) input_cases)
									(conclude
										(assoc
											num_trained 0
											error message
											status status_output
											ablated_indices ablated_indices_list
										)
									)
								)

								;unsubstitute nominal feature values if necessary
								(if
									(and input_is_substituted hasSubstituteFeatureValues)
									(assign
										(assoc
											input_cases (map
													(lambda
														(call
															UnsubstituteFeatureValues
															(assoc
																feature_values (current_value
																		1
																	)
																features features
															)
														)
													)
													input_cases
												)
										)
									)
								)
								(declare
									(assoc
										encode_features_on_train (retrieve_from_entity "hasFeaturesNeedEncodingFromInput")
									)
								)

								;encode all cases in bulk if either training on accumulated weights only or training from series
								;because series trained cases are alredy encoded.
								(if
									(and
										encode_features_on_train
										(or
											(size series_cases)
											(and train_weights_only accumulate_weight_feature)
										)
									)
									(assign
										(assoc
											input_cases (map
													(lambda
														(let
															(assoc
																feature_values (current_value
																		1
																	)
															)
															(map
																(lambda
																	(if
																		(contains_index
																			encodingNeededFeaturesSet
																			(current_value)
																		)
																		(if
																			(=
																				(null)
																				(get
																					feature_values
																					(current_index)
																				)
																			)
																			(null)
																			(if

																				;stringify all nominal values
																				(contains_index
																					stringNominalFeaturesSet
																					(current_value)
																				)
																				(concat
																					(get
																						feature_values
																						(current_index)
																					)
																				)

																				;if it's a datetime, encode datetime by converting string date time into seconds
																				(contains_index
																					featureDateTimeMap
																					(current_value)
																				)
																				(format
																					(get
																						feature_values
																						(current_index)
																					)
																					(get
																						featureDateTimeMap
																						(list
																							(current_value
																								1
																							)
																							"date_time_format"
																						)
																					)
																					"number"
																					(get
																						featureDateTimeMap
																						(list
																							(current_value
																								1
																							)
																							"locale"
																						)
																					)
																					""
																				)

																				;else it's a string ordinal, convert from string to ordinal value
																				(contains_index
																					ordinalStringToOrdinalMap
																					(current_value)
																				)
																				(get
																					ordinalStringToOrdinalMap
																					(list
																						(current_value
																							1
																						)
																						(get
																							feature_values
																							(current_index
																								1
																							)
																						)
																					)
																				)
																				(=
																					"boolean"
																					(get
																						nonStringNominalFeaturesMap
																						(current_value)
																					)
																				)
																				(+
																					(get
																						feature_values
																						(current_index)
																					)
																				)

																				;else return the value as-is
																				(get
																					feature_values
																					(current_index)
																				)
																			)
																		)

																		;else return the value as-is
																		(get
																			feature_values
																			(current_index)
																		)
																	)
																)
																features
															)
														)
													)
													input_cases
												)
											encode_features_on_train (false)
										)
									)
								)

								;don't train the data, only accumulate weights to neighbors
								(if
									(and train_weights_only accumulate_weight_feature)
									(seq
										(call
											AccumulateCaseInfluenceWeights
											(assoc
												cases input_cases
												accumulate_weight_feature accumulate_weight_feature
												features features
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)
										(conclude
											(assoc
												ablated_indices (list)
												num_trained 0
												status status_output
											)
										)
									)
								)

								;series storage is already encoded, append it as-is to passed in data
								(if
									(size series_cases)
									(let
										(assoc
											remaining_series_feature_indices (list)
											series_features (get
													seriesFeatures
													series
												)
										)

										;leave only those indices of series_features that will not be clobbered by features
										(assign
											(assoc
												remaining_series_feature_indices (filter
														(lambda
															(not
																(contains_value
																	features
																	(get
																		series_features
																		(current_value)
																	)
																)
															)
														)
														(indices
															series_features
														)
													)
											)
										)

										;set training features to be unique, removing those from the series that are being explicitly trained on
										(accum
											(assoc
												features (unzip
														series_features
														remaining_series_feature_indices
													)
											)
										)
										(assign
											(assoc
												input_cases
													;apply the one input case to all the cases in the series
													(if
														(=
															(size
																input_cases
															)
															1
														)
														(let
															(assoc
																case_values (get
																		input_cases
																		0
																	)
															)
															(map
																(lambda
																	(append
																		case_values
																		(unzip
																			(current_value)
																			remaining_series_feature_indices
																		)
																	)
																)
																series_cases
															)
														)

														;else apply each input case to each of the cases in the series
														(=
															(size
																input_cases
															)
															(size
																series_cases
															)
														)
														(map
															(lambda
																(append
																	(get
																		input_cases
																		(current_index)
																	)
																	(unzip
																		(current_value)
																		remaining_series_feature_indices
																	)
																)
															)
															series_cases
														)
													)
											)
										)

										;clear out stored series
										(call
											RemoveSeriesStore
											(assoc series series)
										)
									)
								)

								;iterate over the input cases and create them, only returning case ids for cases that were able to be created
								(declare
									(assoc
										new_case_ids (weave
												(lambda
													(let
														(assoc
															feature_values (first
																	(current_value
																		1
																	)
																)
														)
														(if
															encode_features_on_train
															(assign
																(assoc
																	feature_values (call
																			ConvertFromInput
																			(assoc
																				feature_values feature_values
																				features features
																			)
																		)
																)
															)
														)

														;do not train on this case if it is null or all case values are null or it's within provided thresholds
														(if
															(and
																(!=
																	(null)
																	feature_values
																)
																(not
																	(apply
																		"="
																		(append
																			feature_values
																			(list
																				(null)
																			)
																		)
																	)
																)

																;no thresholds specified or the case is outside of thresholds
																(or
																	(=
																		(null)
																		convictionLowerThreshold
																		convictionUpperThreshold
																		ablatement_params
																	)
																	(call
																		CaseOutsideThresholds
																	)
																)
															)
															(seq

																;create the case and store case id
																(declare
																	(assoc
																		new_case_id (call
																				CreateCase
																				(assoc
																					feature_values feature_values
																					session_training_index trained_instance_count
																					session (get_value
																							session
																						)
																					features features
																				)
																			)
																	)
																)
																(accum
																	(assoc
																		trained_instance_count 1
																	)
																)

																;output the new case id
																(list
																	new_case_id
																)
															)

															;else don't output anything, filtering out any null case ids
															(seq
																(accum
																	(assoc
																		ablated_indices_list (get_value
																				(current_index
																					1
																				)
																			)
																	)
																)
																(list)
															)
														)
													)
												)
												input_cases

												;use weave as a map-filter by specifying null as the second list
												(null)
											)
									)
								)

								;set values if there were cases that were trained on
								(if
									(>
										(size new_case_ids)
										0
									)
									(seq

										;add action to the existing replay data
										(assign_to_entities
											session
											(assoc
												".trained_instance_count" trained_instance_count
												".indices_map" (append
														cur_session_case_indices_map
														(zip
															(range
																(-
																	trained_instance_count
																	(size
																		new_case_ids
																	)
																)
																(-
																	trained_instance_count
																	1
																)
															)
															new_case_ids
														)
													)
												".replay_steps" (append
														cur_session_data
														new_case_ids
													)
											)
										)

										;removing all defaultFeatures from features should result in an empty assoc, if it's not empty that means
										;we're training on features that aren't in defaultFeatures yet, append them in their specified order
										(if
											(!=
												(assoc)
												(remove
													(zip
														features
													)
													defaultFeatures
												)
											)
											(accum_to_entities
												(assoc
													defaultFeatures (filter
															(lambda
																(not
																	(contains_value
																		defaultFeatures
																		(current_value)
																	)
																)
															)
															(append
																features
																(indices
																	derivedFeaturesMap
																)
															)
														)
												)
											)
										)

										;model has changed so clear out these cached value
										##ClearCachedCountsAndEntropies
										(assign_to_entities
											(assoc
												averageModelCaseEntropyRemoval (null)
												averageModelCaseEntropyAddition (null)
												expectedValuesMap (assoc)
												averageModelCaseDistanceContribution (null)
												nominalClassProbabilitiesMap (assoc)
												staleOrdinalValuesCount (true)
												storedCaseConvictionsFeatureAddition (null)
											)
										)

										;if auto optimization is enabled, check whether this model should be re-optimized
										;and return the appropriate status to client so that optimization could be started
										(if
											autoOptimizeEnabled
											(let
												(assoc
													num_cases (call
															GetNumTrainingCases
														)
												)
												(if
													(and
														(>=
															num_cases
															autoOptimizeThreshold
														)
														(or
															(<
																num_cases
																autoOptimizeLimitSize
															)
															(<=
																autoOptimizeLimitSize
																0
															)
														)
													)
													(assign
														(assoc
															status_output "optimize"
														)
													)
												)
											)
										)
									)
								)

								;if derived features wasn't specified, auto-detect them
								(if
									(and
										(= (null) derived_features)
										(>
											(size derivedFeaturesMap)
											0
										)
									)
									(seq
										(assign
											(assoc derived_features (list))
										)

										;check features vs sourceToDerivedFeatureMap and populate derived_features accordingly
										(map
											(lambda
												(let
													(assoc
														feature_name (current_value
																1
															)
													)

													;if this trained feature has derived features, add all of them to the derived_features list
													(if
														(contains_index
															sourceToDerivedFeatureMap
															feature_name
														)
														(accum
															(assoc
																derived_features (get
																		sourceToDerivedFeatureMap
																		feature_name
																	)
															)
														)
													)
												)
											)
											features
										)

										;clear out possible duplicates out of derived_features
										(assign
											(assoc
												derived_features (indices
														(zip
															derived_features
														)
													)
											)
										)
									)
								)
								(if
									(size nominalsSet)
									(call UpdateNominalClassCounts)
								)

								;auto populate derived features if necessary
								(if
									(>
										(size derived_features)
										0
									)
									(call
										DeriveTrainFeatures
										(assoc
											derived_features (filter
													(lambda
														(not
															(contains_value
																features
																(current_value)
															)
														)
													)
													derived_features
												)
											features features
										)
									)
								)
								(if
									hasDependentFeatures
									(let
										(assoc
											unique_nominals_set (list)
											dependent_values_combinations_map (assoc)
											dependents_boundary_map (assoc)
										)
										(if
											(size continuousDependentsMap)
											(seq
												(map
													(lambda
														(let
															(assoc
																continuous_feature (get_value
																		(current_index
																			1
																		)
																	)
																dependent_nominals (current_value
																		1
																	)
																dependents_combinations_map (assoc)
																dependent_values_combinations (list)
															)
															(assign
																(assoc
																	dependents_combinations_map (call
																			ComputeDependentBoundaries
																			(assoc
																				value_feature continuous_feature
																				nominals dependent_nominals
																			)
																		)
																)
															)
															(call
																AccumulateDependentValuesCombinations
																(assoc
																	values_lists (list)
																	nested_value_combinations_map dependents_combinations_map
																)
															)
															(accum
																(assoc
																	dependent_values_combinations_map (associate
																			continuous_feature
																			dependent_values_combinations
																		)
																	dependents_boundary_map (associate
																			continuous_feature
																			dependents_combinations_map
																		)
																)
															)
														)
													)
													continuousDependentsMap
												)
												(assign_to_entities
													(assoc
														dependentValuesCombinationsMap dependent_values_combinations_map
														dependentsBoundaryMap dependents_boundary_map
													)
												)
											)
										)
									)
								)

								;if there are features that have nulls, check if they still have nulls
								(if
									hasInactiveFeatures
									(let
										(assoc
											inactive_features_map (filter
													(lambda
														(let
															(assoc
																feature (current_index
																		1
																	)
															)

															;only keep those features that have no valid values (0 non-nulls)
															(=
																(contained_entities
																	(list
																		(query_exists
																			internalLabelSession
																		)
																		(query_not_equals
																			feature
																			(null)
																		)
																		(query_count)
																	)
																)
																0
															)
														)
													)
													(if
														(=
															(assoc)
															inactiveFeaturesMap
														)
														(zip
															defaultFeatures
															0
														)
														inactiveFeaturesMap
													)
												)
										)

										;if there are now less inactive features than there were, set the no-longer inactive feature weights to 1
										(if
											(<
												(size inactive_features_map)
												(size inactiveFeaturesMap)
											)
											(call
												SetFeatureWeightsForFeatures
												(assoc
													overwrite (true)
													features_weights_map (zip
															(indices
																(remove
																	inactiveFeaturesMap
																	(indices
																		inactive_features_map
																	)
																)
															)
															1
														)
												)
											)
										)
										(if
											(size inactive_features_map)
											(assign_to_entities
												(assoc
													inactiveFeaturesMap inactive_features_map
												)
											)

											;else all features have some values
											(assign_to_entities
												(assoc
													hasInactiveFeatures (false)
													inactiveFeaturesMap (null)
												)
											)
										)
									)
								)

								;if there are inactive features and they haven't been set yet, set their weight to 0
								(if
									hasInactiveFeatures
									(call
										SetFeatureWeightsForFeatures
										(assoc
											overwrite (false)
											features_weights_map inactiveFeaturesMap
										)
									)
								)
								(accum_to_entities
									(assoc revision 1)
								)

								;if accumulate_weight_feature was specified and there are ablated cases, accumulate weights to their neighbors
								(if
									(and
										(size ablated_indices_list)
										accumulate_weight_feature
									)
									(call
										AccumulateCaseInfluenceWeights
										(assoc
											cases (unzip
													input_cases
													ablated_indices_list
												)
											accumulate_weight_feature accumulate_weight_feature
											features features
										)
									)
								)

								;return response
								(assoc
									ablated_indices ablated_indices_list
									num_trained (size new_case_ids)
									status status_output
								)
							)

							;set specified feature weights in all hyperparameters
							;If weights haven't been defined yet, set them to 0 for invacitves and 1 for actives
							;If already defined, will overwrite the weight of the specified features in feature_weights_map
							;
							;parameters:
							; features_weights_map: assoc of feature -> weight to overwrite in all hyperparameter sets
							; overwrite: flag, if set to true will assume that featureWeights already exist and overwrites them.
							;			 When false, will create featureWeights in the hyperparameter set
							##SetFeatureWeightsForFeatures
							(map
								(lambda
									(let
										(assoc
											hp_action_feature (current_index 1)
										)
										(map
											(lambda
												(let
													(assoc
														hp_robust_mode (current_index
																1
															)
													)
													(map
														(lambda
															(let
																(assoc
																	hp_weight_feature (current_index
																			1
																		)
																	hp_set (current_value
																			1
																		)
																)
																(if
																	overwrite
																	(assign_to_entities
																		(assoc
																			hyperparameterMetadataMap (set
																					hyperparameterMetadataMap
																					(list
																						hp_action_feature
																						hp_robust_mode
																						hp_weight_feature
																						"featureWeights"
																					)
																					(append
																						(get
																							hp_set
																							"featureWeights"
																						)
																						features_weights_map
																					)
																				)
																		)
																	)

																	;else if featureWeights aren't defined, set them to 0 for the inactive features, and 1 for others
																	(if
																		(not
																			(contains_index
																				hp_set
																				"featureWeights"
																			)
																		)
																		(assign_to_entities
																			(assoc
																				hyperparameterMetadataMap (set
																						hyperparameterMetadataMap
																						(list
																							hp_action_feature
																							hp_robust_mode
																							hp_weight_feature
																							"featureWeights"
																						)
																						(append
																							(zip
																								defaultFeatures
																								1
																							)
																							features_weights_map
																						)
																					)
																			)
																		)
																	)
																)
															)
														)
														(current_value)
													)
												)
											)
											(current_value)
										)
									)
								)
								hyperparameterMetadataMap
							)

							;Helper method to update current nominal class counts for the whole model
							;no parameters, it iterates over all the known nominals in nominalsSet and for each feature stores the count for each class
							##UpdateNominalClassCounts
							(let
								(assoc
									nominal_class_values_map (map
											(lambda
												(indices
													(compute_on_contained_entities
														(list
															(query_value_masses
																(current_index
																	1
																)
																(null)
																(contains_index
																	nonStringNominalFeaturesMap
																	(current_index
																		1
																	)
																)
															)
														)
													)
												)
											)
											nominalsSet
										)
								)
								(assign_to_entities
									(assoc
										nominalClassCountsMap (map
												(lambda
													(if
														(contains_index
															nominalsSet
															(current_index)
														)

														;will be the count of classes if the feature is in the map of nominal features, 0 otherwise
														(size
															(get
																nominal_class_values_map
																(current_index)
															)
														)
														0
													)
												)
												(zip defaultFeatures)
											)
									)
								)
							)

							;Helper method to update current nominal counts for the specified feature
							;store the count for each class for the specified feature into nominalClassCountsMap
							;parameters:
							; feature: nominal feature for which to store class counts
							##UpdateNominalClassCountsForFeature
							(let

								;store all the unique classes for this nominal feature
								(assoc
									nominal_class_values (if
											(contains_index nominalsSet feature)
											(indices
												(compute_on_contained_entities
													(list
														(query_value_masses
															feature
															(null)
															(contains_index
																nonStringNominalFeaturesMap
																feature
															)
														)
													)
												)
											)

											;else not nominal, so it's an empty list
											(list)
										)
								)
								(accum_to_entities
									(assoc
										nominalClassCountsMap (associate
												feature
												(size nominal_class_values)
											)
									)
								)
							)

							;Tests the new training case against the provided thresholds and filters out those that are too similar to existing cases in the model
							;returns: 0 if the case should be filtered out and not trained on because it's too similar to others
							;		 1 if the case should be trained on because it's sufficiently different
							; inherited parameters: features, feature_values
							; ablatement_params: assoc of feature -> threshold_type
							; 	threshold_type is one of:
							;		['exact'] - don't train if prediction matches exactly
							;		['tolerance', MIN, MAX] - don't train if prediction >= (case value - MIN) and prediction <= (case value + MAX)
							;		['relative', PERCENT] - don't train if abs(prediction - case value) / prediction <= PERCENT
							;		['residual'] - don't train if if abs(prediction - case value) <= feature residual
							##CaseOutsideThresholds
							(let
								(assoc
									feature_value_map (zip features feature_values)
									action_features (indices ablatement_params)
								)
								(declare
									(assoc
										action_values (unzip feature_value_map action_features)
										residual_map (assoc)
									)
								)
								(or

									;evaluate in order and return the first true block
									;if the model is too small, skip ablatement, return true to force training
									(<
										(call GetNumTrainingCases)
										minAblatementModelSize
									)

									;if we have ablatement_params, need to react first
									(if
										(!= (null) ablatement_params)

										;store the reaction to reuse for both
										(let
											(assoc
												reaction_values (map
														(lambda
															(let
																(assoc
																	ablate_by_feature_residuals (=
																			"residual"
																			(get
																				ablatement_params
																				(list
																					(current_value
																						2
																					)
																					0
																				)
																			)
																		)
																	feature (current_value
																			1
																		)
																)
																(declare
																	(assoc
																		context_features (filter
																				(lambda
																					(!=
																						feature
																						(current_value)
																					)
																				)
																				features
																			)
																	)
																)

																;react to each of the action features, using all other features as contexts
																(declare
																	(assoc
																		reaction (call
																				ReactDiscriminative
																				(assoc
																					skip_decoding (true)
																					context_values (unzip
																							feature_value_map
																							context_features
																						)
																					details (if
																							ablate_by_feature_residuals
																							(assoc
																								feature_residuals (true)
																							)

																							;else
																							(null)
																						)
																					return_action_values_only (true)
																					substitute_output (false)
																					skip_encoding (true)
																					action_features (list
																							feature
																						)
																					context_features context_features
																				)
																			)
																	)
																)

																;output the predicted value
																(if
																	ablate_by_feature_residuals
																	(seq

																		;store the residual min and max tolerance for this feature
																		(accum
																			(assoc
																				residual_map (associate
																						feature
																						(assoc
																							min (get
																									reaction
																									(list
																										"feature_residuals"
																										feature
																										"mean_absolute_error_low"
																									)
																								)
																							max (get
																									reaction
																									(list
																										"feature_residuals"
																										feature
																										"mean_absolute_error_high"
																									)
																								)
																						)
																					)
																			)
																		)
																		(first
																			(get
																				reaction
																				"action_values"
																			)
																		)
																	)
																	(first
																		reaction
																	)
																)
															)
														)
														action_features
													)
											)
											(or

												;if we filter out any values outside of the defined thresholds (that should be trained on)
												;allow training because these values are not being predicted by the system
												(!=
													(size
														action_values
													)

													;if an action_value is same as/within threshold of prediction, it will not be filtered out
													;so if this list is the same size as the original action_values, all action values were predicted correctly
													;but if it's not the same size, the action values are different enough to be trained on
													(size
														(filter
															(lambda
																(let
																	(assoc
																		action_value (get
																				action_values
																				(current_index
																					1
																				)
																			)
																		threshold (get
																				ablatement_params
																				(get
																					action_features
																					(current_index
																						1
																					)
																				)
																			)
																	)
																	(declare
																		(assoc
																			threshold_type (first
																					threshold
																				)
																		)
																	)
																	(if
																		(=
																			threshold_type
																			"exact"
																		)
																		(=
																			action_value
																			(current_value)
																		)

																		;for discrete or residual, set the min and max and check if actual value is outside of those bounds
																		(or
																			(=
																				threshold_type
																				"tolerance"
																			)
																			(=
																				threshold_type
																				"residual"
																			)
																		)
																		(let
																			(assoc
																				min (if
																						(=
																							threshold_type
																							"tolerance"
																						)
																						(get
																							threshold
																							1
																						)
																						(get
																							residual_map
																							(list
																								(get
																									action_features
																									(current_index
																										1
																									)
																								)
																								"min"
																							)
																						)
																					)
																				max (if
																						(=
																							threshold_type
																							"tolerance"
																						)
																						(get
																							threshold
																							2
																						)
																						(get
																							residual_map
																							(list
																								(get
																									action_features
																									(current_index
																										1
																									)
																								)
																								"max"
																							)
																						)
																					)
																			)
																			(and
																				(>=
																					(current_value)
																					(-
																						action_value
																						min
																					)
																				)
																				(<=
																					(current_value)
																					(+
																						action_value
																						max
																					)
																				)
																			)
																		)

																		;PERCENT is (last threshold)
																		(=
																			threshold_type
																			"relative"
																		)
																		(<=
																			(/
																				(abs
																					(-
																						(current_value)
																						action_value
																					)
																				)
																				(current_value)
																			)
																			(last
																				threshold
																			)
																		)

																		;if threshold_type is explicitly undefined, treat it as outside of bounds and filter out the value
																		;thus forcing this case to be trained
																		(=
																			threshold_type
																			(null)
																		)
																		(false)
																	)
																)
															)
															reaction_values
														)
													)
												)
											)
										)
									)

									;conviction thresholds
									(if
										(or
											(!= convictionLowerThreshold (null))
											(!= convictionUpperThreshold (null))
										)
										(let
											(assoc
												conviction_value (get
														(call
															ReactGroup
															(assoc
																new_cases (list
																		feature_values
																	)
																features features
																skip_encoding (true)
															)
														)
														"familiarity_conviction_addition"
													)
											)
											(or

												;if both threshold values set, must be within both, otherwise check only the provided one
												(if
													(and
														(!=
															(null)
															convictionLowerThreshold
														)
														(!=
															(null)
															convictionUpperThreshold
														)
													)
													(and
														(<
															conviction_value
															convictionUpperThreshold
														)
														(>
															conviction_value
															convictionLowerThreshold
														)
													)
													(!=
														(null)
														convictionLowerThreshold
													)
													(>
														conviction_value
														convictionLowerThreshold
													)
													(<
														conviction_value
														convictionUpperThreshold
													)
												)

												;if the model is empty, ReactGroup returns 0, force training
												(=
													conviction_value
													0
												)
											)
										)

										;else
										0
									)
								)
							)

							;sets the model to auto-optimize by tracking its size and notifying the clients in train responses when it should be optimized
							;parameters:
							; auto_optimize_enabled: flag, default is false. when true, returns when it's time for model to be optimized again.
							; optimize_threshold: optional, stores the threshold for the number of cases at which the model should be re-optimized. default of 100.
							; optimize_growth_factor: the factor by which to increase the optimize threshold everytime the model grows to the current threshold size
							;						default of two orders of magnitude using the universal scaling factor e
							; auto_optimize_limit_size: the size of of the model at which to stop doing outo-optimization. Value of 0 means no limit.
							##SetAutoOptimize
							(declare
								(assoc
									optimize_threshold 100
									auto_optimize_enabled (false)
									auto_optimize_limit_size 100000
									optimize_growth_factor 7.389056
								)

								;growth factor must be more than 1
								(if
									(<= optimize_growth_factor 1)
									(assign
										(assoc optimize_growth_factor 2)
									)
								)
								(if
									(< auto_optimize_limit_size 0)
									(assign
										(assoc auto_optimize_limit_size 0)
									)
								)
								(declare
									(assoc
										num_cases (call GetNumTrainingCases)
									)
								)

								;if the model is already larger than the specified optimize_threshold, set the optimize_threshold to a valid value nearest the current
								;number of cases in the model without going over
								(if
									(and
										(!= (null) optimize_threshold)
										(> num_cases optimize_threshold)
									)
									(seq

										;keep increasing the optimization_threshold by the growth_factor_amount until it's bigger than the current number of cases
										;and then decrease it back down so that it's just below
										(while
											(> num_cases optimize_threshold)
											(assign
												(assoc
													optimize_threshold (*
															optimize_threshold
															optimize_growth_factor
														)
												)
											)
										)
										(assign
											(assoc
												optimize_threshold (/
														optimize_threshold
														optimize_growth_factor
													)
											)
										)
									)
								)
								(accum_to_entities
									(assoc revision 1)
								)
								(assign_to_entities
									(assoc
										autoOptimizeEnabled auto_optimize_enabled
										autoOptimizeLimitSize auto_optimize_limit_size
										autoOptimizeGrowthFactorAmount optimize_growth_factor
										autoOptimizeThreshold optimize_threshold
									)
								)
							)

							;Helper method to store cases directly into series in bulk
							##AppendToSeriesStore
							(map
								(lambda
									(let
										(assoc
											case_context_values (current_value 1)
										)
										(call
											AppendCaseToSeriesStoreWithoutEncoding
											(assoc
												context_values (if
														hasFeaturesNeedEncodingFromInput
														(call
															ConvertFromInput
															(assoc
																feature_values case_context_values
																features context_features
															)
														)
														case_context_values
													)
												series series
												context_features context_features
											)
										)
									)
								)
								context_values
							)

							;helper method to store react case and features into the specified into_series_store seriesStore
							;outputs the react case object
							;
							;parameters:
							; react_case: the react output whose values to store. React action values are assumed to be unencoded
							; action_features: list of action features corresponding to the react_case action_values
							; context_features: list of context features used during react
							; context_values: list of (encoded) context_values used during react
							; series: series id, the key for storing a series of react cases in seriesStore
							##AppendCaseToSeriesStoreWithoutEncoding
							(declare
								(assoc
									react_case (assoc)
									context_values (list)
									series (null)
									action_features (list)
									context_features (list)
								)
								(declare
									(assoc
										action_values (get react_case "action_values")
										series_store (get seriesStore series)
										all_features (append context_features action_features)
									)
								)

								;encode action (generated) values so that they are stored as encoded
								(if
									hasFeaturesNeedEncodingFromInput
									(assign
										(assoc
											action_values (call
													ConvertFromInput
													(assoc
														feature_values action_values
														features action_features
													)
												)
										)
									)
								)
								(declare
									(assoc
										reorder_values (false)
										all_values (append context_values action_values)
									)
								)

								;if there are duplicate features among context and action features, remove them here
								;with action_values taking precedence over(writing) their 'same-feature' context values
								(if
									(!=
										(size all_features)
										(size
											(zip all_features)
										)
									)
									(let
										(assoc
											combined_values_map (zip
													all_features
													all_values
												)
										)
										(assign
											(assoc
												reorder_values (true)
												all_values (values
														combined_values_map
													)
												all_features (indices
														combined_values_map
													)
											)
										)
									)
								)

								;if it doesn't exist, initialize it to an empty list and store the features
								(if
									(= (null) series_store)
									(seq
										(assign
											(assoc series_store (list))
										)
										(accum_to_entities
											(assoc
												seriesFeatures (associate
														series
														all_features
													)
											)
										)
									)
								)

								;all_values might be in a different order due to unzipping due to duplicate features,
								;fix the order here to match other cases in series
								(if
									reorder_values
									(assign
										(assoc
											all_values (unzip
													(zip
														all_features
														all_values
													)
													(get
														seriesFeatures
														series
													)
												)
										)
									)
								)

								;add the generated case to seriesStore, format of { series:  [ react values ] }
								(assign_to_entities
									(assoc
										seriesStore (set
												seriesStore
												series
												(append
													series_store
													(list
														all_values
													)
												)
											)
									)
								)

								;output the case object
								react_case
							)

							;clears stored series
							;parameters:
							; series: optional, series id to clear. if not provided, removes entire store
							;remove entire store if series isn't provided
							##RemoveSeriesStore
							(if
								(= (null) series)
								(assign_to_entities
									(assoc seriesFeatures (assoc) seriesStore (assoc))
								)

								;else remove only the series for the session
								(assign_to_entities
									(assoc
										seriesFeatures (remove seriesFeatures series)
										seriesStore (remove seriesStore series)
									)
								)
								(true)
							)

							;return the case id for a case given its session and original session training index
							;
							;parameters:
							; session: session id for the case
							; session_training_index: the index of the case in the original order that it was trained for the specified session
							##GetCaseId
							(first

								;return the one entity that was trained in this session at this session_training_index
								(contained_entities
									(list
										(query_equals internalLabelSession session)
										(query_equals internalLabelSessionTrainingIndex session_training_index)
									)
								)
							)

							;outputs the entire model's data to the console
							;note: need root entity to call this
							##PrintFullModel
							(let
								(assoc
									cases (call AllCases)
								)
								(print
									(map
										(lambda
											(retrieve_entity_root (current_value))
										)
										cases
									)
								)
							)

							;retrieve the top or bottom number of cases for a specified feature, sorted top to bottom for top, and bottom to top for bottom
							;parmeters:
							; sort_feature: the feature for which to sort the cases by
							; num: number of cases to return, positive value will return the top (largest value), negative will return smallest
							; features : the features for which values should be returned
							##RetrieveExtremeCasesForFeature
							(declare
								(assoc
									sort_feature (null)
									features (null)
									num 0
								)
								(if
									(= (null) features)
									(assign
										(assoc features defaultFeatures)
									)
								)
								(declare
									(assoc
										case_ids (if
												(!=
													(null)
													sort_feature
												)
												(if
													(>
														num
														0
													)
													(contained_entities
														(list
															(query_exists
																internalLabelSession
															)
															(query_max
																sort_feature
																num
															)
														)
													)
													(<
														num
														0
													)
													(contained_entities
														(list
															(query_exists
																internalLabelSession
															)
															(query_min
																sort_feature
																(-
																	num
																)
															)
														)
													)
													(null)
												)
											)
									)
								)

								;store the case values into a list
								(declare
									(assoc
										case_values_list (map
												(lambda
													(retrieve_from_entity
														(current_value)
														features
													)
												)
												case_ids
											)
									)
								)

								;determine the index of the feature to be sorted on from the list of all features so that we can sort by it
								(declare
									(assoc
										sort_by_feature_value (if
												(>
													num
													0
												)
												(lambda
													(>
														(get
															(current_value
																1
															)
															feature_index
														)
														(get
															(current_value)
															feature_index
														)
													)
												)
												(lambda
													(<
														(get
															(current_value
																1
															)
															feature_index
														)
														(get
															(current_value)
															feature_index
														)
													)
												)
											)
										has_datetime_features hasDateTimeFeatures
										feature_index (first
												(filter
													(lambda
														(=
															sort_feature
															(get
																features
																(current_value)
															)
														)
													)
													(indices
														features
													)
												)
											)
										has_rounded_features hasRoundedFeatures
									)
								)

								;sort the list of case values
								(assign
									(assoc
										case_values_list (sort sort_by_feature_value case_values_list)
									)
								)
								(associate
									"features"
									features
									"cases"
									(if
										(and
											hasEncodedFeatures
											(not skip_decoding)
										)

										;decode nominal features if necessary
										(map
											(lambda
												(call
													ConvertToOutput
													(assoc
														feature_values (current_value
																1
															)
														has_datetime_features has_datetime_features
														features features
														has_rounded_features has_rounded_features
													)
												)
											)
											case_values_list
										)

										;else round if needed
										has_rounded_features
										(map
											(lambda
												(call
													RoundContinuousFeatures
													(assoc
														feature_values (current_value
																1
															)
														features features
													)
												)
											)
											case_values_list
										)

										;else just return the values
										case_values_list
									)
								)
							)

							;return all cases that match the specified condition
							;parameters:
							; precision: flag, whether to query for 'exact' matches; if set to 'similar' will query for similar values intead of 'exact'
							; condition_session_id: optional, if specified ignores condition and returns cases for the specified session id
							; condition: assoc of feature->value(s)
							;	no value = must have feature
							;   - for continuous or numeric ordinal features:
							;	one value = must equal exactly the value or be close to it for fuzzy match
							;	two values = inclusive between
							;   - for nominal or string ordinal features:
							;	n values = must match any of these values exactly
							; num_cases: number of cases return; if set to 0, will not have a limit
							##GetCasesByCondition
							(declare
								(assoc
									condition (assoc)
									num_cases 1
									condition_session_id (null)
									precision "exact"
								)
								(if
									(!= (null) condition_session_id)

									;get all the case ids in the order they were stored for the specified session
									(retrieve_from_entity condition_session_id ".replay_steps")

									;else return cases that match the condition
									(seq
										(if
											hasStringOrdinals
											(assign
												(assoc
													condition (map
															(lambda

																;if the features in the condition are string ordinals, look up the encoded value and overwrite it in the condition statement
																;since querying is done on numeric (encoded) values
																(if
																	(and
																		(contains_index
																			ordinalStringToOrdinalMap
																			(current_index)
																		)
																		(!=
																			(null)
																			(current_value)
																		)
																	)
																	(let
																		(assoc
																			feature (get_value
																					(current_index
																						1
																					)
																				)
																			cond_value (current_value
																					1
																				)
																		)

																		;get the enum value for the value(s) for this feature
																		(if
																			(~
																				(list)
																				cond_value
																			)
																			(map
																				(lambda
																					(get
																						ordinalStringToOrdinalMap
																						(list
																							feature
																							(current_value
																								1
																							)
																						)
																					)
																				)
																				cond_value
																			)

																			;else get the one single value
																			(get
																				ordinalStringToOrdinalMap
																				(list
																					feature
																					cond_value
																				)
																			)
																		)
																	)

																	;else return the value without encoding
																	(current_value)
																)
															)
															condition
														)
												)
											)
										)
										(if
											(= "exact" precision)

											;limit the list to the number of specified cases
											(trunc

												;iterate over each condition and create a conjunctive filter to return only the matching cases
												(contained_entities
													(append
														(query_exists
															internalLabelSession
														)
														(map
															(lambda
																(let
																	(assoc
																		feature (current_value
																				1
																			)
																		cond_value (get
																				condition
																				(current_value
																					1
																				)
																			)
																	)
																	(if

																		;feature must exist
																		(=
																			cond_value
																			(null)
																		)
																		(query_exists
																			feature
																		)

																		;else then feature value must equal
																		(contains_value
																			(list
																				"number"
																				"string"
																			)
																			(get_type_string
																				cond_value
																			)
																		)
																		(query_equals
																			feature
																			cond_value
																		)

																		;else this is a list of values, for nominals use query_among, for continuous use query_between
																		(if
																			(or
																				(contains_index
																					nominalsSet
																					feature
																				)
																				(contains_index
																					ordinalStringToOrdinalMap
																					feature
																				)
																			)
																			(query_among
																				feature
																				cond_value
																			)

																			;else continuous, inclusive query between the two provided values
																			(query_between
																				feature
																				(first
																					cond_value
																				)
																				(last
																					cond_value
																				)
																			)
																		)
																	)
																)
															)
															(indices
																condition
															)
														)
													)
												)
												num_cases
											)

											;else do a fuzzy query
											(let
												(assoc
													other_features (list)
													equals_features (list)
													hyperparam_map (call
															GetHyperparameters
															(assoc
																weight_feature ".none"
																feature ".targetless"
																mode "robust"
															)
														)
												)

												;iterate over condition and populate the equals and other lists
												(map
													(lambda
														(if

															;if the condition for this feature is an equals, add it to the equals_features list
															(contains_value
																(list
																	"string"
																	"number"
																)
																(get_type_string
																	(get
																		condition
																		(current_value)
																	)
																)
															)
															(accum
																(assoc
																	equals_features (current_value
																			1
																		)
																)
															)

															;else add it to the other list
															(accum
																(assoc
																	other_features (current_value
																			1
																		)
																)
															)
														)
													)
													(indices
														condition
													)
												)

												;pull corresponding feature values and flags for the equals features to be used in the generalized_distance query below
												(declare
													(assoc
														equals_features_values (unzip
																condition
																equals_features
															)
													)
												)

												;build the fuzzy query condition, appending the generalized norm query to the other conditions
												(declare
													(assoc
														query_conditions (append
																(query_exists
																	internalLabelSession
																)
																(map
																	(lambda
																		(let
																			(assoc
																				feature (current_value
																						1
																					)
																				cond_value (get
																						condition
																						(current_value
																							1
																						)
																					)
																			)
																			(if

																				;feature must exist
																				(=
																					cond_value
																					(null)
																				)
																				(query_exists
																					feature
																				)

																				;else this is a list of values, for nominals use query_among, for continuous use query_between
																				(if
																					(or
																						(contains_index
																							nominalsSet
																							feature
																						)
																						(contains_index
																							ordinalStringToOrdinalMap
																							feature
																						)
																					)
																					(query_among
																						feature
																						cond_value
																					)

																					;else continuous, inclusive query between the two provided values
																					(query_between
																						feature
																						(first
																							cond_value
																						)
																						(last
																							cond_value
																						)
																					)
																				)
																			)
																		)
																	)
																	other_features
																)
																(if
																	(>
																		num_cases
																		0
																	)
																	(query_nearest_generalized_distance
																		num_cases
																		equals_features
																		equals_features_values
																		(get
																			hyperparam_map
																			"featureWeights"
																		)
																		nominalClassCountsMap
																		cyclicFeaturesMap
																		(if
																			(get
																				hyperparam_map
																				"useDeviations"
																			)
																			(get
																				hyperparam_map
																				"featureDeviations"
																			)
																		)
																		(get
																			hyperparam_map
																			"p"
																		)
																		(get
																			hyperparam_map
																			"dwe"
																		)
																		(null)

																		;weight
																		;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																		"fixed rand seed"
																		(null)

																		;radius
																		lpSpaceHeuristicMultiplier

																		;no need to compute accurate distances since we just need the case ids and not the distances
																		(false)
																	)
																	(list)
																)
															)
													)
												)

												;run query conditions only if they exist, otherwise return all cases
												(if
													(>
														(size
															query_conditions
														)
														0
													)
													(contained_entities
														query_conditions
													)

													;else return all
													(contained_entities
														(list
															(query_exists
																internalLabelSession
															)
														)
													)
												)
											)
										)
									)
								)
							)

							;set a trainee's action feature weights
							;parameter:
							; action_feature : action feature for which to set context feature weights, if null will set these as the targetless_feature_weights
							; mode: robustness mode for the specified action feature, valid values are "robust" or "full"
							; feature_weights_map : assoc of feature -> weights for all the context features
							; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
							##SetFeatureWeights
							(declare
								(assoc
									weight_feature ".case_weight"
									feature_weights_map (assoc)
									mode "full"
									action_feature (null)
								)
								(declare
									(assoc
										hp_map (get
												hyperparameterMetadataMap
												(list
													action_feature
													mode
													weight_feature
												)
											)
									)
								)
								(if
									(and
										(= (null) hp_map)
										(= "full" mode)
									)
									(assign
										(assoc
											hp_map (get
													hyperparameterMetadataMap
													(list
														action_feature
														"robust"
														weight_feature
													)
												)
											mode "robust"
										)
									)
								)

								;can't set weights for a feature that isn't in the hyperparameter map
								(if
									(= (null) hp_map)
									(conclude)
								)

								;ensure that if any of the default features are missing from the weights map, that their weight is defaulted to 1
								(map
									(lambda
										(if
											(not
												(contains_index
													feature_weights_map
													(current_value)
												)
											)
											(accum
												(assoc
													feature_weights_map (associate
															(current_value
																2
															)
															1
														)
												)
											)
										)
									)
									defaultFeatures
								)

								;accum the weights to the map for this action_feature
								(accum
									(assoc
										hp_map (assoc featureWeights feature_weights_map)
									)
								)
								(assign_to_entities
									(assoc
										hyperparameterMetadataMap (set
												hyperparameterMetadataMap
												(list
													action_feature
													mode
													weight_feature
												)
												hp_map
											)
									)
								)
							)

							;return the full internal parameters map
							##GetInternalParameters
							(let
								(assoc
									internal_parameters_map (assoc hyperparameter_map hyperparameterMetadataMap)
								)
								(if
									(!= (null) autoOptimizeThreshold)
									(accum
										(assoc
											internal_parameters_map (assoc
													auto_optimize autoOptimizeEnabled
													optimize_threshold autoOptimizeThreshold
													auto_optimize_limit_size autoOptimizeLimitSize
													optimize_growth_factor autoOptimizeGrowthFactorAmount
												)
										)
									)
								)
								internal_parameters_map
							)

							;sets internal hyperparameters
							;
							;parameters:
							; hyperparameter_map: required. must have at least an action feature (e.g., .targetless) -> robust -> k, p and dwe provided.
							;	example:
							;   {
							;	  	".targetless" { "robust" : { "k" : number, "p" : number, "dwe": number }},
							;		"featureA" : { "full" : { "k" : number, "p" : number, "dwe": number }},
							;			...
							;	}
							; auto_optimize_enabled: flag, default is false. when true, returns when it's time for model to be optimized again.
							; optimize_threshold: optional, stores the threshold for the number of cases at which the model should be re-optimized. default of 100.
							; optimize_growth_factor: the factor by which to increase the optimize threshold everytime the model grows to the current threshold size
							;						default of two orders of magnitude using the universal scaling factor e
							; auto_optimize_limit_size: optional, the size of of the model at which to stop doing outo-optimization
							##SetInternalParameters
							(declare
								(assoc
									optimize_threshold 100
									auto_optimize_enabled (false)
									hyperparameter_map (null)
									auto_optimize_limit_size 100000
									optimize_growth_factor 7.389056
								)
								(declare
									(assoc
										bad_param (=
												0
												(size hyperparameter_map)
											)
									)
								)

								;the passed in hyperparameters must at least have the basic attributes defined correctly
								;iterate over action features
								(map
									(lambda
										(if
											(=
												0
												(size (current_value))
											)
											(assign
												(assoc
													bad_param (true)
												)
											)

											;else iterate over robust / full
											(map
												(lambda
													(if
														(=
															0
															(size
																(current_value)
															)
														)
														(assign
															(assoc
																bad_param (true)
															)
														)

														;else iterate over case weight
														(map
															(lambda
																(if
																	(or
																		(not
																			(contains_index
																				(current_value)
																				"p"
																			)
																		)
																		(not
																			(contains_index
																				(current_value)
																				"k"
																			)
																		)
																		(not
																			(contains_index
																				(current_value)
																				"dwe"
																			)
																		)
																	)
																	(assign
																		(assoc
																			bad_param (true)
																		)
																	)
																)
															)
															(current_value)
														)
													)
												)
												(current_value)
											)
										)
									)
									hyperparameter_map
								)

								;return failure, invalid hyperparameter_map passed in
								(if
									bad_param
									(conclude (false))
								)
								(assign_to_entities
									(assoc
										autoOptimizeEnabled auto_optimize_enabled
										autoOptimizeLimitSize auto_optimize_limit_size
										hyperparameterMetadataMap hyperparameter_map
										autoOptimizeGrowthFactorAmount optimize_growth_factor
										autoOptimizeThreshold optimize_threshold
									)
								)
								(accum_to_entities
									(assoc revision 1)
								)
								(true)
							)
							##GetHyperparameters
							(declare
								(assoc weight_feature ".case_weight" mode "robust")
								(if
									(= (null) feature)
									(assign
										(assoc feature ".targetless")
									)
								)
								(if
									(contains_index
										hyperparameterMetadataMap
										(list feature mode weight_feature)
									)
									(get
										hyperparameterMetadataMap
										(list feature mode weight_feature)
									)

									;else feature is the the map and has 'robust', return that
									(contains_index
										hyperparameterMetadataMap
										(list feature "robust")
									)
									(if
										(contains_index
											hyperparameterMetadataMap
											(list
												feature
												"robust"
												weight_feature
											)
										)
										(get
											hyperparameterMetadataMap
											(list
												feature
												"robust"
												weight_feature
											)
										)
										(get
											hyperparameterMetadataMap
											(list
												feature
												"robust"
												".none"
											)
										)
									)

									;else check if we should output weight_feature targetless robust if using weights
									(contains_index
										hyperparameterMetadataMap
										(list ".targetless" "robust" weight_feature)
									)
									(get
										hyperparameterMetadataMap
										(list ".targetless" "robust" weight_feature)
									)

									;else the feature and case_weight isn't in the map, return params for generic targetless robust
									(get
										hyperparameterMetadataMap
										(list ".targetless" "robust" ".none")
									)
								)
							)
							##loadModulesEndpoint
							(list

								;module for trainee_template
								;contains methods to set and get feature attributes
								(null

									;set all features and their attributes for a trainee
									;parameters:
									; features: assoc in the following example format
									;	{
									;		'sepal-width' : {		  #name of feature as the key, and feature attributes as value
									;			'type': 'continuous', #one of 'continuous', 'ordinal' or 'nominal'. default is 'continuous'
									;			'bounds' : { ... }	  #object with keys of 'min' and/or 'max', specifying values for continuous features
									;								  # 'allowed' key containing a list of values for nominal or ordinal features
									;								  # if this is a string ordinal feature, 'allowed' list must list all the values ordered low to high
									;			'cycle_length': 7,	#specify cycle length of cyclic feature, default is no cycle length
									;			'date_time_format': '%Y-%m-%d-%H.%M.%S', #date time format string, default is no date_time_format
									;			'locale': 'en_US',	  # locale for the date time, default is "en_US"
									;			'time_delta_format: 'seconds',  #format of the delta for times, default is "seconds". valid values are:
									;								  milliseconds, seconds, minutes, hours, days, weeks, years
									;			'significant_digits': 2,  #rounding to significant digits, default is no rounding
									;			'decimal_places': 1,  #rounding of decimal places, default is no rounding. If significant_digits is specified, then it rounds to the
									;								  #specified number of significant digits. If decimal_places is specified, then it ensures that output will be
									;								  #rounded at least to the number of decimal points past the integer as specified by decimal_places.
									;			'observational_error': .333,	  #observed error for feature, if known
									;			'data_type': 'number' # nominals only, persists their original datatype on output. Valid values are 'number' for
									;								  # numeric nominals, and 'boolean' for boolean nominals. default is 'string' if unspecified.
									;			'id_feature': True,   #flag specifying a feature should be used to compute case weights for id based privacy
									;			'unique': True		  #flag for nominal features if nominal feature has only unique values
									;			'dependent_features': [], #list of dependent features, directionality of depedency is not relevant. Should be used when there may
									;									#be multi-type value features that tightly depend on values based on other multi-type values features.
									;			'time_feature': True,   #flag for features that hold designated "time" values for a series, i.e., the 'datetime' feature in a
									;									# time series model should have this flag set to True
									;			'auto_derive_on_train': { ...  } # object with attributes defining how to create and derive all the values for this feature from
									;					 	# the trained dataset. For full list of specific 'auto_derive_on_train' feature attributes refer the comments at the tap
									;					  	# of the derive.amlg module.
									;			'derived_feature_code' : "#x 1" # code defining how the value for this feature could be derived if this feature is specified as a
									;						# "derived_context_feature" or a "derived_action_feature" during react flows. For react_series, the data referenced is the
									;						# accumulated series data (as a list of rows), and for non-series reacts, the data is the one single row. Each row is
									;						# comprised of all the combined context and action features. Referencing data in these rows uses 0-based indexing, where
									;						# the current row index is 0, the previous row's is 1, etc. Specified code may do simple logic and numeric operations on
									;						# feature values referenced via feature name and row offset.
									;						# Examples:
									;						#  "#x 1" - Use the value for feature 'x' from the previously processed row (offset of 1, one lag value).
									;						#  "(- #y 0 #x 1)" - Feature 'y' value from current (offset 0) row  minus feature 'x' value from previous (offest 1) row.
									;		}
									;	}
									##SetFeatureAttributes
									(declare
										(assoc features (assoc))

										;filter out any features that start with reserved characters
										(assign
											(assoc
												features (filter
														(lambda
															(not
																(contains_index
																	reservedFeatureCharacterSet
																	(first
																		(current_index)
																	)
																)
															)
														)
														features
													)
											)
										)
										(declare
											(assoc
												string_nominal_features_set (assoc)
												has_datetime_features (false)
												feature_custom_derived_methods (assoc)
												has_string_ordinals (false)
												ordinals_map (assoc)
												ordinal_ordinal_to_string_map (assoc)
												has_encoded_features (false)
												has_dependent_features (false)
												ordinal_string_to_ordinal_map (assoc)
												unique_nominals_map (assoc)
												feature_datetime_map (assoc)
												source_to_derived_feature_map (assoc)
												has_rounded_features (false)
												non_string_nominal_features_map (assoc)
												boundaries_map (assoc)
												nominals (list)
												has_booleans (false)
												derived_features_map (assoc)
												user_specified_feature_errors_map (assoc)
												feature_bounds_map (assoc)
												feature_rounding_map (assoc)
												nominals_map (assoc)
												ordinals (list)
												cyclics_map (assoc)
											)
										)
										(assign
											(assoc
												custom_derived_features_map (filter
														(lambda
															(or
																(!=
																	(null)
																	(get
																		(current_value)
																		"auto_derive_on_train"
																	)
																)
																(!=
																	(null)
																	(get
																		(current_value)
																		"derived_feature_code"
																	)
																)
															)
														)
														features
													)
												dependents_map (call
														ComposeDependentsMap
													)
												ordinals_map (filter
														(lambda
															(=
																"ordinal"
																(get
																	(current_value)
																	"type"
																)
															)
														)
														features
													)
												feature_datetime_map (call
														ComposeDateTimeMap
													)
												boundaries_map (filter
														(lambda
															(or
																(!=
																	(null)
																	(get
																		(current_value)
																		"bounds"
																	)
																)
																(!=
																	(null)
																	(get
																		(current_value)
																		"allow_null"
																	)
																)
															)
														)
														features
													)
												user_specified_feature_errors_map (call
														ComposeUserSpecifiedFeatureErrorsMap
													)
												feature_rounding_map (call
														ComposeRoundingMap
													)
												nominals_map (filter
														(lambda
															(=
																"nominal"
																(get
																	(current_value)
																	"type"
																)
															)
														)
														features
													)
												cyclics_map (call
														ComposeCyclicsMap
													)
											)
										)
										(if
											(size dependents_map)
											(assign
												(assoc
													has_dependent_features (true)
													continuous_dependents_map (call
															ComposeContinuousDependentsMap
														)
												)
											)
										)
										(if
											(size feature_rounding_map)
											(assign
												(assoc
													has_rounded_features (true)
												)
											)
										)
										(if
											(size ordinals_map)
											(assign
												(assoc
													ordinals_map (filter
															(lambda
																(>
																	(size
																		(get
																			(current_value)
																			(list
																				"bounds"
																				"allowed"
																			)
																		)
																	)
																	0
																)
															)
															ordinals_map
														)
													ordinals (indices
															ordinals_map
														)
												)
											)
										)
										(if
											(size feature_datetime_map)
											(assign
												(assoc
													has_datetime_features (true)
												)
											)
										)

										;process strng ordinals
										(if
											(size ordinals_map)
											(assign
												(assoc
													ordinal_string_to_ordinal_map (map
															(lambda
																(let
																	(assoc
																		ordered_ordinals (get
																				(current_value
																					1
																				)
																				(list
																					"bounds"
																					"allowed"
																				)
																			)
																	)
																	(zip
																		ordered_ordinals
																		(range
																			1
																			(size
																				ordered_ordinals
																			)
																		)
																	)
																)
															)
															ordinals_map
														)
													ordinal_ordinal_to_string_map (map
															(lambda
																(let
																	(assoc
																		ordered_ordinals (get
																				(current_value
																					1
																				)
																				(list
																					"bounds"
																					"allowed"
																				)
																			)
																	)
																	(zip
																		(range
																			1
																			(size
																				ordered_ordinals
																			)
																		)
																		ordered_ordinals
																	)
																)
															)
															ordinals_map
														)
												)
											)
										)
										(if
											(size ordinal_string_to_ordinal_map)
											(assign
												(assoc
													has_string_ordinals (true)
												)
											)
										)
										(if
											(size nominals_map)
											(assign
												(assoc
													unique_nominals_map (zip
															(filter
																(lambda
																	(=
																		(true)
																		(get
																			nominals_map
																			(list
																				(current_value
																					1
																				)
																				"unique"
																			)
																		)
																	)
																)
																(indices
																	nominals_map
																)
															)
														)
													non_string_nominal_features_map (call
															ComposeNonStringNominalsMap
														)
													nominals (indices
															nominals_map
														)
												)
											)
										)
										(if
											(size nominals)
											(assign
												(assoc
													string_nominal_features_set (remove
															(zip
																nominals
															)
															(indices
																non_string_nominal_features_map
															)
														)
												)
											)
										)
										(if
											(contains_value non_string_nominal_features_map "boolean")
											(assign
												(assoc
													has_booleans (true)
												)
											)
										)

										;substition features may be set outside of setting attributes, so any of these means we have encoded values that need to be decoded for output
										(if
											(or
												hasSubstituteFeatureValues
												has_rounded_features
												has_string_ordinals
												has_datetime_features
												has_booleans
											)
											(assign
												(assoc
													has_encoded_features (true)
												)
											)
										)

										;the set of features that need to be encoded in some way during training: string nominals, string ordinals, booleans and datetimes
										(declare
											(assoc
												encoding_needed_features_set (zip
														(append
															(indices
																string_nominal_features_set
															)
															(indices
																feature_datetime_map
															)
															(indices
																ordinal_string_to_ordinal_map
															)
															(indices
																(filter
																	(lambda
																		(=
																			"boolean"
																			(current_value)
																		)
																	)
																	non_string_nominal_features_map
																)
															)
														)
													)
											)
										)
										(if
											(size boundaries_map)
											(assign
												(assoc
													feature_bounds_map (call
															ComposeBoundariesMap
														)
												)
											)
										)
										(if
											(size custom_derived_features_map)
											(seq
												(assign
													(assoc
														custom_derived_features_map (filter
																(lambda
																	(or
																		(=
																			"custom"
																			(get
																				(current_value)
																				(list
																					"auto_derive_on_train"
																					"derive_type"
																				)
																			)
																		)
																		(!=
																			(null)
																			(get
																				(current_value)
																				"derived_feature_code"
																			)
																		)
																	)
																)
																custom_derived_features_map
															)
														derived_features_map (filter
																(lambda
																	(!=
																		(null)
																		(get
																			(current_value)
																			"auto_derive_on_train"
																		)
																	)
																)
																custom_derived_features_map
															)
													)
												)

												;Accumulate source_to_derived_feature_map from all the auto_derive_on_train features
												(call AccumulateSourceToDerivedFeatureMap)

												;cache all the custom specified derivation code
												(assign
													(assoc
														feature_custom_derived_methods (call
																ComposeCustomDerivedMethods
															)
													)
												)
											)
										)
										(declare
											(assoc
												query_feature_limits_map (call
														ComposeFeatureLimitsMap
													)
												query_distance_type_map (call
														ComposeDistanceTypeMap
													)
											)
										)
										(assign_to_entities
											(assoc
												hasFeaturesNeedEncodingFromInput (>
														(size
															encoding_needed_features_set
														)
														0
													)
												uniqueNominalsMap unique_nominals_map
												hasBooleans has_booleans
												continuousDependentsMap continuous_dependents_map
												hasStringOrdinals has_string_ordinals
												stringNominalFeaturesSet string_nominal_features_set
												featureAttributes features
												ordinalStringToOrdinalMap ordinal_string_to_ordinal_map
												queryDistanceTypeMap query_distance_type_map
												featureCustomDerivedMethods feature_custom_derived_methods
												nonStringNominalFeaturesMap non_string_nominal_features_map
												dependentFeatureMap dependents_map
												featureRoundingMap feature_rounding_map
												sourceToDerivedFeatureMap source_to_derived_feature_map
												hasEncodedFeatures has_encoded_features
												featureBoundsMap feature_bounds_map
												userSpecifiedFeatureErrorsMap user_specified_feature_errors_map
												derivedFeaturesMap (zip
														(indices
															derived_features_map
														)
													)
												hasDependentFeatures has_dependent_features
												featureDateTimeMap feature_datetime_map
												hasRoundedFeatures has_rounded_features
												queryFeatureLimitsMap query_feature_limits_map
												encodingNeededFeaturesSet encoding_needed_features_set
												hasDateTimeFeatures has_datetime_features
												ordinalOrdinalToStringMap ordinal_ordinal_to_string_map
											)
										)
										(call
											SetOrdinalFeatures
											(assoc ordinal_features ordinals)
										)
										(call
											SetNominalFeatures
											(assoc nominal_features nominals)
										)
										(call
											SetCyclicFeatures
											(assoc features cyclics_map)
										)

										;overwrite computed deviations with user specified ones if user specified ones were larger
										(if
											(>
												(size userSpecifiedFeatureErrorsMap)
												0
											)
											(assign_to_entities
												(assoc
													hyperparameterMetadataMap (map
															(lambda
																(let
																	(assoc
																		hp_map (current_value
																				1
																			)
																	)
																	(map
																		(lambda
																			(let
																				(assoc
																					mode_map (current_value
																							1
																						)
																				)
																				(map
																					(lambda
																						(let
																							(assoc
																								deviations_map (get
																										(current_value
																											1
																										)
																										"featureDeviations"
																									)
																								weight_feature (current_index
																										1
																									)
																								feature_map (current_value
																										1
																									)
																							)
																							(if
																								(!=
																									(null)
																									deviations_map
																								)
																								(map
																									(lambda
																										(assign
																											(assoc
																												deviations_map (set
																														deviations_map
																														(current_index
																															1
																														)

																														;max of user specified and stored deviation in the map
																														(max
																															(current_value
																																1
																															)
																															(get
																																deviations_map
																																(current_index
																																	1
																																)
																															)
																														)
																													)
																											)
																										)
																									)
																									userSpecifiedFeatureErrorsMap
																								)
																							)
																							(accum
																								(assoc
																									feature_map (assoc
																											featureDeviations deviations_map
																										)
																								)
																							)
																							feature_map
																						)
																					)
																					mode_map
																				)
																			)
																		)
																		hp_map
																	)
																)
															)
															hyperparameterMetadataMap
														)
												)
											)
										)
									)

									;map-filter weave produces a list of string, assoc combinations, assoc conversion makes the strings keys and values the assoc
									##ComposeCyclicsMap
									(apply
										"assoc"
										(weave
											(lambda
												(if
													(>
														(get
															(last
																(current_value)
															)
															"cycle_length"
														)
														0
													)
													(list
														(first
															(current_value
																1
															)
														)
														(get
															(last
																(current_value
																	1
																)
															)
															"cycle_length"
														)
													)

													;else don't output anything, map-filtering out any values that don't have cyclics
													(list)
												)
											)
											(indices features)
											(values features)
										)
									)
									##ComposeDateTimeMap
									(apply
										"assoc"
										(weave
											(lambda
												(if
													(!=
														(null)
														(get
															(last
																(current_value)
															)
															"date_time_format"
														)
													)
													(let
														(assoc
															locale (get
																	(last
																		(current_value
																			1
																		)
																	)
																	"locale"
																)
															date_time_format (get
																	(last
																		(current_value
																			1
																		)
																	)
																	"date_time_format"
																)
															time_delta_format (get
																	(last
																		(current_value
																			1
																		)
																	)
																	"time_delta_format"
																)
														)
														(list
															(first
																(current_value
																	1
																)
															)
															(assoc
																locale locale
																date_time_format (concat
																		"date:"
																		date_time_format
																	)
																time_delta_format time_delta_format
															)
														)
													)

													;else don't output anything, map-filtering out any values that don't have datetimes
													(list)
												)
											)
											(indices features)
											(values features)
										)
									)
									##ComposeRoundingMap
									(apply
										"assoc"
										(weave
											(lambda
												(if
													(or
														(!=
															(null)
															(get
																(last
																	(current_value)
																)
																"decimal_places"
															)
														)
														(!=
															(null)
															(get
																(last
																	(current_value)
																)
																"significant_digits"
															)
														)
													)
													(let
														(assoc
															decimal_places (get
																	(last
																		(current_value
																			1
																		)
																	)
																	"decimal_places"
																)
															feature (first
																	(current_value
																		1
																	)
																)
															significant_digits (get
																	(last
																		(current_value
																			1
																		)
																	)
																	"significant_digits"
																)
														)
														(if
															(and
																(!=
																	(null)
																	decimal_places
																)
																(!=
																	(null)
																	significant_digits
																)
															)
															(list
																feature
																(list
																	significant_digits
																	decimal_places
																)
															)
															(!=
																(null)
																decimal_places
															)

															;ignore the significant digit by setting it to max value of 18
															(list
																feature
																(list
																	18
																	decimal_places
																)
															)

															;else if only the significant digits are specified, store that
															(!=
																(null)
																significant_digits
															)
															(list
																feature
																(list
																	significant_digits
																)
															)
														)
													)

													;else don't output anything, map-filtering out any values that don't have rounded features
													(list)
												)
											)
											(indices features)
											(values features)
										)
									)

									;map-filter weave
									##ComposeUserSpecifiedFeatureErrorsMap
									(apply
										"assoc"
										(weave
											(lambda
												(if
													(!=
														(null)
														(get
															(last
																(current_value)
															)
															"observational_error"
														)
													)
													(list
														(first
															(current_value
																1
															)
														)
														(get
															(last
																(current_value
																	1
																)
															)
															"observational_error"
														)
													)

													;else don't output anything, map-filtering out any values that don't have cyclics
													(list)
												)
											)
											(indices features)
											(values features)
										)
									)
									##ComposeDependentsMap
									(let
										(assoc
											full_dependents_map (assoc)
											dependents_map
												;map-filter weave, leaves an assoc of:  feature -> { "dependent_features": [ ... ] } for those that have dependent_features
												(apply
													"assoc"
													(weave
														(lambda
															(if
																(!=
																	(null)
																	(get
																		(last
																			(current_value)
																		)
																		"dependent_features"
																	)
																)
																(list
																	(first
																		(current_value
																			1
																		)
																	)
																	(assoc
																		dependent_features (get
																				(last
																					(current_value
																						2
																					)
																				)
																				"dependent_features"
																			)
																	)
																)

																;else don't output anything, map-filtering out any values that don't have dependent features
																(list)
															)
														)
														(indices
															features
														)
														(values
															features
														)
													)
												)
										)

										;copy the original dependents_map so that it can be populated if necessary below
										(assign
											(assoc
												full_dependents_map (get_value
														dependents_map
													)
											)
										)

										;ensure that every feature listed as a dependent feature has whatever feature referenced it in their own dependent_features list as well
										;e.g., if user only provided that  A -> [B, C] ensure that B -> [A] and C -> [A] as well
										(map
											(lambda
												(let
													(assoc
														feature (get_value
																(current_index
																	1
																)
															)
													)

													;iterate over all the dependents and ensure they are added to full_dependents_map if they aren't there
													;e.g., from the example above, for feature A, iterate over [B, C], pulling B's and then C's
													;dependent_features lists and accumulate A to each if needed
													(map
														(lambda
															(if
																(not
																	(contains_value
																		(get
																			full_dependents_map
																			(list
																				(current_value
																					1
																				)
																				"dependent_features"
																			)
																		)
																		feature
																	)
																)
																(accum
																	"full_dependents_map"
																	(list
																		(current_value
																			1
																		)
																		"dependent_features"
																	)
																	(list
																		feature
																	)
																)
															)
														)

														;list of dependent_features for this feature
														(get
															(current_value)
															"dependent_features"
														)
													)
												)
											)
											dependents_map
										)

										;return the filled dependents map
										full_dependents_map
									)
									##ComposeContinuousDependentsMap
									(let
										(assoc
											dependent_continuous_features_map
												;filter out nominal features, leaving only continuous ones
												(filter
													(lambda
														(not
															(contains_index
																nominals_map
																(get_value
																	(current_index)
																)
															)
														)
													)
													dependents_map
												)
										)

										;output an assoc of continuous feature -> [ list of sorted nominal dependents ]
										(map
											(lambda
												(filter
													(lambda
														(contains_index
															nominals_map
															(current_value)
														)
													)
													(sort
														(get
															(current_value)
															"dependent_features"
														)
													)
												)
											)
											dependent_continuous_features_map
										)
									)

									;map-filter weave
									##ComposeNonStringNominalsMap
									(apply
										"assoc"
										(weave
											(lambda

												;only allowed data_type values are number and boolean, all others are ignored
												(if
													(contains_value
														(list
															"number"
															"boolean"
														)
														(get
															(last
																(current_value)
															)
															"data_type"
														)
													)
													(list
														(first
															(current_value
																1
															)
														)
														(get
															(last
																(current_value
																	1
																)
															)
															"data_type"
														)
													)

													;else don't output anything, map-filtering out any values that don't have datype defined
													(list)
												)
											)
											(indices features)
											(values features)
										)
									)
									##ComposeBoundariesMap
									(map
										(lambda
											(let
												(assoc
													feature (get_value
															(current_index
																1
															)
														)
													bounds_map (or
															(get
																(current_value
																	1
																)
																"bounds"
															)
															(assoc)
														)
													allow_null_param (get
															(current_value
																1
															)
															"allow_null"
														)
												)

												;cache epoch max and min values so that they don't have to be repeatedly calculated later
												(if
													(contains_index
														feature_datetime_map
														feature
													)
													(let
														(assoc
															boundary_min (get
																	bounds_map
																	"min"
																)
															boundary_max (get
																	bounds_map
																	"max"
																)
														)
														(accum
															(assoc
																bounds_map (assoc
																		epoch_max_value (if
																				(!=
																					(null)
																					boundary_max
																				)
																				(if
																					(!=
																						"number"
																						(get_type_string
																							boundary_max
																						)
																					)
																					(call
																						ConvertDateToEpoch
																						(assoc
																							date boundary_max
																							feature feature
																							feature_datetime_map feature_datetime_map
																						)
																					)

																					;else boundary value was provided in epoch number format already, keep it as-is
																					boundary_max
																				)
																			)
																		has_epoch_bounds (true)
																		epoch_min_value (if
																				(!=
																					(null)
																					boundary_min
																				)
																				(if
																					(!=
																						"number"
																						(get_type_string
																							boundary_min
																						)
																					)
																					(call
																						ConvertDateToEpoch
																						(assoc
																							date boundary_min
																							feature feature
																							feature_datetime_map feature_datetime_map
																						)
																					)

																					;else boundary value was provided in epoch number format already, keep it as-is
																					boundary_min
																				)
																			)
																	)
															)
														)
													)
												)

												;bounds map contains the min and max from 'bounds' and allow_null parameters
												(append
													bounds_map
													(if
														(!=
															(null)
															allow_null_param
														)
														(assoc
															allow_null allow_null_param
														)
														(assoc)
													)
												)
											)
										)
										boundaries_map
									)
									##ComposeCustomDerivedMethods
									(map
										(lambda
											(let
												(assoc
													attributes (current_value
															1
														)
													train_derived_method (null)
													feature (get_value
															(current_index
																1
															)
														)
												)
												(if
													(=
														"custom"
														(get
															attributes
															(list
																"auto_derive_on_train"
																"derive_type"
															)
														)
													)
													(assign
														(assoc
															train_derived_method (call
																	ParseDerivedFeatureCode
																	(assoc
																		label_to_code (lambda
																				(if
																					(and
																						(>=
																							(-
																								series_row_index
																								label_value
																							)
																							0
																						)
																						(contains_index
																							feat_index_map
																							label_name
																						)
																					)

																					;pull the feature value
																					(get
																						series_data
																						(list
																							(-
																								series_row_index
																								label_value
																							)
																							(get
																								feat_index_map
																								label_name
																							)
																						)
																					)
																					(null)
																				)
																			)
																		code_string (get
																				attributes
																				(list
																					"auto_derive_on_train"
																					"code"
																				)
																			)
																	)
																)
														)
													)
												)

												;if feature has custom specified derived code, compute and cache it
												(if
													(contains_index
														attributes
														"derived_feature_code"
													)
													(let
														(assoc
															parsed_code_string_labels_map (get_all_labels
																	(parse
																		(get
																			attributes
																			"derived_feature_code"
																		)
																	)
																)
															raw_code_string (get
																	attributes
																	"derived_feature_code"
																)
														)

														;grab the the largest value in the code to find the max lag
														(declare
															(assoc
																max_row_lag (apply
																		"max"
																		(values
																			parsed_code_string_labels_map
																		)
																	)
															)
														)

														;add the max_row_lag attribute to this feature attribute
														(assign
															"features"
															(list
																feature
																"max_row_lag"
															)
															max_row_lag
														)

														;cache the parsed single and series react derived custom code methods for this feature
														(assoc
															react (call
																	ParseDerivedFeatureCode
																	(assoc
																		label_to_code (lambda

																				;feature label offsets must all be 0 to derive valid values since we can only pull data from the
																				;one existing 'row' of data that is provided for computation. Any values other than 0 output a null.
																				(if
																					(and
																						(=
																							label_value
																							0
																						)
																						(contains_index
																							feature_values_map
																							label_name
																						)
																					)
																					(get
																						feature_values_map
																						label_name
																					)
																					(null)
																				)
																			)
																		code_string raw_code_string
																	)
																)
															series_react (call
																	ParseDerivedFeatureCode
																	(assoc
																		label_to_code (lambda
																				(if
																					(and
																						(>=
																							(-
																								series_row_index
																								label_value
																							)
																							0
																						)
																						(contains_index
																							feature_index_map
																							label_name
																						)
																					)
																					(let
																						(assoc
																							val (get
																									series_data
																									(list
																										(-
																											series_row_index
																											label_value
																										)
																										(get
																											feature_index_map
																											label_name
																										)
																									)
																								)
																						)

																						;encode datetime by converting string date time into seconds since epoch
																						(if
																							(contains_index
																								featureDateTimeMap
																								label_name
																							)
																							(if
																								(!=
																									(null)
																									val
																								)
																								(call
																									ConvertDateToEpoch
																									(assoc
																										date val
																										feature label_name
																									)
																								)
																							)

																							;not a datetime, return continuous value
																							val
																						)
																					)

																					;invalid input
																					(null)
																				)
																			)
																		code_string raw_code_string
																	)
																)
															train train_derived_method
														)
													)

													;else feature only has a train-derive method, cache that
													(!=
														(null)
														train_derived_method
													)
													(assoc
														train train_derived_method
													)
												)
											)
										)
										custom_derived_features_map
									)
									##AccumulateSourceToDerivedFeatureMap
									(map
										(lambda
											(let
												(assoc
													feature (get_value
															(current_index
																1
															)
														)
													attributes (current_value
															1
														)
												)
												(if
													(contains_index
														attributes
														"auto_derive_on_train"
													)
													(let
														(assoc
															derive_type (get
																	attributes
																	(list
																		"auto_derive_on_train"
																		"derive_type"
																	)
																)
														)

														;append this derived feature name to the list of derived features for its matching source feature(s)
														(if
															(=
																"end"
																derive_type
															)
															(let
																(assoc
																	source_feature_name (get
																			attributes
																			(list
																				"auto_derive_on_train"
																				"end_time_feature"
																			)
																		)
																	derived_features_list (get
																			source_to_derived_feature_map
																			(get
																				attributes
																				(list
																					"auto_derive_on_train"
																					"end_time_feature"
																				)
																			)
																		)
																)
																(if
																	(=
																		(null)
																		derived_features_list
																	)
																	(assign
																		(assoc
																			derived_features_list (list)
																		)
																	)
																)
																(accum
																	(assoc
																		source_to_derived_feature_map (associate
																				source_feature_name
																				(append
																					derived_features_list
																					feature
																				)
																			)
																	)
																)
															)
															(=
																"start"
																derive_type
															)
															(let
																(assoc
																	source_feature_name (get
																			attributes
																			(list
																				"auto_derive_on_train"
																				"start_time_feature"
																			)
																		)
																	derived_features_list (get
																			source_to_derived_feature_map
																			(get
																				attributes
																				(list
																					"auto_derive_on_train"
																					"start_time_feature"
																				)
																			)
																		)
																)
																(if
																	(=
																		(null)
																		derived_features_list
																	)
																	(assign
																		(assoc
																			derived_features_list (list)
																		)
																	)
																)
																(accum
																	(assoc
																		source_to_derived_feature_map (associate
																				source_feature_name
																				(append
																					derived_features_list
																					feature
																				)
																			)
																	)
																)
															)
															(=
																"custom"
																derive_type
															)
															(let
																(assoc
																	parsed_code_string_labels_map (get_all_labels
																			(parse
																				(get
																					attributes
																					(list
																						"auto_derive_on_train"
																						"code"
																					)
																				)
																			)
																		)
																	raw_code_string (get
																			attributes
																			(list
																				"auto_derive_on_train"
																				"code"
																			)
																		)
																)
																(declare
																	(assoc
																		sourced_features (indices
																				parsed_code_string_labels_map
																			)
																	)
																)
																(map
																	(lambda
																		(let
																			(assoc
																				source_feature_name (current_value
																						1
																					)
																				derived_features_list (get
																						source_to_derived_feature_map
																						(current_value
																							1
																						)
																					)
																			)
																			(if
																				(=
																					(null)
																					derived_features_list
																				)
																				(assign
																					(assoc
																						derived_features_list (list)
																					)
																				)
																			)
																			(accum
																				(assoc
																					source_to_derived_feature_map (associate
																							source_feature_name
																							(append
																								derived_features_list
																								feature
																							)
																						)
																				)
																			)
																		)
																	)
																	sourced_features
																)
															)
														)
													)
												)
											)
										)
										derived_features_map
									)

									;output all feature attributes as a list of assocs
									##GetFeatureAttributes
									(seq

										;if feature attributes is empty but there are feature definitions, manually populate featureAttributes
										(if
											(and
												(!=
													(null)
													defaultFeatures
												)
												(=
													(assoc)
													featureAttributes
												)
											)
											(assign_to_entities
												(assoc
													featureAttributes
														;iterate over the default features as an assoc, such that they keys are feature names
														;and the values are the feature attributes
														(map
															(lambda
																(let
																	(assoc
																		locale (get
																				featureDateTimeMap
																				(list
																					(get_value
																						(current_index
																							2
																						)
																					)
																					"locale"
																				)
																			)
																		decimal_places (get
																				featureRoundingMap
																				(list
																					(get_value
																						(current_index
																							2
																						)
																					)
																					1
																				)
																			)
																		cycle_length (get
																				cyclicFeaturesMap
																				(get_value
																					(current_index
																						1
																					)
																				)
																			)
																		type (if
																				(contains_index
																					nominalsSet
																					(get_value
																						(current_index
																							1
																						)
																					)
																				)
																				"nominal"
																				(contains_value
																					ordinalFeatures
																					(get_value
																						(current_index
																							1
																						)
																					)
																				)
																				"ordinal"

																				;else
																				"continuous"
																			)
																		significant_digits (get
																				featureRoundingMap
																				(list
																					(get_value
																						(current_index
																							2
																						)
																					)
																					0
																				)
																			)
																		observational_error (get
																				userSpecifiedFeatureErrorsMap
																				(get_value
																					(current_index
																						1
																					)
																				)
																			)
																		date_time_format (get
																				featureDateTimeMap
																				(list
																					(get_value
																						(current_index
																							2
																						)
																					)
																					"date_time_format"
																				)
																			)
																		time_delta_format (get
																				featureDateTimeMap
																				(list
																					(get_value
																						(current_index
																							2
																						)
																					)
																					"time_delta_format"
																				)
																			)
																	)

																	;create an assoc of feature attributes
																	(append
																		(assoc
																			type type
																		)
																		(if
																			(!=
																				(null)
																				decimal_places
																			)
																			(assoc
																				decimal_places decimal_places
																			)
																			(assoc)
																		)
																		(if
																			(!=
																				(null)
																				significant_digits
																			)
																			(assoc
																				significant_digits significant_digits
																			)
																			(assoc)
																		)
																		(if
																			(!=
																				(null)
																				cycle_length
																			)
																			(assoc
																				cycle_length cycle_length
																			)
																			(assoc)
																		)
																		(if
																			(!=
																				(null)
																				observational_error
																			)
																			(assoc
																				observational_error observational_error
																			)
																			(assoc)
																		)
																		(if
																			(!=
																				(null)
																				date_time_format
																			)
																			(assoc
																				date_time_format date_time_format
																			)
																			(assoc)
																		)
																		(if
																			(!=
																				(null)
																				locale
																			)
																			(assoc
																				locale locale
																			)
																			(assoc)
																		)
																		(if
																			(!=
																				(null)
																				time_delta_format
																			)
																			(assoc
																				time_delta_format time_delta_format
																			)
																			(assoc)
																		)
																	)
																)
															)
															(zip
																defaultFeatures
															)
														)
												)
											)
										)

										;output stored featureAttributes
										(get_value featureAttributes)
									)

									;a recursive method to generate a nested assoc of feature values -> (feature values) -> min,max boundary for those values
									;when provided a list of nominal features and a their dependent continuous value feature
									;for example, if there are two nominal features named 'measure' and 'unit', and a continuous feature named 'amount',
									;this would generate a nested dict of all measure-units -> min,max bounds for each respective measure and unit combination
									;
									;parameters:
									; base_query_among: the list of query_among's that should be appended to for each recursive call
									; value_feature: name of the continuous feature for which we want to determine all the possible min/max bounds
									; nominals: list of nominal features corresponding to the continuous value feature
									##ComputeDependentBoundaries
									(declare
										(assoc
											base_query_among (list)
											feature (null)
											value_feature ""
											nominals (list)
										)
										(assign
											(assoc
												feature (first
														nominals
													)
												nominals (tail
														nominals
													)
											)
										)

										;pull all the unique values for this nominal feature
										(declare
											(assoc
												feature_values (indices
														(compute_on_contained_entities
															(list

																;if non-string nominal, pull as numeric count
																(query_value_masses
																	feature
																	(null)
																	(contains_index
																		nonStringNominalFeaturesMap
																		feature
																	)
																)
															)
														)
													)
											)
										)

										;if there are more dependent nominals, we need to call this method for those nominals recursively,
										;once for each feature value for this feature.  for example, if there are two nominal features A (with values 'h','i' and 'j')
										;and B with values 'x','y','z', we'll call this method for each value of A, with nominals=[B] and base_query_among = (list (query_among "A" (list "h"))),
										;then again with base_query_among = (list (query_among "A" (list "i"))), and finally with base_query_among = (list (query_among "A" (list "j"))),
										(if
											(>
												(size nominals)
												0
											)
											(map
												(lambda
													(let
														(assoc
															query_among (append
																	base_query_among
																	(list
																		(query_among
																			feature
																			(list
																				(+
																					(current_index
																						3
																					)
																				)
																			)
																		)
																	)
																)
														)
														(call
															ComputeDependentBoundaries
															(assoc
																base_query_among query_among
																value_feature value_feature
																nominals nominals
															)
														)
													)
												)
												(zip feature_values)
											)

											;else there are no more dependent nominals left, continuing the above example, we iterate over all the values of this last nominal feature 'B'
											;appending to each of the query amongs passed in, to create all the combinations of feature values for A and B,
											;eg., h+x, h+y, h+z, i+x, i+y, etc...  so h+x is in the format of (list (query_among "A" (list "h")) (query_among "B" (list "x")))
											;given all these possible combinations of feature values, we determine the min and max value for the continous feature and output it as a
											;pair of (list min max) for feature value combinations that exist or (null) for those that don't, resulting in a nested assoc that may look like:
											; { 'h': {'x': (list 0 10) }, 'h': {'y': (null) }, 'h': {'z': (null) }, 'i': {'x': (null) }, 'i': {'y': (list 10 100) }, etc... }
											(map
												(lambda
													(let
														(assoc
															query_among (append
																	base_query_among
																	(list
																		(query_among
																			feature
																			(list
																				(+
																					(current_index
																						3
																					)
																				)
																			)
																		)
																	)
																)
															min_value (null)
														)

														;pull the case with the smallest value for the continous feature given the constructed query_among with the nominal value combinations
														;if there are no cases for such query_among(s), min_case will be null and we output (null) for the bounds pair
														(assign
															(assoc
																min_case (contained_entities
																		(append
																			query_among
																			(query_min
																				value_feature
																				1
																			)
																		)
																	)
															)
														)

														;if there does exist a case with a minimum value, that means there must also be a max value, so we return the bounds pair for this
														;combination of nominal values
														(if
															(size
																min_case
															)
															(list
																(retrieve_from_entity
																	min_case
																	value_feature
																)
																(retrieve_from_entity
																	(contained_entities
																		(append
																			query_among
																			(query_max
																				value_feature
																				1
																			)
																		)
																	)
																	value_feature
																)
															)
														)
													)
												)
												(zip feature_values)
											)
										)
									)

									;Recursive method to process the computed dependent boundary map into a list of valid nominal value combinations
									; If there are two dependent nominal features with 4 values each, while there may be 16 unique combinations of values,
									; realistically only 4 are probably valid, so this method filters out all the combinations that do not have a min,max boundary,
									; leaving a list of lists of valid feature values.  Example: 'heartrate' and 'BPM' are valid, but 'heartrate' and 'mSv' is not.
									##AccumulateDependentValuesCombinations
									(values
										(map
											(lambda
												(let
													(assoc
														value (+
																(get_value
																	(current_index
																		1
																	)
																)
															)
													)

													;call recursively to iterate down the nested accos
													(if
														(=
															"assoc"
															(get_type_string
																(current_value)
															)
														)
														(call
															AccumulateDependentValuesCombinations
															(assoc
																values_lists (append
																		values_lists
																		value
																	)
																nested_value_combinations_map (current_value
																		1
																	)
															)
														)

														;else return the accumulated list of nested keys for this iteration and append the full list to the global list
														(seq
															(if
																(!=
																	(null)
																	(current_value)
																)
																(accum
																	(assoc
																		dependent_values_combinations (list
																				(append
																					values_lists
																					value
																				)
																			)
																	)
																)
															)
															(append
																values_lists
																value
															)
														)
													)
												)
											)
											nested_value_combinations_map
										)
									)

									;Helper method to create a map of feature -> distance type for all the features for use in queries
									##ComposeDistanceTypeMap
									(map
										(lambda
											(if
												(contains_index
													nominals_map
													(current_index)
												)
												"nominal"
												(contains_index
													cyclics_map
													(current_index)
												)
												"cyclic"

												;TODO: 14039 not yet supported
												(and
													(=
														"continuous"
														(get
															(current_value)
															"type"
														)
													)
													(=
														"string"
														(get
															(current_value)
															"data_type"
														)
													)
												)
												"string"

												;TODO: 14039 not yet supported
												(=
													"code"
													(get
														(current_value)
														"type"
													)
												)
												"code"

												;else default value
												"continuous"
											)
										)
										features
									)

									;Helper method to creata  map of feature -> limits, based on the type of feature it is and limits specified in boundaries map
									##ComposeFeatureLimitsMap
									(map
										(lambda
											(let
												(assoc
													feature (current_index
															1
														)
												)
												(if

													;nominal should provide nominalClassCountsMap, but null will use query-engine built-in counts
													(contains_index
														nominals_map
														feature
													)
													(null)

													;cyclic min/max is 0 - cycle length
													(contains_index
														cyclics_map
														feature
													)
													(list
														0
														(get
															cyclics_map
															feature
														)
													)

													;max string length
													(and
														(=
															"continuous"
															(get
																(current_value)
																"type"
															)
														)
														(=
															"string"
															(get
																(current_value)
																"data_type"
															)
														)
													)
													(get
														feature_bounds_map
														(list
															feature
															"max"
														)
													)

													;max code size
													(=
														"code"
														(get
															(current_value)
															"type"
														)
													)
													(get
														feature_bounds_map
														(list
															feature
															"max"
														)
													)

													;else "continuous", if min or max are specified, provide as a tuple of [min, max]
													(if
														(or
															(!=
																(null)
																(get
																	feature_bounds_map
																	(list
																		feature
																		"min"
																	)
																)
															)
															(!=
																(null)
																(get
																	feature_bounds_map
																	(list
																		feature
																		"max"
																	)
																)
															)
														)
														(list
															(get
																feature_bounds_map
																(list
																	feature
																	"min"
																)
															)
															(get
																feature_bounds_map
																(list
																	feature
																	"max"
																)
															)
														)
													)
												)
											)
										)
										features
									)
								)

								;module for trainee_template
								;contains methods for reacting
								(null

									;Run react_series in a batch, output a list of outputs from each individual react_series.
									;
									;parameters:  same as #react_series, unless listed here
									;  batch_size: number of react_series to do in a batch.
									;  rand_seed:  optional, see #react for description.  if specified must be length of batch size.
									;  series_context_values: optional, 3d-list of values, context value for each feature for each row of a series.
									;		If specified, batch_size and max_series_lengths are ignored.
									;  series_context_features: optional, features corresponding to series_context_values
									;
									;	 All of the following parameters, if specified, must be either length of 1 or batch_size.
									;
									;  initial_values - list of lists. see #react_series for description.
									;  series_stop_maps - list of assocs. see #react_series for description.
									;  max_series_lengths - list of values. see #react_series for description.
									;  context_values - list of lists.  see #react for description.
									;  action_values - list of lists.  see #react for description.
									;  case_indices - list of lists.  see #react for description.
									##BatchReactSeries
									(declare
										(assoc
											single_max_length (=
													1
													(size
														max_series_lengths
													)
												)
											has_series_context_values (false)
											single_context (=
													1
													(size
														context_values
													)
												)
											single_action (=
													1
													(size
														action_values
													)
												)
											single_stop_map (=
													1
													(size
														series_stop_maps
													)
												)
											batch_size 1
											single_session (=
													1
													(size
														case_indices
													)
												)
											single_initial (=
													1
													(size
														initial_values
													)
												)
										)

										;these lists must be either a list of lists or null; if it's an empty list, treat it as null
										(if
											(= (list) context_values)
											(assign
												(assoc
													context_values (null)
												)
											)
										)
										(if
											(= (list) action_values)
											(assign
												(assoc
													action_values (null)
												)
											)
										)
										(if
											(= (list) initial_values)
											(assign
												(assoc
													initial_values (null)
												)
											)
										)
										(if
											(= (list) series_stop_maps)
											(assign
												(assoc
													series_stop_maps (null)
												)
											)
										)
										(if
											(size series_context_values)
											(assign
												(assoc
													has_series_context_values (true)
													batch_size (size
															series_context_values
														)
												)
											)
										)
										(assoc
											react_results ||(map
													(lambda
														(let
															(assoc
																action_index (if
																		single_action
																		0
																		(current_value
																			1
																		)
																	)
																max_length_index (if
																		single_max_length
																		0
																		(current_value
																			1
																		)
																	)
																context_index (if
																		single_context
																		0
																		(current_value
																			1
																		)
																	)
																initial_index (if
																		single_initial
																		0
																		(current_value
																			1
																		)
																	)
																react_rand_seed (if
																		rand_seed
																		(get
																			rand_seed
																			(current_value
																				1
																			)
																		)
																	)
																react_series_context_values (if
																		has_series_context_values
																		(get
																			series_context_values
																			(current_value
																				1
																			)
																		)
																		(list)
																	)
																react_session (null)
																react_session_training_index (null)
																session_index (if
																		single_session
																		0
																		(current_value
																			1
																		)
																	)
																stop_map_index (if
																		single_stop_map
																		0
																		(current_value
																			1
																		)
																	)
															)

															;get the corresponding parameters by the index, values will be null if not specified, but must be defaulted to an empty list/assoc
															(declare
																(assoc
																	react_max_series_length (get
																			max_series_lengths
																			max_length_index
																		)
																	react_initial_values (if
																			initial_values
																			(get
																				initial_values
																				initial_index
																			)
																			(list)
																		)
																	react_context_values (if
																			context_values
																			(get
																				context_values
																				context_index
																			)
																			(list)
																		)
																	react_action_values (if
																			action_values
																			(get
																				action_values
																				action_index
																			)
																			(list)
																		)
																	react_series_stop_map (if
																			series_stop_maps
																			(get
																				series_stop_maps
																				stop_map_index
																			)
																			(assoc)
																		)
																)
															)

															;if one of these is provided, both of them must be
															(if
																case_indices
																(assign
																	(assoc
																		react_case_index (get
																				case_indices
																				session_index
																			)
																	)
																)
															)
															(call
																ReactSeries
																(assoc
																	use_regional_model_residuals use_regional_model_residuals
																	max_series_length react_max_series_length
																	details details
																	ignore_case ignore_case
																	context_values react_context_values
																	weight_feature weight_feature
																	leave_case_out leave_case_out
																	extra_audit_features extra_audit_features
																	case_access_count_label case_access_count_label
																	action_values react_action_values
																	input_is_substituted input_is_substituted
																	derived_action_features derived_action_features
																	series_context_features series_context_features
																	derived_context_features derived_context_features
																	generate_new_cases generate_new_cases
																	use_case_weights use_case_weights
																	rand_seed react_rand_seed
																	substitute_output substitute_output
																	preserve_feature_values preserve_feature_values
																	initial_values react_initial_values
																	initial_features initial_features
																	action_features action_features
																	series_context_values react_series_context_values
																	desired_conviction desired_conviction
																	feature_bounds_map feature_bounds_map
																	series_stop_map react_series_stop_map
																	context_features context_features
																	new_series_id_features new_series_id_features
																	case_indices react_case_index
																	ordered_by_specified_features ordered_by_specified_features
																)
															)
														)
													)
													(range
														0
														(-
															batch_size
															1
														)
													)
												)
											action_features (append
													action_features
													derived_action_features
												)
										)
									)

									;Run reacts in a batch, output a list of outputs from each individual react.
									;
									;parameters:  same as #react, unless listed here
									;  batch_size: number of reacts to do in a batch.
									;  context_values - list of lists.  see #react for description. if specified must be either length of 1 or batch_size.
									;  action_values - list of lists.  see #react for description. if specified must be either length of 1 or batch_size.
									;  case_indices - list of lists.  see #react for description. if specified must be either length of 1 or batch_size.
									;  rand_seed - optional, see #react for description.  if specified must be length of batch size.
									##BatchReact
									(declare
										(assoc
											single_context (=
													1
													(size
														context_values
													)
												)
											single_action (=
													1
													(size
														action_values
													)
												)
											batch_size 1
											single_session (=
													1
													(size
														case_indices
													)
												)
										)

										;action and context_values must be either a list of lists or null; if it's an empty list, treat it as null
										(if
											(= (list) context_values)
											(assign
												(assoc
													context_values (null)
												)
											)
										)
										(if
											(= (list) action_values)
											(assign
												(assoc
													action_values (null)
												)
											)
										)

										;assoc of feature -> list of batch_size unique values, pre-populated if there are unique features that need to be synthed
										(declare
											(assoc
												generated_uniques_list_map
													;if doing generative reacts with unique nominals, generate the requested number of uniques values prior to synthesis
													(if
														(and
															(!=
																(null)
																desired_conviction
															)
															(>
																(size
																	uniqueNominalsMap
																)
																0
															)

															;generating unique nominal actions
															(>
																(size
																	(intersect
																		(zip
																			action_features
																		)
																		uniqueNominalsMap
																	)
																)
																0
															)
														)
														(call
															GenerateUniquesListMap
															(assoc
																batch_size batch_size
																preserve_feature_values preserve_feature_values
																action_features action_features
																context_features context_features
															)
														)
													)
											)
										)
										(if
											(!= (null) into_series_store)
											(accum_to_entities
												(assoc
													revision 1
												)
											)
										)
										(assoc
											react_results
												;TODO: 11201: react into_series_store works with MT
												(if
													(=
														(null)
														into_series_store
													)
													||(map
														##!ReactFunction
														(lambda
															(let
																(assoc
																	pre_generated_uniques_map (if
																			(!=
																				(null)
																				generated_uniques_list_map
																			)
																			(if
																				(=
																					1
																					batch_size
																				)
																				generated_uniques_list_map

																				;create a map for each unique feature to its corresponding value by the index (current_value 2) of which case
																				;is being synthed when synthing > 1 case
																				(map
																					(lambda
																						(get
																							(current_value)
																							(current_value
																								2
																							)
																						)
																					)
																					generated_uniques_list_map
																				)
																			)
																		)
																	action_index (if
																			single_action
																			0
																			(current_value
																				1
																			)
																		)
																	context_index (if
																			single_context
																			0
																			(current_value
																				1
																			)
																		)
																	react_rand_seed (if
																			rand_seed
																			(get
																				rand_seed
																				(current_value
																					1
																				)
																			)
																		)
																	react_session (null)
																	react_session_training_index (null)
																	session_index (if
																			single_session
																			0
																			(current_value
																				1
																			)
																		)
																)

																;get the corresponding parameters by the index, values will be null if not specified
																;context and action values when not provided should be an empty list
																(declare
																	(assoc
																		react_context_values (if
																				context_values
																				(get
																					context_values
																					context_index
																				)
																				(list)
																			)
																		react_action_values (if
																				action_values
																				(get
																					action_values
																					action_index
																				)
																				(list)
																			)
																	)
																)

																;if one of these is provided, both of them must be
																(if
																	case_indices
																	(assign
																		(assoc
																			react_case_index (get
																					case_indices
																					session_index
																				)
																		)
																	)
																)
																(call
																	React
																	(assoc
																		pre_generated_uniques_map pre_generated_uniques_map
																		use_regional_model_residuals use_regional_model_residuals
																		details details
																		ignore_case ignore_case
																		weight_feature weight_feature
																		context_values react_context_values
																		allow_nulls allow_nulls
																		leave_case_out leave_case_out
																		extra_audit_features extra_audit_features
																		case_access_count_label case_access_count_label
																		action_values react_action_values
																		input_is_substituted input_is_substituted
																		derived_action_features derived_action_features
																		derived_context_features derived_context_features
																		use_case_weights use_case_weights
																		generate_new_cases generate_new_cases
																		into_series_store into_series_store
																		rand_seed react_rand_seed
																		substitute_output substitute_output
																		preserve_feature_values preserve_feature_values
																		action_features action_features
																		desired_conviction desired_conviction
																		feature_bounds_map feature_bounds_map
																		context_features context_features
																		case_indices react_case_index
																		ordered_by_specified_features ordered_by_specified_features
																	)
																)
															)
														)
														(range
															0
															(-
																batch_size
																1
															)
														)
													)

													;else run the same but without the use multi-threading
													(map
														(call
															!ReactFunction
														)
														(range
															0
															(-
																batch_size
																1
															)
														)
													)
												)
											action_features (if
													(size
														derived_action_features
													)
													(append
														action_features
														derived_action_features
													)
													action_features
												)
										)
									)

									;wrapper method for #React that auto generated uniques if necessary for generative react flows
									; parameters:
									;	see comment block for #react in howso.amlg for details
									##SingleReact
									(seq

										;assoc of feature -> unique value, pre-populated if there are unique features that need to be synthed
										(declare
											(assoc
												pre_generated_uniques_map
													;if doing generative reacts with unique nominals, generate the uniques values prior to synthesis
													(if
														(and
															(!=
																(null)
																desired_conviction
															)
															(>
																(size
																	uniqueNominalsMap
																)
																0
															)

															;generating unique nominal actions
															(>
																(size
																	(intersect
																		(zip
																			action_features
																		)
																		uniqueNominalsMap
																	)
																)
																0
															)
														)
														(call
															GenerateUniquesListMap
															(assoc
																batch_size 1
																preserve_feature_values preserve_feature_values
																action_features action_features
																context_features context_features
															)
														)
													)
											)
										)
										(if
											(!= (null) into_series_store)
											(accum_to_entities
												(assoc
													revision 1
												)
											)
										)
										(declare
											(assoc
												react_response (call
														React
														(assoc
															pre_generated_uniques_map pre_generated_uniques_map
															use_regional_model_residuals use_regional_model_residuals
															details details
															ignore_case ignore_case
															weight_feature weight_feature
															context_values context_values
															allow_nulls allow_nulls
															leave_case_out leave_case_out
															extra_audit_features extra_audit_features
															case_access_count_label case_access_count_label
															action_values action_values
															input_is_substituted input_is_substituted
															derived_action_features derived_action_features
															derived_context_features derived_context_features
															use_case_weights use_case_weights
															generate_new_cases generate_new_cases
															into_series_store into_series_store
															rand_seed rand_seed
															substitute_output substitute_output
															preserve_feature_values preserve_feature_values
															action_features action_features
															desired_conviction desired_conviction
															feature_bounds_map feature_bounds_map
															context_features context_features
															case_indices case_indices
															ordered_by_specified_features ordered_by_specified_features
														)
													)
											)
										)

										;append action_features to response
										(if
											(!= (null) react_response)
											(accum
												(assoc
													react_response (assoc
															action_features (if
																	(size
																		derived_action_features
																	)
																	(append
																		action_features
																		derived_action_features
																	)
																	action_features
																)
														)
												)
											)
										)
										react_response
									)

									;React in series until a series_stop_map condition has been met, outputs an assoc of action_features and series.
									;
									;parameters:
									;	see comment block for #react_series in howso.amlg for details
									##ReactSeries
									(seq
										(declare
											(assoc
												original_context_map (append
														(zip
															derived_context_features
														)
														(zip
															derived_action_features
														)
														(if
															(size
																action_values
															)
															(zip
																action_features
																action_values
															)
															(zip
																action_features
															)
														)
														(zip
															context_features
															context_values
														)
														(if
															(size
																series_context_values
															)
															(zip
																series_context_features
																(first
																	series_context_values
																)
															)
															(assoc)
														)
													)
											)
										)
										(declare
											(assoc
												current_series_index 0
												react_output (null)
												react_context_features (list)
												initial_series_ids_map (null)
												use_initial_context_features (false)
												has_unique_features (false)
												replacement_id_values_map (assoc)
												new_series_id_feature_set (zip
														new_series_id_features
													)
												done (false)
												has_series_context_values (size
														series_context_values
													)
												features (indices
														original_context_map
													)
												current_case_map (null)
												all_context_features (append
														context_features
														derived_context_features
														series_context_features
													)
												series_data (list)
												user_specified_context_features (append
														context_features
														series_context_features
													)
												last_series_index -1
												initial_features_map (null)
											)
										)
										(assign
											(assoc
												max_series_length (if
														has_series_context_values
														(-
															(size
																series_context_values
															)
															1
														)
														(=
															(null)
															max_series_length
														)

														;default limit to series length generation to be 3 * model_size - 1 to account for 0-based indices
														(-
															(*
																3
																(call
																	GetNumTrainingCases
																)
															)
															1
														)

														;0 or a a negative value means no limit to series length
														(<=
															max_series_length
															0
														)
														.infinity

														;subtract 1 from the specified length so that it can be compared to the 0-based index of each series row
														(-
															max_series_length
															1
														)
													)
											)
										)

										;if there are custom series contexts provided but no stop map, create a dummy stop map to prevent it from
										;stopping after 1 case which is the default behavior when no stop map is provided
										(if
											(and
												has_series_context_values
												(=
													0
													(size
														series_stop_maps
													)
												)
											)
											(assign
												(assoc
													series_stop_map (assoc
															".none" (null)
														)
												)
											)
										)

										;if doing generative reacts with unique nominals, generate unique values prior to synthesis
										(if
											(and
												(!=
													(null)
													desired_conviction
												)
												(>
													(size
														uniqueNominalsMap
													)
													0
												)

												;generating unique nominal actions
												(>
													(size
														(intersect
															(zip
																action_features
															)
															uniqueNominalsMap
														)
													)
													0
												)
											)
											(assign
												(assoc
													has_unique_features (true)
												)
											)
										)

										;map of feature -> corresponding column index in series_data
										(declare
											(assoc
												feature_index_map (zip
														features
														(indices
															features
														)
													)
												original_context_values (unzip
														original_context_map
														features
													)
											)
										)

										;compose a map of all series id features that need to be output
										(map
											(lambda
												(if
													(get
														featureAttributes
														(list
															(current_value
																1
															)
															"id_feature"
														)
													)
													(accum
														(assoc
															replacement_id_values_map (associate
																	(current_value
																		2
																	)
																	(null)
																)
														)
													)
												)
											)
											action_features
										)
										(let
											(assoc
												context_map (zip
														user_specified_context_features
													)
											)

											;replacement map is made of those ids that should have new values assigned at completion or are not explicitly provided as contexts
											(assign
												(assoc
													replacement_id_values_map (filter
															(lambda
																(or
																	(contains_index
																		new_series_id_feature_set
																		(current_index)
																	)
																	(not
																		(contains_index
																			context_map
																			(current_index)
																		)
																	)
																)
															)
															replacement_id_values_map
														)
												)
											)
										)

										;if initial features are provided, ensure there aren't any that do not appear in features. any extra features are deleted and ignored.
										(if
											(size initial_features)
											(let
												(assoc
													invalid_initial_features (filter
															(lambda
																(not
																	(contains_index
																		feature_index_map
																		(current_value)
																	)
																)
															)
															initial_features
														)
												)

												;^^^(print "DEBUG: invalid initial features: " invalid_initial_features "\n")
												(assign
													(assoc
														initial_features_map (zip
																initial_features
																initial_values
															)
													)
												)
												(if
													(size
														invalid_initial_features
													)
													(assign
														(assoc
															initial_features_map (remove
																	initial_features_map
																	invalid_initial_features
																)
														)
													)
												)
											)
										)

										;^^^(print "DEBUG: orignal context map: " original_context_map "\n")
										;^^^(print "DEBUG: initial_features_map: " initial_features_map "\n")
										;loop until series stopping condition is met
										(while
											(not done)

											;if initial conditions were provided, use them as contexts for the first case
											(if
												(and
													(=
														-1
														last_series_index
													)
													(>
														(size
															initial_features_map
														)
														0
													)
												)
												(assign
													(assoc
														use_initial_context_features (true)
														initial_features_map (append
																(zip
																	context_features
																	context_values
																)
																(if
																	has_series_context_values
																	(zip
																		series_context_features
																		(first
																			series_context_values
																		)
																	)
																	(assoc)
																)
																initial_features_map
															)
													)
												)

												;else not initial row
												(assign
													(assoc
														use_initial_context_features (false)
													)
												)
											)

											;^^^(if use_initial_context_features (print "DEBUG: updated initial features map: " initial_features_map))
											;add each new row to series data with all initial context values
											(accum
												(assoc
													current_series_index 1
													series_data (if
															use_initial_context_features
															(list
																(unzip
																	(append
																		original_context_map
																		initial_features_map
																	)
																	features
																)
															)

															;overwrite the values in the original_context_map with those from the current series_index in the provided series_context_values
															has_series_context_values
															(list
																(unzip
																	(append
																		original_context_map
																		(zip
																			series_context_features
																			(get
																				series_context_values
																				current_series_index
																			)
																		)
																	)
																	features
																)
															)

															;else every row begins as the original context values
															(list
																original_context_values
															)
														)
													last_series_index 1
												)
											)
											(if
												(size derived_context_features)
												(if
													use_initial_context_features
													(call
														DeriveOrGenerateFeatures
														(assoc
															derived_features (filter
																	(lambda
																		(not
																			(contains_index
																				initial_features_map
																				(current_value)
																			)
																		)
																	)
																	derived_context_features
																)
															react_context_features (indices
																	initial_features_map
																)
														)
													)

													;else just provide context features and the full list of derived_context_features
													(call
														DeriveOrGenerateFeatures
														(assoc
															derived_features derived_context_features
															react_context_features user_specified_context_features
														)
													)
												)
											)

											;^^^(print "DEBUG: post derived context values row: " last_series_index " : " (zip features (last series_data)))
											;pregenerate unique values for non series id features
											(if
												has_unique_features

												;generate a map of non-series id unique features -> unique value
												(assign
													(assoc
														pre_generated_uniques_map (call
																GenerateUniquesListMap
																(assoc
																	batch_size 1
																	preserve_feature_values preserve_feature_values
																	action_features action_features
																	context_features all_context_features
																)
															)
													)
												)
											)
											(assign
												(assoc
													react_context_features (if
															use_initial_context_features
															(indices
																initial_features_map
															)
															all_context_features
														)
													current_case_map (zip
															features
															(last
																series_data
															)
														)
												)
											)
											(assign
												(assoc
													react_output (call
															React
															(assoc
																pre_generated_uniques_map pre_generated_uniques_map
																use_regional_model_residuals use_regional_model_residuals
																details (null)
																ignore_case ignore_case
																context_values (unzip
																		current_case_map
																		react_context_features
																	)
																weight_feature weight_feature
																leave_case_out leave_case_out
																extra_audit_features extra_audit_features
																case_access_count_label case_access_count_label
																action_values action_values
																input_is_substituted input_is_substituted
																derived_action_features (list)
																derived_context_features (list)
																generate_new_cases generate_new_cases
																use_case_weights use_case_weights
																rand_seed rand_seed
																substitute_output substitute_output
																preserve_feature_values preserve_feature_values
																action_features action_features
																desired_conviction desired_conviction
																feature_bounds_map feature_bounds_map
																context_features react_context_features
																case_indices case_indices
																ordered_by_specified_features ordered_by_specified_features
															)
														)
												)
											)

											;overwrite the values for the action features in the current case map now that they have values
											(accum
												(assoc
													current_case_map (zip
															action_features
															(get
																react_output
																"action_values"
															)
														)
												)
											)

											;^^^(print "DEBUG: post react, pre derived action: row " last_series_index " : " current_case_map)
											;overwrite the last row in series data with the values from the updated current case
											(assign
												"series_data"
												(list last_series_index)
												(unzip
													current_case_map
													features
												)
											)
											(if
												(size derived_action_features)
												(let
													(assoc
														derivation_failed (call
																DeriveOrGenerateFeatures
																(assoc
																	derived_features
																		;for initial case, may need to filter out derived action features whose values are already provided
																		(if
																			use_initial_context_features
																			(filter
																				(lambda
																					(not
																						(contains_index
																							initial_features_map
																							(current_value)
																						)
																					)
																				)
																				derived_action_features
																			)

																			;else use all derived_action_features
																			derived_action_features
																		)
																	react_context_features (indices
																			(append
																				(zip
																					react_context_features
																				)
																				(zip
																					action_features
																				)
																			)
																		)
																)
															)
													)

													;stop generating series if derivation_failed due to time feature being past max boundary;
													;remove current (last) row and stop
													(if
														derivation_failed
														(assign
															(assoc
																done (true)
																series_data (trunc
																		series_data
																	)
															)
														)
													)
												)
											)
											(assign
												(assoc
													current_case_map (zip
															features
															(last
																series_data
															)
														)
												)
											)

											;if this is the first row of the series, assign values for the replacement series ids here, now that the initial value is available
											(if
												(=
													0
													last_series_index
												)
												(assign
													(assoc
														replacement_id_values_map (map
																(lambda

																	;generate new unique value
																	(if
																		(contains_index
																			new_series_id_feature_set
																			(current_index)
																		)
																		(call
																			GenerateInt64String
																		)

																		;else grab the value from this first series row
																		(get
																			current_case_map
																			(current_index)
																		)
																	)
																)
																replacement_id_values_map
															)
													)
												)
											)

											;^^^(print "DEBUG: complete series row: " last_series_index " :  " current_case_map)
											;determine whether to stop generating the series
											;if there's no series_stop_map or exceeded max_series_length, be done
											(if
												(or
													(=
														0
														(size
															series_stop_map
														)
													)
													(>=
														last_series_index
														max_series_length
													)
												)
												(assign
													(assoc
														done (true)
													)
												)
												(map
													(lambda
														(seq
															(if
																(contains_index
																	(current_value)
																	"values"
																)
																(if
																	(contains_value
																		(get
																			(current_value)
																			"values"
																		)
																		(get
																			current_case_map
																			(current_index)
																		)
																	)
																	(assign
																		(assoc
																			done (true)
																		)
																	)
																)
															)
															(if
																(contains_index
																	(current_value)
																	"min"
																)
																(if
																	(>=
																		(get
																			(current_value)
																			"min"
																		)
																		(get
																			current_case_map
																			(current_index)
																		)
																	)
																	(assign
																		(assoc
																			done (true)
																		)
																	)
																)
															)
															(if
																(contains_index
																	(current_value)
																	"max"
																)
																(if
																	(<=
																		(get
																			(current_value)
																			"max"
																		)
																		(get
																			current_case_map
																			(current_index)
																		)
																	)
																	(assign
																		(assoc
																			done (true)
																		)
																	)
																)
															)
														)
													)
													series_stop_map
												)
											)
										)

										;while loop
										;grab the list of column indices corresponding to all the combined action features
										(declare
											(assoc
												action_feature_indices (unzip
														feature_index_map
														(append
															action_features
															derived_action_features
														)
													)
											)
										)

										;if need to update/replace id values, for each id, update all the rows and set updated value for each id feature
										(if
											(size replacement_id_values_map)
											(map
												(lambda
													(let
														(assoc
															id_value (current_value
																	1
																)
															id_index (get
																	feature_index_map
																	(current_index
																		1
																	)
																)
														)
														(map
															(lambda
																(assign
																	"series_data"
																	(list
																		(current_index
																			1
																		)
																		id_index
																	)
																	id_value
																)
															)
															(indices
																series_data
															)
														)
													)
												)
												replacement_id_values_map
											)
										)

										;output the series data
										(assoc
											series
												;iterate over all the series data and return only the columns corresponding to action_features
												(map
													(lambda
														(unzip
															(current_value)
															action_feature_indices
														)
													)
													series_data
												)
										)
									)

									;Wrapper method for ReactDiscriminative and GenerateCase
									;note: this method may overwmrite desired_conviction if it's specified along with generate_new_cases=true and the case isn't generated in one attempt
									;parameters:
									;  see comment block for #react in howso.amlg for details
									;
									;  for generative flows only, new parameter:
									;  pre_generated_uniques_map: optional, map of feature -> value for all unique features whose output value has been pre-generated for output
									##React
									(declare
										(assoc
											pre_generated_uniques_map (null)
											use_regional_model_residuals (true)
											weight_feature ".case_weight"
											context_values (list)
											allow_nulls (false)
											leave_case_out (false)
											extra_audit_features (list)
											case_access_count_label ""
											action_values (list)
											input_is_substituted (false)
											derived_action_features (list)
											derived_context_features (list)
											use_case_weights (false)
											rand_seed (null)
											substitute_output (true)
											preserve_feature_values (list)
											action_features (list)
											feature_bounds_map (assoc)
											case_indices (null)
											context_features (list)
										)
										(if
											(!= (null) rand_seed)
											(set_rand_seed rand_seed)
										)

										;unsubstitute nominal feature values if necessary
										(if
											(and input_is_substituted hasSubstituteFeatureValues)
											(assign
												(assoc
													action_values
														;most discriminative reacts will have action_features but no action_values, skip this step if no action_values are provided
														(if
															(>
																(size
																	action_values
																)
																0
															)
															(call
																UnsubstituteFeatureValues
																(assoc
																	feature_values action_values
																	features action_features
																)
															)
															action_values
														)
													context_values (call
															UnsubstituteFeatureValues
															(assoc
																feature_values context_values
																features context_features
															)
														)
												)
											)
										)

										;derive context features prior to react and append the computed values to context values
										(if
											(size derived_context_features)
											(assign
												(assoc
													context_values (append
															context_values
															(call
																ComputeFeatureValuesFromCode
																(assoc
																	feature_values_map (zip
																			context_features
																			context_values
																		)
																	derived_features derived_context_features
																)
															)
														)
													context_features (append
															context_features
															derived_context_features
														)
												)
											)
										)

										;generative react
										(if
											(!= desired_conviction (null))
											(let
												(assoc
													generated_case (null)
													original_action_features (null)
													total_attempts (if
															(=
																"attempt"
																generate_new_cases
															)
															6
															5
														)
												)
												(if
													(=
														0
														(size
															action_features
														)
													)
													(assign
														(assoc
															action_features (retrieve_from_entity
																	trainee
																	"defaultFeatures"
																)
														)
													)
												)

												;don't generate any features in the pre_generated_uniques_map by filtering them out of the action_features list
												(if
													(>
														(size
															pre_generated_uniques_map
														)
														0
													)
													(seq
														(assign
															(assoc
																original_action_features action_features
															)
														)

														;remove the generated unique features from the action_features and restore them below after case is generated
														(assign
															(assoc
																action_features (filter
																		(lambda
																			(not
																				(contains_index
																					pre_generated_uniques_map
																					(current_value)
																				)
																			)
																		)
																		action_features
																	)
															)
														)
													)
												)
												(assign
													(assoc
														generated_case (call
																GenerateCase
																(assoc
																	generate_novel_case (if
																			(or
																				(=
																					generate_new_cases
																					(null)
																				)
																				(=
																					generate_new_cases
																					"no"
																				)
																			)
																			(false)
																			(true)
																		)
																	use_regional_model_residuals use_regional_model_residuals
																	leave_case_out leave_case_out
																	context_values context_values
																	weight_feature weight_feature
																	use_case_weights use_case_weights
																	substitute_output substitute_output
																	preserve_feature_values preserve_feature_values
																	original_substitute_output substitute_output
																	action_features action_features
																	desired_conviction desired_conviction
																	feature_bounds_map feature_bounds_map
																	context_features context_features
																	case_indices case_indices
																	ordered_by_specified_features ordered_by_specified_features
																)
															)
													)
												)

												;retry up to total_attempt times if case is generated as all nulls
												(if
													(and
														generate_new_cases
														(=
															(null)
															generated_case
														)
													)
													(let
														(assoc
															attempts 0
														)
														(while
															(<
																attempts
																total_attempts
															)

															;decrease desired_conviction by a factor of (1 - e^-1)
															(assign
																(assoc
																	desired_conviction (*
																			0.632120558
																			desired_conviction
																		)
																)
															)
															(assign
																(assoc
																	generated_case (call
																			GenerateCase
																			(assoc
																				generate_novel_case (if
																						(and
																							(or
																								(=
																									generate_new_cases
																									"always"
																								)
																								(=
																									generate_new_cases
																									"attempt"
																								)
																							)
																							(<
																								attempts
																								5
																							)
																						)
																						(true)
																						(false)
																					)
																				use_regional_model_residuals use_regional_model_residuals
																				leave_case_out leave_case_out
																				context_values context_values
																				weight_feature weight_feature
																				use_case_weights use_case_weights
																				substitute_output substitute_output
																				preserve_feature_values preserve_feature_values
																				original_substitute_output substitute_output
																				action_features action_features
																				desired_conviction desired_conviction
																				feature_bounds_map feature_bounds_map
																				context_features context_features
																				case_indices case_indices
																				ordered_by_specified_features ordered_by_specified_features
																			)
																		)
																)
															)

															;try again if failed to generate
															(if
																(=
																	(null)
																	generated_case
																)
																(accum
																	(assoc
																		attempts 1
																	)
																)

																;else stop
																(assign
																	(assoc
																		attempts total_attempts
																	)
																)
															)
														)
													)
												)

												;if there are pre-generated unique values that should be in the output, append them to the generated case and then
												;unzip by the original_action_features to preserve the original feature ordering
												(if
													(and
														(>
															(size
																pre_generated_uniques_map
															)
															0
														)

														;only append if the case was generated or if there were no features that needed to be generated
														(or
															(=
																0
																(size
																	action_features
																)
															)
															(!=
																(null)
																generated_case
															)
														)
													)
													(assign
														(assoc
															generated_case (unzip
																	(append
																		(zip
																			action_features
																			generated_case
																		)
																		pre_generated_uniques_map
																	)
																	original_action_features
																)
															action_features original_action_features
														)
													)
												)

												;output generated case with explanation of the case if needed
												(if
													(!=
														details
														(null)
													)
													(seq

														;if user doesn't want to use case weights, change weight_feature to '.none'
														(if
															(not
																use_case_weights
															)
															(assign
																(assoc
																	weight_feature ".none"
																)
															)
														)
														(if
															hasFeaturesNeedEncodingFromInput
															(assign
																(assoc
																	action_values (call
																			ConvertFromInput
																			(assoc
																				feature_values generated_case
																				features action_features
																			)
																		)
																	context_values (call
																			ConvertFromInput
																			(assoc
																				feature_values context_values
																				features context_features
																			)
																		)
																)
															)

															;else dataset has no nominal values, just set action_values to be same as the generated ones
															(assign
																(assoc
																	action_values generated_case
																)
															)
														)
														(declare
															(assoc
																hyperparam_map (call
																		GetHyperparameters
																		(assoc
																			weight_feature weight_feature
																			feature ".targetless"
																			mode "robust"
																		)
																	)
															)
														)
														(assign
															(assoc
																generated_case (call
																		RetrieveAuditData
																		(assoc
																			context_values context_values
																			details details
																			ignore_case (null)
																			force_targetless (true)
																			extra_audit_features extra_audit_features
																			action_values action_values
																			action_features action_features
																			hyperparam_map hyperparam_map
																			context_features context_features
																			num_features_returned num_features_returned
																		)
																	)
															)
														)
													)

													;else put the generated case action values into the same format as an explanation object
													(assign
														(assoc
															generated_case (assoc
																	action_values generated_case
																)
														)
													)
												)

												;derive action features after react
												(if
													(size
														derived_action_features
													)

													;append the derived action values to the end of the predicted action_values
													(accum
														"generated_case"
														(list
															"action_values"
														)
														(call
															ComputeFeatureValuesFromCode
															(assoc
																feature_values_map
																	;append generated actions to contexts, clobbering the contexts to prevent duplicates
																	(append
																		(zip
																			context_features
																			context_values
																		)
																		(zip
																			action_features
																			(get
																				generated_case
																				"action_values"
																			)
																		)
																	)
																derived_features derived_action_features
															)
														)
													)
												)
												(if
													(=
														(null)
														into_series_store
													)

													;return generated case
													generated_case

													;else reacts should be stored into a series, store it by into_series_store
													(call
														AppendCaseToSeriesStoreWithoutEncoding
														(assoc
															react_case generated_case
															context_values
																;context values were already encoded during the details flow, but need to be encoded if no details were specified
																(if
																	(!=
																		details
																		(null)
																	)
																	context_values

																	;else need to encode here so the input is consistent
																	(if
																		hasFeaturesNeedEncodingFromInput
																		(call
																			ConvertFromInput
																			(assoc
																				feature_values context_values
																				features context_features
																			)
																		)
																		context_values
																	)
																)
															series into_series_store
															action_features action_features
															context_features context_features
														)
													)
												)
											)

											;else run discriminative react
											(let
												(assoc
													output_case (call
															ReactDiscriminative
															(assoc
																extra_audit_features extra_audit_features
																leave_case_out leave_case_out
																weight_feature weight_feature
																details details
																ignore_case ignore_case
																context_values context_values
																allow_nulls allow_nulls
																case_access_count_label case_access_count_label
																action_values action_values
																use_case_weights use_case_weights
																preserve_feature_values preserve_feature_values
																action_features action_features
																case_indices case_indices
																context_features context_features
															)
														)
												)
												(if
													(size
														derived_action_features
													)

													;append the derived action values to the end of the predicted action_values
													(accum
														"output_case"
														(list
															"action_values"
														)
														(call
															ComputeFeatureValuesFromCode
															(assoc
																feature_values_map
																	;append reacted actions to contexts, clobbering the contexts to prevent duplicates
																	(append
																		(zip
																			context_features
																			context_values
																		)
																		(zip
																			action_features
																			(get
																				output_case
																				"action_values"
																			)
																		)
																	)
																derived_features derived_action_features
															)
														)
													)
												)
												(if
													(=
														(null)
														into_series_store
													)

													;return output case
													output_case

													;else store into series and then return output
													(call
														AppendCaseToSeriesStoreWithoutEncoding
														(assoc
															react_case output_case
															context_values
																;may need to encode here so the input is consistent
																(if
																	hasFeaturesNeedEncodingFromInput
																	(call
																		ConvertFromInput
																		(assoc
																			feature_values context_values
																			features context_features
																		)
																	)
																	context_values
																)
															series into_series_store
															action_features action_features
															context_features context_features
														)
													)
												)
											)
										)
									)

									;reacts to the context specified: computes the next action from replays given the current context
									; context_features: list of context features
									; context_values: current values of the world state
									; action_values: values of action features. If specified will bypass react and only do the explanation if details is set
									; action_features: list of action features for action inputs
									; case_access_count_label: if specified (not empty), will accumulate the number of times each context has been accessed
									; details: if set to an assoc with corresponding flags set, then it will modify the return type and return the requested audit info
									;					 if set to a number (1 - 4) will return corresponding bundle of flags for backwards compatibility
									; num_features_returned: if return audit data, will return up to this many specified features in the explanation
									; skip_encoding: if set to true, will forcibly skip encoding and react to passed in values
									; skip_decoding: if set to true, will forcibly skip decoding and return raw values from the react
									; extra_audit_features: list of additional features to return with audit data
									; match_on_context_features : flag, if true will query only for cases whose context features are not null
									; ignore_case: optional case_id, if set will query for K+1 cases and ignore the perfect matching case during the reaction
									; focal_case: optional case id of case which to ignore along with ignore_case.  Used specifically in prediction_conviction flow to compute
									;			 residuals for a specific existing case, see usage comments in ComputeCasePredictionConviction method for details.
									; tie_break_random_seed: the random number seed to use to break ties for equal distances.  defaults to a constant value
									; allow_nulls : flag, if set to true will allow return of null values if there are nulls in the local model for the action features
									;
									; case_indices: optional pair (list) of session id and index, where index is the original 0-based session_training_index of the case as it was
									;			trained into the session. If this case does not exist, outputs null.
									; preserve_feature_values : optional, list of features that will preserve their values from the case specified by case_indices, appending and
									;			overwriting the specified context and context features as necessary.
									; leave_case_out: flag, if set to true and specified along with case_indices, will set ignore_case to the one specified by case_indices
									;
									; return_action_values_only: if set to true and details is not specified, output will be just the raw list of action values
									; force_targetless: flag, if set to true forces use of targetless hyperparameters if available
									; hyperparam_map: optional assoc of hyperparameters to use (instead of system-determined ones)
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; has_dependent_features: flag, defaults to hasDependentFeatures, when false forces react with no dependencies
									;
									;returns:
									; if details is not specified returns the react object { 'action_values': [values of the actions matching action_features] }
									; otherwise additionally returns the appropriate requested audit data in the react object as well
									##ReactDiscriminative
									(declare
										(assoc
											focal_case (null)
											valid_weight_feature (false)
											extra_audit_features (list)
											weight_feature ".case_weight"
											tie_break_random_seed "fixed rand seed"
											ignore_case (null)
											details (null)
											return_action_values_only (false)
											skip_decoding (not hasEncodedFeatures)
											context_values (list)
											force_targetless (false)
											allow_nulls (false)
											leave_case_out (false)
											has_dependent_features hasDependentFeatures
											case_access_count_label ""
											action_values (list)
											use_case_weights (false)
											preserve_feature_values (list)
											action_features (list)
											match_on_context_features (false)
											hyperparam_map (null)
											skip_encoding (not hasEncodedFeatures)
											context_features (list)
											case_indices (null)
											num_features_returned (null)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)

											;else using case weights, weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
											(assign
												(assoc
													valid_weight_feature (or
															hasPopulatedCaseWeight
															(!=
																weight_feature
																".case_weight"
															)
														)
												)
											)
										)

										;determine the case to ignore based on specified case_indices and use that cases's values by preserve_feature_values
										(if
											(and
												(=
													(null)
													ignore_case
												)
												(!=
													(null)
													case_indices
												)
											)
											(seq
												(assign
													(assoc
														ignore_case (call
																GetCaseId
																(assoc
																	session (first
																			case_indices
																		)
																	session_training_index (last
																			case_indices
																		)
																)
															)
													)
												)

												;return (null) if a session case was specified but not found
												(if
													(=
														(null)
														ignore_case
													)
													(conclude
														(assoc
															action_values (null)
														)
													)
												)

												;set/overwrite all the feature values directly from the specified case if necessary
												(if
													(size
														preserve_feature_values
													)
													(let
														(assoc
															preserved_values_map (zip
																	preserve_feature_values
																	(retrieve_from_entity
																		ignore_case
																		preserve_feature_values
																	)
																)
															context_values_map (zip
																	context_features
																	context_values
																)
														)
														(if
															(and
																hasEncodedFeatures
																(not
																	skip_encoding
																)
															)
															(assign
																(assoc
																	preserved_values_map (zip
																			preserve_feature_values
																			(call
																				ConvertToOutput
																				(assoc
																					feature_values (unzip
																							preserved_values_map
																							preserve_feature_values
																						)
																					has_rounded_features (false)
																					features preserve_feature_values
																					substitute_output (false)
																				)
																			)
																		)
																)
															)
														)
														(declare
															(assoc
																preserved_action_features (indices
																		(intersect
																			preserved_values_map
																			(zip
																				action_features
																			)
																		)
																	)
															)
														)
														(if
															(size
																preserved_action_features
															)
															(assign
																(assoc
																	action_values (unzip
																			preserved_values_map
																			preserved_action_features
																		)
																	preserved_values_map (remove
																			preserved_values_map
																			preserved_action_features
																		)
																)
															)
														)
														(if
															(size
																context_values_map
															)
															(accum
																(assoc
																	context_values_map preserved_values_map
																)
															)
															(assign
																(assoc
																	context_values_map preserved_values_map
																)
															)
														)
														(assign
															(assoc
																context_values (values
																		context_values_map
																	)
																context_features (indices
																		context_values_map
																	)
															)
														)
													)
												)

												;if it should not be left out, treat it like it wasn't specified
												(if
													(not
														leave_case_out
													)
													(assign
														(assoc
															ignore_case (null)
														)
													)
												)
											)
										)

										;return (null) context inputs don't match in length
										(if
											(!=
												(size context_features)
												(size context_values)
											)
											(conclude
												(assoc
													action_values (null)
												)
											)
										)

										;output list of reaction values
										(declare
											(assoc react_action_values action_values)
										)

										;don't encode values if they don't need encoding
										(if
											(and
												hasFeaturesNeedEncodingFromInput
												(not skip_encoding)
											)
											(seq
												(assign
													(assoc
														context_values (call
																ConvertFromInput
																(assoc
																	feature_values context_values
																	features context_features
																)
															)
													)
												)

												;if action values were specified, encode those into reaction values to be used in explanation
												(if
													(>
														(size
															action_values
														)
														0
													)
													(assign
														(assoc
															react_action_values (call
																	ConvertFromInput
																	(assoc
																		feature_values action_values
																		features action_features
																	)
																)
														)
													)
												)
											)
										)
										(if
											(= (null) hyperparam_map)
											(assign
												(assoc
													hyperparam_map (call
															GetHyperparameters
															(assoc
																weight_feature weight_feature
																feature (first
																		action_features
																	)
																mode (if
																		(or
																			force_targetless
																			(>
																				(size
																					action_features
																				)
																				1
																			)
																		)
																		"robust"
																		"full"
																	)
															)
														)
												)
											)
										)
										(declare
											(assoc
												action_feature_is_dependent (false)
												dependent_features_map (if
														has_dependent_features
														(retrieve_from_entity
															"dependentFeatureMap"
														)
													)
											)
										)

										;make a combined features list
										(declare
											(assoc
												output_categorical_action_probabilities (or
														(get
															details
															"categorical_action_probabilities"
														)
														(get
															details
															"case_contributions"
														)
														(get
															details
															"feature_contributions"
														)
														(get
															details
															"case_mda"
														)
													)
												influence_weights_map (assoc)
												output_influence_weights (or
														(and
															(=
																(assoc)
																(get_type
																	details
																)
															)
															(get
																details
																"influential_cases"
															)
														)
														(and
															(=
																(assoc)
																(get_type
																	details
																)
															)
															(get
																details
																"boundary_cases"
															)
														)
													)
												filtering_queries (list)
												features (append
														action_features
														context_features
													)
												categorical_action_probabilities_map (assoc)
												cached_candidate_cases_map (null)
											)
										)

										;if there are dependent context features, and the action is dependent, precompute all residuals for dependent continuous features
										(if
											dependent_features_map
											(if
												(contains_index
													dependent_features_map
													(first
														action_features
													)
												)
												(seq
													(call
														ComputeAndCacheMinMaxForDependentContinuousContexts
														(assoc
															use_regional_model_residuals use_regional_model_residuals
															context_values context_values
															hyperparam_map hyperparam_map
															context_features context_features
														)
													)
													(assign
														(assoc
															action_feature_is_dependent (true)
														)
													)
												)
											)
										)

										;if reaction_action_values is already set (user provided or from existing case), bypass the GenerateReaction flow, otherwise run it as normal
										(if
											(>
												(size react_action_values)
												0
											)

											;we don't need not_null nor dependent_queries since this is for explanations only
											(call
												PopulateFilteringQueriesForExplanation
												(assoc
													dependent_queries_list (list)
													not_null_features_queries (list)
													ignore_null_action_feature (=
															(false)
															allow_nulls
														)
												)
											)

											;else do the GenerateReaction flow here. If only one action feature, just react to that one feature
											(=
												1
												(size action_features)
											)

											;interpolate continuous actions to get values between training cases
											(let
												(assoc
													action_value (call
															GenerateReaction
															(assoc
																allow_nulls allow_nulls
															)
														)
												)
												(if
													(and
														(=
															(null)
															action_value
														)
														(not
															allow_nulls
														)
													)

													;expand neighbor search to acquire a non-null reaction if possible
													(assign
														(assoc
															action_value (call
																	GenerateReaction
																	(assoc
																		allow_nulls (false)
																		ignore_null_action_feature (true)
																	)
																)
														)
													)
												)

												;convert into a list of action values for output
												(assign
													(assoc
														react_action_values (list
																action_value
															)
													)
												)
											)

											;else no action features, ensure correct case is ignored if applicable (eg, explaining an existing case)
											(=
												0
												(size action_features)
											)
											(call
												PopulateFilteringQueriesForExplanation
												(assoc
													dependent_queries_list (list)
													not_null_features_queries (list)
													ignore_null_action_feature (false)
												)
											)

											;else there are multiple action features, react to them one at a time
											(let
												(assoc
													context_features_param context_features
													i 0
													context_values_param context_values
													action_value ""
													action_feature ""
													ordered_action_features action_features
												)

												;iterate over the action features in order using a while loop to guarantee order of processing
												(while
													(<
														i
														(size
															ordered_action_features
														)
													)
													(if
														(>
															i
															0
														)
														(seq

															;get the hyperparameter map for the next action feature
															(assign
																(assoc
																	hyperparam_map (call
																			GetHyperparameters
																			(assoc
																				weight_feature weight_feature
																				feature (get
																						ordered_action_features
																						i
																					)
																				mode (if
																						(or
																							force_targetless
																							(!=
																								i
																								(-
																									(size
																										action_features
																									)
																									1
																								)
																							)
																						)
																						"robust"
																						"full"
																					)
																			)
																		)
																)
															)
															(assign
																(assoc
																	context_features_param (append
																			context_features_param
																			action_feature
																		)
																	context_values_param (append
																			context_values_param
																			action_value
																		)
																)
															)

															;if there are dependent context features, and this action is dependent, precompute all residuals for dependent continuous features
															(if
																dependent_features_map
																(if
																	(contains_index
																		dependent_features_map
																		(get
																			ordered_action_features
																			i
																		)
																	)
																	(seq
																		(call
																			ComputeAndCacheMinMaxForDependentContinuousContexts
																			(assoc
																				use_regional_model_residuals use_regional_model_residuals
																				context_values context_values_param
																				hyperparam_map hyperparam_map
																				context_features context_features_param
																			)
																		)
																		(assign
																			(assoc
																				action_feature_is_dependent (true)
																			)
																		)
																	)

																	;else action feature is not dependent
																	(assign
																		(assoc
																			action_feature_is_dependent (false)
																		)
																	)
																)
															)
														)
													)
													(assign
														(assoc
															action_value (call
																	GenerateReaction
																	(assoc
																		allow_nulls allow_nulls
																		context_values context_values_param
																		action_features (list
																				(get
																					ordered_action_features
																					i
																				)
																			)
																		context_features context_features_param
																	)
																)
															action_feature (get
																	ordered_action_features
																	i
																)
														)
													)
													(if
														(and
															(=
																(null)
																action_value
															)
															(not
																allow_nulls
															)
														)

														;expand neighbor search to acquire a non-null reaction if possible
														(assign
															(assoc
																action_value (call
																		GenerateReaction
																		(assoc
																			context_values context_values_param
																			allow_nulls (false)
																			ignore_null_action_feature (true)
																			action_features (list
																					action_feature
																				)
																			context_features context_features_param
																		)
																	)
															)
														)
													)

													;null values by themselves aren't appended to the list, must append nulls in a list
													(accum
														(assoc
															react_action_values (if
																	(=
																		(null)
																		action_value
																	)
																	(list
																		(null)
																	)
																	action_value
																)
														)
													)
													(accum
														(assoc
															i 1
														)
													)
												)
											)
										)

										;return based on whether audit data was requested
										(if
											(!= details (null))
											(call
												RetrieveAuditData
												(assoc
													context_values context_values
													details details
													ignore_case ignore_case
													force_targetless force_targetless
													extra_audit_features extra_audit_features
													action_values react_action_values
													action_features action_features
													hyperparam_map hyperparam_map
													context_features context_features
													num_features_returned num_features_returned
												)
											)

											;output only the action values
											return_action_values_only
											(if
												(and
													hasEncodedFeatures
													(not
														skip_decoding
													)
												)

												;decode nominal features if necessary
												(call
													ConvertToOutput
													(assoc
														feature_values react_action_values
														features action_features
													)
												)
												hasRoundedFeatures
												(call
													RoundContinuousFeatures
													(assoc
														feature_values react_action_values
														features action_features
													)
												)

												;else just return the values
												react_action_values
											)

											;else output action values as part of the react object
											(assoc
												action_values (if
														(and
															hasEncodedFeatures
															(not
																skip_decoding
															)
														)

														;decode nominal features if necessary
														(call
															ConvertToOutput
															(assoc
																feature_values react_action_values
																features action_features
															)
														)
														hasRoundedFeatures
														(call
															RoundContinuousFeatures
															(assoc
																feature_values react_action_values
																features action_features
															)
														)

														;else just return the values
														react_action_values
													)
											)
										)
									)

									;Selects or interpolates a set of reaction cases
									;parameters:
									; neighbor_weights_map : map of neighbor case ids and their respective weights
									; action_feature: the action feature
									; allow_nulls : flag, if set to true will allow interpolate to return null values if there are nulls in the local model for the action features
									; has_perfect_matches: flag, if set to true, there are 0-distance neighbors, will filter out non-0-distance neighbors from neighbor_weights_map
									##InterpolateActionValues
									(declare
										(assoc
											allow_nulls (false)
											neighbor_weights_map (assoc)
											action_feature (null)
											has_perfect_matches (false)
										)

										;any weights larger than 1e15 are basically infinite (distance is 0), use 1e15 to account for floating point issues
										;such that values like 4.000000000000001 are treated same as 4
										(declare
											(assoc
												neighbor_ids_of_zero_dist_values (if
														has_perfect_matches
														(filter
															(lambda
																(>=
																	(get
																		neighbor_weights_map
																		(current_value)
																	)
																	1000000000000000
																)
															)
															(indices
																neighbor_weights_map
															)
														)

														;else
														(null)
													)
											)
										)

										;get the action values for each index in the neighbor_weights_map
										(declare
											(assoc
												neighbor_id_to_values_map (if
														allow_nulls
														(map
															(lambda
																(retrieve_from_entity
																	(current_index)
																	action_feature
																)
															)
															(if
																has_perfect_matches
																(zip
																	neighbor_ids_of_zero_dist_values
																)
																neighbor_weights_map
															)
														)

														;filter out all id->null elements from this assoc, remaining assoc is case id -> case value where all values are not null
														(filter
															(map
																(lambda
																	(retrieve_from_entity
																		(current_index)
																		action_feature
																	)
																)
																(if
																	has_perfect_matches
																	(zip
																		neighbor_ids_of_zero_dist_values
																	)
																	neighbor_weights_map
																)
															)
														)
													)
											)
										)
										(if
											(=
												0
												(size neighbor_id_to_values_map)
											)

											;if there are some non-perfect matches, just run the normal nearest neighbors flow on those
											(if
												(and
													has_perfect_matches
													(<
														(size
															neighbor_ids_of_zero_dist_values
														)
														(size
															neighbor_weights_map
														)
													)
												)
												(let
													(assoc
														not_null_value_cases_map (filter
																(lambda
																	(not
																		(contains_index
																			neighbor_id_to_values_map
																			(current_index)
																		)
																	)
																)
																neighbor_weights_map
															)
													)

													;execute the regular flow for the remaining non-perfect match cases
													(call
														InterpolateActionValues
														(assoc
															allow_nulls allow_nulls
															neighbor_weights_map not_null_value_cases_map
															action_feature action_feature
															has_perfect_matches (false)
														)
													)
												)

												;else return null because that means all the neighbors have nulls
												(null)
											)

											;else interpolate
											(declare
												(assoc
													neighbor_ids (indices
															neighbor_id_to_values_map
														)
													has_nulls (if
															allow_nulls

															;will be set to true if there are any null values among the neighbors
															(contains_value
																neighbor_id_to_values_map
																(null)
															)

															;else is false because all nulls should already have been filtered out if not allowing nulls
															(false)
														)
													is_continuous_feature (not
															(contains_index
																categoricalFeaturesSet
																action_feature
															)
														)
												)
												(declare
													(assoc
														neighbor_weights (if
																has_perfect_matches
																(if
																	valid_weight_feature

																	;pull corresponding weights from each case, numerified so a null becomes 0
																	(map
																		(lambda
																			(+
																				(retrieve_from_entity
																					(current_value)
																					weight_feature
																				)
																			)
																		)
																		neighbor_ids
																	)

																	;else set all weights to be same value of 1 for perfect matches
																	(map
																		(lambda
																			1
																		)
																		neighbor_ids
																	)
																)

																;else get actual corresponding weights for each neighbor case
																(unzip
																	neighbor_weights_map
																	neighbor_ids
																)
															)
														neighbor_values (unzip
																neighbor_id_to_values_map
																neighbor_ids
															)
													)
												)

												;sum up the weight of all the cases that have feature values
												(declare
													(assoc
														total_weight (apply
																"+"
																neighbor_weights
															)
													)
												)

												;if a continuous feature has nulls, check to see if the nulls are >= 50% of the weight, if so just return null
												;otherwise filter out the nulls and interpolate without them
												(if
													(and
														has_nulls
														is_continuous_feature
													)
													(let
														(assoc
															filled_indices
																; filter out all the null values leaving only indices of filled valued
																(filter
																	(lambda
																		(!=
																			(null)
																			(get
																				neighbor_values
																				(current_value)
																			)
																		)
																	)
																	(indices
																		neighbor_values
																	)
																)
															nulls_weight
																; sum up all the weight of all the null values
																(apply
																	"+"
																	(filter
																		(lambda
																			(=
																				(null)
																				(get
																					neighbor_values
																					(current_index)
																				)
																			)
																		)
																		neighbor_weights
																	)
																)
														)

														;filter out the nulls to interpolate since the weight of the nulls is less then 50% of total weight
														(if
															(<
																(/
																	nulls_weight
																	total_weight
																)
																0.5
															)
															(assign
																(assoc
																	neighbor_weights (unzip
																			neighbor_weights
																			filled_indices
																		)
																	has_nulls (false)
																	neighbor_values (unzip
																			neighbor_values
																			filled_indices
																		)
																	total_weight (-
																			total_weight
																			nulls_weight
																		)
																)
															)
														)
													)
												)
												(if
													is_continuous_feature
													(if

														;if nulls were < 50% of the weight, they would have been filtered out and this flag cleared, so must be null
														has_nulls
														(null)

														;else handle cyclic features
														(contains_index
															cyclicFeaturesMap
															action_feature
														)
														(let
															(assoc
																cycle_length (get
																		cyclicFeaturesMap
																		action_feature
																	)
																sum 0
															)
															(declare
																(assoc
																	half_cycle_value (/
																			cycle_length
																			2
																		)
																)
															)

															;if outputting influence weights, store them into scaled_neighbor_weights and accumulate
															(if
																output_influence_weights
																(declare
																	(assoc
																		scaled_neighbor_weights (map
																				(lambda
																					(let
																						(assoc
																							value (current_value
																									1
																								)
																						)

																						;if sum += (value + length) * weight
																						;else: value >= midpoint: sum += value * weight
																						(if
																							(<
																								value
																								half_cycle_value
																							)
																							(accum
																								(assoc
																									value cycle_length
																								)
																							)
																						)

																						;increase the sum by the weighted value
																						(accum
																							(assoc
																								sum (/
																										(*
																											value
																											(get
																												neighbor_weights
																												(current_index
																													1
																												)
																											)
																										)
																										total_weight
																									)
																							)
																						)

																						;output the scaled weight for this neighbor
																						(/
																							(get
																								neighbor_weights
																								(current_index)
																							)
																							total_weight
																						)
																					)
																				)
																				neighbor_values
																			)
																	)
																	(call
																		AccumulateInfluenceWeights
																		(assoc
																			weights scaled_neighbor_weights
																			case_ids neighbor_ids
																		)
																	)
																)

																;else just calculate the sum of all the cyclic weights
																(map
																	(lambda
																		(let
																			(assoc
																				value (current_value
																						1
																					)
																			)

																			;if sum += (value + length) * weight
																			;else: value >= midpoint: sum += value * weight
																			(if
																				(<
																					value
																					half_cycle_value
																				)
																				(accum
																					(assoc
																						value cycle_length
																					)
																				)
																			)

																			;increase the sum by the weighted value
																			(accum
																				(assoc
																					sum (/
																							(*
																								value
																								(get
																									neighbor_weights
																									(current_index
																										1
																									)
																								)
																							)
																							total_weight
																						)
																				)
																			)
																		)
																	)
																	neighbor_values
																)
															)

															;if sum has gone past the max value, decrease by the length of cycle, i.e., 370 degrees becomes 10
															(if
																(>
																	sum
																	cycle_length
																)
																(accum
																	(assoc
																		sum (-
																				cycle_length
																			)
																	)
																)
															)

															;if sum has gone past the min value, increase by the length of cycle, i.e., -10 degrees becomes 350
															(if
																(<
																	sum
																	0
																)
																(accum
																	(assoc
																		sum cycle_length
																	)
																)
															)

															;output the weighted sum
															sum
														)

														;else: regular continuous, retrieve the value for each neighbor,  multiply it by the weight for that case
														;then sum the weight-modified features and divide by the sum of the total weight
														(seq
															(if
																output_influence_weights
																(call
																	AccumulateInfluenceWeights
																	(assoc
																		weights (map
																				(lambda
																					(/
																						(current_value)
																						total_weight
																					)
																				)
																				neighbor_weights
																			)
																		case_ids neighbor_ids
																	)
																)
															)

															;divide the dot product by the total weight
															(/
																(dot_product
																	neighbor_values
																	neighbor_weights
																)
																total_weight
															)
														)
													)

													;else it is categorical, pull the categorical value with the highest weight sum from nearby cases
													(let

														;an assoc of categorical action feature values -> sum of their weight
														(assoc
															categorical_value_weights_map (assoc)
															output_value (null)
														)
														(if
															output_influence_weights
															(call
																AccumulateInfluenceWeights
																(assoc
																	weights neighbor_weights
																	case_ids neighbor_ids
																)
															)
														)

														;iterate over all the nearby cases, to create the mapping between each categorical action value and its summed
														;weight for this categorical feature.  for each unique categorical value in all the neighbors, sum up its weight if
														;it's encountered more than once, and select the categorical value with the highest weight below
														(assign
															(assoc
																categorical_value_weights_map (zip
																		(lambda
																			(+
																				(current_value
																					1
																				)
																				(current_value)
																			)
																		)
																		neighbor_values
																		neighbor_weights
																	)
															)
														)
														(if
															output_categorical_action_probabilities
															(call
																AccumulateCategoricalActionProbabilties
																(assoc
																	categorical_value_weights_map categorical_value_weights_map
																	action_feature action_feature
																)
															)
														)

														;sort the assoc of discrete values by their weights from high to low
														;returns the first (highest weighted) categorical value
														(assign
															(assoc
																output_value (first
																		(sort
																			(lambda
																				(>
																					(get
																						categorical_value_weights_map
																						(current_value
																							1
																						)
																					)
																					(get
																						categorical_value_weights_map
																						(current_value)
																					)
																				)
																			)
																			(indices
																				categorical_value_weights_map
																			)
																		)
																	)
															)
														)
														(if
															has_nulls

															;parse the categorical neighbor value to handle the situation where the value is the string .nas
															;and convert it to an actual (null), all other numerical or string literals will remain unchanged
															(if
																(=
																	.nas
																	output_value
																)
																(null)
																(contains_index
																	nonStringNominalFeaturesMap
																	action_feature
																)
																(+
																	output_value
																)
																(contains_index
																	ordinalNumericFeaturesSet
																	action_feature
																)
																(+
																	output_value
																)
																output_value
															)
															(contains_index
																nonStringNominalFeaturesMap
																action_feature
															)
															(+
																output_value
															)
															(contains_index
																ordinalNumericFeaturesSet
																action_feature
															)
															(+
																output_value
															)
															output_value
														)
													)
												)
											)
										)
									)

									;Selects or interpolates a set of reaction cases
									; If the feature is categorical, then it selects the case according distance.
									; If the feature is continuous, then the feature value is computed from a weighted average of values of each case
									;
									; context_features: list of context features
									; context_values: list of current values of each context
									; action_features: list of action features
									; ignore_null_action_feature: flag, if true the nearest neighbor query will ignore cases where the action_feature is null
									; match_on_context_features : flag, if true will query only for cases whose context features are not null
									; ignore_case:case_id, if set will query for K+1 cases and ignore the perfect matching case during the reaction
									; tie_break_random_seed: the random number seed to use to break ties for equal distances
									; allow_nulls : flag, if set to true will allow interpolate to return null values if there are nulls in the local model for the action features
									; force_targetless: flag, if set to true forces use of targetless hyperparameters if available
									; use_case_weights: flag, if set to true will scale influence weights by each case's .case_weight
									;
									;returns: assoc of case (entity) ids -> their distance to react case, and the next_action_chase_case id if there is one
									##GenerateReaction
									(let
										(assoc
											dependent_queries_list (if
													action_feature_is_dependent
													(call
														ComputeDependentQueries
														(assoc
															context_values context_values
															action_feature (first
																	action_features
																)
															context_features context_features
														)
													)
													(list)
												)
											k_parameter (get
													hyperparam_map
													"k"
												)
											not_null_features_queries
												;if context features must not be null, we want only find cases that have the same set of features that are not null
												(if
													match_on_context_features
													(let
														(assoc
															not_null_features (filter
																	(lambda
																		(!=
																			(null)
																			(get
																				context_values
																				(current_index)
																			)
																		)
																	)
																	context_features
																)
														)
														(apply
															(lambda
																(append)
															)
															(map
																(lambda
																	(query_not_equals
																		(get_value
																			(current_value)
																		)
																		(null)
																	)
																)
																not_null_features
															)
														)
													)

													;else there are no null case values
													(list)
												)
										)
										(declare
											(assoc
												candidate_cases_map (compute_on_contained_entities
														(append
															not_null_features_queries

															;if ignoring null action feature, query for cases where action feature is not null
															(if
																ignore_null_action_feature
																(query_not_equals
																	(first
																		action_features
																	)
																	(null)
																)
																(list)
															)
															dependent_queries_list
															(if
																ignore_case
																(if
																	focal_case
																	(query_not_in_entity_list
																		(list
																			ignore_case
																			focal_case
																		)
																	)
																	(query_not_in_entity_list
																		(list
																			ignore_case
																		)
																	)
																)
																(list)
															)
															(if
																custom_extra_filtering_queries
																custom_extra_filtering_queries
																(list)
															)
															(query_nearest_generalized_distance
																k_parameter
																context_features
																context_values
																(get
																	hyperparam_map
																	"featureWeights"
																)
																nominalClassCountsMap
																cyclicFeaturesMap
																(if
																	(get
																		hyperparam_map
																		"useDeviations"
																	)
																	(get
																		hyperparam_map
																		"featureDeviations"
																	)
																)
																(get
																	hyperparam_map
																	"p"
																)
																(get
																	hyperparam_map
																	"dwe"
																)
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)
																tie_break_random_seed
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
															)
														)
													)
											)
										)

										;populate filtering_queries for explanations if necessary
										(call PopulateFilteringQueriesForExplanation)

										;^^^(if (= 2 debug_print) (print (zip context_features context_values )))
										;^^^(if (= 2 debug_print) (map (lambda (print (current_value) " " (retrieve_entity_root (current_index)))) candidate_cases_map))
										;^^^(if (= 2 debug_print) (print "---------\n"))
										;if there is no context or no closest neighbors and we must have a value for the action feature, calculate the expected value
										;otherwise just interpolate the result
										(if
											(or
												(=
													(list)
													context_features
												)
												(and
													ignore_null_action_feature
													(=
														0
														(size
															candidate_cases_map
														)
													)
												)
											)
											(call
												CalculateFeatureExpectedValue
												(assoc
													feature (first
															action_features
														)
													allow_nulls (false)
												)
											)

											;else interpolate the result from the nearest neighbors
											(seq

												;increase count access if needed for each of the deciding cases
												(if
													case_access_count_label
													(call
														IncrementEntityCaseValue
														(assoc
															entities (indices
																	candidate_cases_map
																)
															label_name case_access_count_label
														)
													)
												)
												(call
													InterpolateActionValues
													(assoc
														allow_nulls allow_nulls
														neighbor_weights_map candidate_cases_map
														action_feature (first
																action_features
															)
														has_perfect_matches (contains_value
																candidate_cases_map
																.infinity
															)
													)
												)
											)
										)
									)

									;Helper method, if there's an explanation, we may need to cache the filtering_queries and possibly the candidate_cases_map
									##PopulateFilteringQueriesForExplanation
									(if
										(!= (null) details)
										(seq

											;for explanations persist all the fitering queries to be able to query on the exact same local model
											(if
												(=
													(list)
													filtering_queries
												)
												(assign
													(assoc
														filtering_queries (append
																not_null_features_queries

																;if ignoring null action feature, query for cases where action feature is not null
																(if
																	ignore_null_action_feature
																	(query_not_equals
																		(first
																			action_features
																		)
																		(null)
																	)
																	(list)
																)
																dependent_queries_list
																(if
																	ignore_case
																	(if
																		focal_case
																		(query_not_in_entity_list
																			(list
																				ignore_case
																				focal_case
																			)
																		)
																		(query_not_in_entity_list
																			(list
																				ignore_case
																			)
																		)
																	)
																	(list)
																)
															)
													)
												)
											)

											;backup the list of candidate cases map for these specific explanations that can reuse this exact output
											(if
												(and
													(or
														(get
															details
															"feature_mda"
														)
														(get
															details
															"outlying_feature_values"
														)
													)
													(=
														(null)
														cached_candidate_cases_map
													)
												)
												(assign
													(assoc
														cached_candidate_cases_map candidate_cases_map
													)
												)
											)
										)
									)

									;computes familiarity conviction of an avg case for each given hypothetical set of cases specified, returns a list of convictions, one per set
									;parameters:
									; trainee: the trainee model as the prior to measure the conviction from
									; features: list of label names
									; new_cases: a list of lists of values corresponding to sets of feature values, where the values are ordered corresponding to the features
									; distance_contributions : calculate and output distance contribution ratios in the output assoc
									; familiarity_conviction_addition: calculate and output familiarity conviction of adding the specified new_cases in the output assoc
									; familiarity_conviction_removal: calculate and output familiarity conviction of removing the specified new_cases in the output assoc
									; p_value_of_addition: default is false. if true will output p value of addition
									; p_value_of_removal: default is false. if true will output p value of removal
									; skip_encoding : flag, if set to true will bypass encoding features and assumes feature values are already encoded
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; high_distance_accuracy: optional, flag, defaults to true. if set to false, will use low accuracy when computing distances.
									##ReactGroup
									(declare
										(assoc
											new_cases (list)
											weight_feature ".case_weight"
											familiarity_conviction_removal (false)
											features (list)
											use_case_weights (false)
											high_distance_accuracy (true)
											skip_encoding (false)
											familiarity_conviction_addition (true)
											distance_contributions (false)
										)
										(declare
											(assoc
												model_size (call
														GetNumTrainingCases
													)
											)
										)

										;if the model is too small, just return 0, otherwise compute conviction
										(if
											(<= model_size 2)
											(conclude
												(assoc
													p_value_of_addition 0
													p_value_of_removal 0
													distance_contribution 0
													familiarity_conviction_removal 0
													combined_model_average_distance_contribution 0
													familiarity_conviction_addition 0
													base_model_average_distance_contribution 0
												)
											)
										)

										;if features aren't specified, assume all defaultFeatures will need to have their mae calculated
										(if
											(=
												0
												(size features)
											)
											(assign
												(assoc
													features defaultFeatures
												)
											)
										)

										;if features need to be encoded, overwrite the values in the new_cases list with the encoded values
										(if
											(and
												hasFeaturesNeedEncodingFromInput
												(not skip_encoding)
											)
											(assign
												(assoc
													new_cases (map
															(lambda
																(call
																	ConvertFromInput
																	(assoc
																		feature_values (current_value
																				1
																			)
																		features features
																	)
																)
															)
															new_cases
														)
												)
											)
										)
										(declare
											(assoc
												valid_weight_feature (false)
												p_value_of_removal_value (null)
												avg_new_cases_distance_contribution (null)
												average_new_cases_conviction_addition (null)
												average_new_cases_conviction_removal (null)
												p_value_of_addition_value (null)
												combined_model_average_distance_contributions (null)
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature ".none"
															feature ".targetless"
															mode "robust"
														)
													)
												new_case_entropies_value (null)
											)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)

											;else using case weights, weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
											(assign
												(assoc
													valid_weight_feature (or
															hasPopulatedCaseWeight
															(!=
																weight_feature
																".case_weight"
															)
														)
												)
											)
										)
										(declare
											(assoc
												feature_weights (get
														hyperparam_map
														"featureWeights"
													)
												closest_k (get
														hyperparam_map
														"k"
													)
												feature_deviations (if
														(get
															hyperparam_map
															"useDeviations"
														)
														(get
															hyperparam_map
															"featureDeviations"
														)
													)
											)
										)

										;closest k must be at least 2 smaller than model size, i.e., a model of 5 needs a K of 3 or less:
										;when knocking out a case during conviction calculations, each remaining case searches for K cases around itself
										;meaning that the K must be at least 2 less than the model size
										(if
											(<
												model_size
												(+
													closest_k
													2
												)
											)
											(assign
												(assoc
													closest_k (-
															model_size
															2
														)
												)
											)
										)

										;cache average case entropies and distance contributions if necessary
										(if
											(and
												familiarity_conviction_addition
												(=
													(null)
													averageModelCaseEntropyAddition
												)
											)
											(call CacheAverageModelCaseEntropyAddition)
										)
										(if
											(and
												familiarity_conviction_removal
												(=
													(null)
													averageModelCaseEntropyRemoval
												)
											)
											(call CacheAverageModelCaseEntropyRemoval)
										)
										(if
											(and
												distance_contributions
												(=
													(null)
													averageModelCaseDistanceContribution
												)
											)
											(call CacheAverageModelCaseDistanceContribution)
										)

										;create new cases
										(assign
											(assoc
												new_case_ids (map
														(lambda
															(call
																CreateCase
																(assoc
																	feature_values (current_value
																			1
																		)
																	session "none"
																	features features
																	session_index 0
																)
															)
														)
														new_cases
													)
											)
										)
										(if
											distance_contributions
											(call ComputeNewCasesDistanceContributions)
										)
										(if
											(or familiarity_conviction_addition p_value_of_addition)
											(call ComputeNewCasesFamiliarityConvictionAddition)
										)
										(if
											(or familiarity_conviction_removal p_value_of_removal)
											(call ComputeNewCasesFamiliarityConvictionRemoval)
										)

										;clean up temporary cases
										(map
											(lambda
												(destroy_entities (current_value))
											)
											new_case_ids
										)

										;output only the requested keys
										(append
											(if
												familiarity_conviction_addition
												(assoc
													familiarity_conviction_addition average_new_cases_conviction_addition
												)
												(assoc)
											)
											(if
												familiarity_conviction_removal
												(assoc
													familiarity_conviction_removal average_new_cases_conviction_removal
												)
												(assoc)
											)
											(if
												p_value_of_addition
												(assoc
													p_value_of_addition p_value_of_addition_value
												)
												(assoc)
											)
											(if
												p_value_of_removal
												(assoc
													p_value_of_removal p_value_of_removal_value
												)
												(assoc)
											)
											(if
												distance_contributions
												(assoc
													distance_contribution avg_new_cases_distance_contribution
													combined_model_average_distance_contribution combined_model_average_distance_contributions
													base_model_average_distance_contribution averageModelCaseDistanceContribution
												)
												(assoc)
											)
										)
									)

									;Generate lists of unique values for each 'unique' feature that isn't being conditioned on for use in #React
									; returns an assoc of:  feature -> (list unique values).  if batch_size is 1, returns an assoc of: feature -> unique value
									;
									;parameters:
									;
									; batch_size: number of values to generate for each feature
									; action_features: list of features that will be output (reacted to/generated)
									; context_features: list of features that condition the reaction
									; preserve_feature_values: list of features that are used to condition the reaction whose values will be preserved during the reaction
									##GenerateUniquesListMap
									(let

										;create a list of unique features that should have values generated
										(assoc
											unique_features_to_generate
												;do not generate values for any unique features that are used as contexts
												(if
													(or
														(>
															(size
																preserve_feature_values
															)
															0
														)
														(>
															(size
																context_features
															)
															0
														)
													)
													(filter
														(lambda

															;keep only those features that are not being conditioned on
															(not
																(or
																	(contains_value
																		preserve_feature_values
																		(current_value)
																	)
																	(contains_value
																		context_features
																		(current_value)
																	)
																)
															)
														)

														;intersection of two assocs keeps all the same features regardless of ordering
														(indices
															(intersect
																(zip
																	action_features
																)
																uniqueNominalsMap
															)
														)
													)

													;else all the unique features that in the action_features list
													(indices
														(intersect
															(zip
																action_features
															)
															uniqueNominalsMap
														)
													)
												)
										)
										(if
											(>
												(size unique_features_to_generate)
												0
											)
											(map
												(lambda
													(let
														(assoc
															unique_values_map (zip
																	(map
																		(lambda
																			(call
																				GenerateInt64String
																			)
																		)
																		(range
																			1
																			batch_size
																		)
																	)
																)
														)

														;if by some small chance any duplicates were generated, accumulate enough new uniques to replace the dupes
														(while
															(<
																(size
																	unique_values_map
																)
																batch_size
															)

															;accumulate-append new generated subsitutions to the map, dupclicates will be clobbered
															(accum
																(assoc
																	unique_values_map (associate
																			(call
																				GenerateInt64String
																			)
																			(null)
																		)
																)
															)
														)

														;output a list of batch_size unique int64s if batch is > 1, otherwise return just the unique int64
														(if
															(=
																1
																batch_size
															)
															(first
																(indices
																	unique_values_map
																)
															)
															(indices
																unique_values_map
															)
														)
													)
												)
												(zip unique_features_to_generate)
											)
										)
									)

									;validate passed in series stop map against the optionally specified feature_bounds_map and the trainee's featureBoundsMap.
									;If a stopmap feature min is <= boundary min, or a stopmap max is >= boundary max, series won't ever reach the stopping point
									;because the boundary will prevent that value from being generated.  For nominals, ensure that at least one stopping value is
									;allowed.
									;
									;returns the name of a stop map feature with an invalid stopping value
									;
									;parameters:
									; series_stop_maps: list of series stop maps with specified stopping condition for each feature
									; feature_bounds_map: optional assoc of user specified feature bounds, takes precedence over the trainee stored feature bounds
									##ValidateSeriesStopMaps
									(declare
										(assoc
											series_stop_maps (list)
											invalid_stopmap_feature (null)
											feature_bounds_map (assoc)
										)
										(map
											(lambda
												(let
													(assoc
														series_stop_map (current_value
																1
															)
													)
													(map
														(lambda

															;current_index = feature
															;current_value = stop map
															;if this stop map feature has a bound, verify it
															(if
																(or
																	(contains_index
																		feature_bounds_map
																		(current_index)
																	)
																	(contains_index
																		featureBoundsMap
																		(current_index)
																	)
																)
																(let
																	(assoc
																		bounds_map
																			;if the bound is defined specifically for this react call
																			(if
																				(contains_index
																					feature_bounds_map
																					(current_index
																						1
																					)
																				)
																				(get
																					feature_bounds_map
																					(current_index
																						1
																					)
																				)

																				;else the bound is defined in the trainee feature bounds
																				(get
																					featureBoundsMap
																					(current_index
																						1
																					)
																				)
																			)
																	)

																	;stop map has explicit stop values, ensure bounds map allows at least one of them
																	(if
																		(and
																			(contains_index
																				(current_value)
																				"values"
																			)
																			(get
																				bounds_map
																				"allowed"
																			)
																		)
																		(if
																			(=
																				(size
																					(get
																						bounds_map
																						"allowed"
																					)
																				)

																				;when we remove all the stop values from the allowed list, if the resulting allowed list hasn't changed size,
																				;that means none of the stopping values were on the allowed list, which is an invalid stopping condition
																				(size
																					(remove
																						(zip
																							(get
																								bounds_map
																								"allowed"
																							)
																						)
																						(get
																							(current_value)
																							"values"
																						)
																					)
																				)
																			)
																			(assign
																				(assoc
																					invalid_stopmap_feature (get_value
																							(current_index
																								1
																							)
																						)
																				)
																			)
																		)
																	)

																	;datetime features need to compare to epoch min and max, continuous can just directly compare min and max
																	(if
																		(contains_index
																			featureDateTimeMap
																			(current_index)
																		)
																		(let
																			(assoc
																				feature (get_value
																						(current_index
																							1
																						)
																					)
																				stop_map (current_value
																						1
																					)
																				epoch_bounds_max (get
																						bounds_map
																						"epoch_max_value"
																					)
																				epoch_bounds_min (get
																						bounds_map
																						"epoch_min_value"
																					)
																			)
																			(declare
																				(assoc
																					epoch_stop_min (if
																							(get
																								stop_map
																								"min"
																							)
																							(format
																								(get
																									stop_map
																									"min"
																								)
																								(get
																									featureDateTimeMap
																									(list
																										feature
																										"date_time_format"
																									)
																								)
																								"number"
																								(get
																									featureDateTimeMap
																									(list
																										feature
																										"locale"
																									)
																								)
																								""
																							)
																						)
																					epoch_stop_max (if
																							(get
																								stop_map
																								"max"
																							)
																							(format
																								(get
																									stop_map
																									"max"
																								)
																								(get
																									featureDateTimeMap
																									(list
																										feature
																										"date_time_format"
																									)
																								)
																								"number"
																								(get
																									featureDateTimeMap
																									(list
																										feature
																										"locale"
																									)
																								)
																								""
																							)
																						)
																				)
																			)
																			(if
																				(not
																					(get
																						bounds_map
																						"has_epoch_bounds"
																					)
																				)

																				;convert the bounds min and max from string date to epoch seconds
																				(assign
																					(assoc
																						epoch_bounds_max (if
																								(!=
																									(null)
																									(get
																										bounds_map
																										"max"
																									)
																								)
																								(format
																									(get
																										bounds_map
																										"max"
																									)
																									(get
																										featureDateTimeMap
																										(list
																											feature
																											"date_time_format"
																										)
																									)
																									"number"
																									(get
																										featureDateTimeMap
																										(list
																											feature
																											"locale"
																										)
																									)
																									""
																								)
																							)
																						epoch_bounds_min (if
																								(!=
																									(null)
																									(get
																										bounds_map
																										"min"
																									)
																								)
																								(format
																									(get
																										bounds_map
																										"min"
																									)
																									(get
																										featureDateTimeMap
																										(list
																											feature
																											"date_time_format"
																										)
																									)
																									"number"
																									(get
																										featureDateTimeMap
																										(list
																											feature
																											"locale"
																										)
																									)
																									""
																								)
																							)
																					)
																				)
																			)

																			;invalid condition if the stopping min value is same or smaller than bounds min
																			(if
																				(<=
																					epoch_stop_min
																					epoch_bounds_min
																				)
																				(assign
																					(assoc
																						invalid_stopmap_feature feature
																					)
																				)
																			)

																			;invalid condition if the stoppnig max value is same or larger than bounds max
																			(if
																				(>=
																					epoch_stop_max
																					epoch_bounds_max
																				)
																				(assign
																					(assoc
																						invalid_stopmap_feature feature
																					)
																				)
																			)
																		)

																		;else regular continuous feature, compare min and max bounds
																		(seq

																			;invalid condition if the stopping min value is same or smaller than bounds min
																			(if
																				(<=
																					(get
																						(current_value)
																						"min"
																					)
																					(get
																						bounds_map
																						"min"
																					)
																				)
																				(assign
																					(assoc
																						invalid_stopmap_feature (get_value
																								(current_index
																									1
																								)
																							)
																					)
																				)
																			)

																			;invalid condition if the stoppnig max value is same or larger than bounds max
																			(if
																				(>=
																					(get
																						(current_value)
																						"max"
																					)
																					(get
																						bounds_map
																						"max"
																					)
																				)
																				(assign
																					(assoc
																						invalid_stopmap_feature (get_value
																								(current_index
																									1
																								)
																							)
																					)
																				)
																			)
																		)
																	)
																)
															)
														)
														series_stop_map
													)
												)
											)
											series_stop_maps
										)

										;output the invalid feature
										invalid_stopmap_feature
									)

									;dependent features map is a map of each feature that has relationships/dependents and is stored in the format of:
									;
									; feature : { "dependent_features": [ list of all related features ] }
									;	   "min" and "max" attributes are added for continuous features once those are computed.
									;
									;compute and output filter query conditions for dependent features to be used in queries
									##ComputeDependentQueries
									(declare
										(assoc
											context_values (list)
											action_feature (null)
											context_features (list)
										)
										(declare
											(assoc
												dependent_features (get
														dependent_features_map
														(list
															action_feature
															"dependent_features"
														)
													)
											)
										)

										; determine if there are any dependents in context features by only keeping those that context_features contains
										(declare
											(assoc
												dependent_context_features (filter
														(lambda
															(contains_value
																dependent_features
																(current_value)
															)
														)
														context_features
													)
											)
										)

										;generate query filtering if there are dependent context features
										(if
											(size dependent_context_features)
											(let
												(assoc
													continuous_context_features (list)
													output_queries (list)
													dependent_context_map (keep
															(zip
																context_features
																context_values
															)
															dependent_context_features
														)
												)

												;if a continuous dependent feature is in contexts and we are reacting to a nominal value, limit what that value can be
												;by creating a list of query_among for the nominal features whose bounds encompass the continuous context value
												(if
													(and
														(size
															continuousDependentsMap
														)
														(contains_index
															nominalsSet
															action_feature
														)
													)
													(map
														(lambda

															;if a continuous dependent feature is in the contexts, then check if any of its dependent nominals are also in the contexts
															(if
																(contains_index
																	dependent_context_map
																	(current_index)
																)
																(seq
																	(accum
																		(assoc
																			continuous_context_features (get_value
																					(current_index
																						1
																					)
																				)
																		)
																	)

																	;if the continuous feature's corresponding dependent nominals are not in the contexts, create query_among filters
																	(if
																		(=
																			(size
																				dependent_context_map
																			)
																			(size
																				(remove
																					dependent_context_map
																					(current_value)
																				)
																			)
																		)
																		(let
																			(assoc
																				continuous_feature (get_value
																						(current_index
																							1
																						)
																					)
																				dependent_combos_encompassing_value (list)
																				continuous_value (get
																						dependent_context_map
																						(get_value
																							(current_index
																								1
																							)
																						)
																					)
																			)
																			(assign
																				(assoc
																					dependent_combos_encompassing_value (filter
																							(lambda
																								(let
																									(assoc
																										bounds_pair (get
																												dependentsBoundaryMap
																												(append
																													continuous_feature
																													(current_value
																														1
																													)
																												)
																											)
																									)
																									(and
																										(>=
																											continuous_value
																											(first
																												bounds_pair
																											)
																										)
																										(<=
																											continuous_value
																											(last
																												bounds_pair
																											)
																										)
																									)
																								)
																							)
																							(get
																								dependentValuesCombinationsMap
																								continuous_feature
																							)
																						)
																				)
																			)

																			;it's possible the context value is outside all bounds, don't do among queries for privacy and exploratory reasons
																			(if
																				(size
																					dependent_combos_encompassing_value
																				)
																				(accum
																					(assoc
																						output_queries
																							;create a list of corresponding query_among queries in the format of:
																							; (query_among <dependentFeature> (list <values that encompass the context value>))
																							(map
																								(lambda
																									(let
																										(assoc
																											f_index (get_value
																													(current_index
																														1
																													)
																												)
																										)
																										(query_among
																											(current_value)
																											(map
																												(lambda
																													(get
																														(current_value)
																														f_index
																													)
																												)
																												dependent_combos_encompassing_value
																											)
																										)
																									)
																								)

																								;list of nominal dependent features for this continuous one
																								(get
																									continuousDependentsMap
																									continuous_feature
																								)
																							)
																					)
																				)

																				;else this continuous value isn't encompassed by nominal combos, find the one closest case to this continuous value
																				;and use its nominal value for this action feature since it's the most "resonable"
																				(let
																					(assoc
																						reasonable_nominal_value_case (first
																								(contained_entities
																									(list
																										(query_nearest_generalized_distance
																											1

																											; k = 1
																											(list
																												continuous_feature
																											)
																											(list
																												continuous_value
																											)
																											(null)

																											; weight don't matter because there's only one context
																											(null)

																											; not a nominal
																											(null)

																											; not cyclic since it's a multi-purpose continuous
																											(null)

																											; deviations don't matter because it's one context
																											1

																											;p value isn't relevant because it's one context
																											1

																											;dwe
																											(null)

																											; weight feature doesn't matter
																											(rand)
																											(null)

																											; radius
																											lpSpaceHeuristicMultiplier
																										)
																									)
																								)
																							)
																					)
																					(accum
																						(assoc
																							output_queries (list
																									(query_among
																										action_feature
																										(list
																											(retrieve_from_entity
																												reasonable_nominal_value_case
																												action_feature
																											)
																										)
																									)
																								)
																						)
																					)
																				)
																			)
																		)
																	)
																)
															)
														)
														continuousDependentsMap
													)
												)

												;generate one query_between or query_equals per dependent context feature
												(accum
													(assoc
														output_queries (map
																(lambda
																	(let
																		(assoc
																			context_feature (current_value
																					1
																				)
																			context_value (get
																					dependent_context_map
																					(current_value
																						1
																					)
																				)
																		)
																		(if
																			(contains_index
																				nominalsSet
																				context_feature
																			)
																			(query_equals
																				context_feature
																				context_value
																			)

																			;else continuous value, get min+max range for it
																			(let
																				(assoc
																					min (get
																							dependent_features_map
																							(list
																								context_feature
																								"min"
																							)
																						)
																					max (get
																							dependent_features_map
																							(list
																								context_feature
																								"max"
																							)
																						)
																				)

																				;min and max are null only if the feature value is null, then don't filter on this feature
																				(if
																					(=
																						(null)
																						min
																						max
																					)
																					(query_between)
																					(query_between
																						context_feature
																						min
																						max
																					)
																				)
																			)
																		)
																	)
																)

																;reorder the list of dependent_context_features such that all the nominals are first, then the continous ones
																;so that all the query_betweens are last, and thus if needbe, will be truncated first
																(append
																	(filter
																		(lambda
																			(contains_index
																				nominalsSet
																				(current_value)
																			)
																		)
																		dependent_context_features
																	)
																	continuous_context_features
																)
															)
													)
												)
												output_queries
											)

											;else return empty list
											(list)
										)
									)
									##ComputeAndCacheMinMaxForDependentContinuousContexts
									(declare
										(assoc
											use_regional_model_residuals (true)
											context_values (list)
											hyperparam_map (assoc)
											context_features (list)
										)
										(declare
											(assoc
												dependent_continuous_features_map (filter
														(lambda
															(and
																(contains_index
																	dependent_features_map
																	(current_index)
																)
																(not
																	(contains_index
																		nominalsSet
																		(current_index)
																	)
																)
															)
														)
														(zip
															context_features
															context_values
														)
													)
											)
										)
										(if
											(=
												0
												(size dependent_continuous_features_map)
											)
											(conclude)
										)
										(declare
											(assoc
												local_k (get
														hyperparam_map
														"k"
													)
											)
										)
										(declare
											(assoc
												regional_model_cases_tuple (compute_on_contained_entities
														(append
															(if
																ignore_case
																(query_not_in_entity_list
																	(list
																		ignore_case
																	)
																)
																(list)
															)
															(query_nearest_generalized_distance
																(if
																	use_regional_model_residuals
																	(max
																		local_k
																		30
																	)
																	(max
																		(*
																			2.718281828459045
																			local_k
																		)
																		30
																	)
																)
																context_features
																context_values
																(get
																	hyperparam_map
																	"featureWeights"
																)
																nominalClassCountsMap
																cyclicFeaturesMap
																(if
																	(get
																		hyperparam_map
																		"useDeviations"
																	)
																	(get
																		hyperparam_map
																		"featureDeviations"
																	)
																)
																(get
																	hyperparam_map
																	"p"
																)
																(get
																	hyperparam_map
																	"dwe"
																)
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)
																(rand)
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
																(true)
															)
														)
													)
											)
										)
										(if
											use_regional_model_residuals
											(let
												(assoc
													regional_residuals (call
															ComputeRegionalResiduals
															(assoc
																residual_features (indices
																		dependent_continuous_features_map
																	)
																ignore_case ignore_case
																features context_features
																regional_model_cases_map (apply
																		"zip"
																		regional_model_cases_tuple
																	)
															)
														)
												)

												;update the the min/max for all the dependent context features from the computed regional residuals
												(map
													(lambda
														(let
															(assoc
																feature_residual (get
																		regional_residuals
																		(current_index
																			1
																		)
																	)
															)
															(accum
																"dependent_features_map"
																(list
																	(current_index
																		1
																	)
																	"min"
																)
																(-
																	(current_value)
																	feature_residual
																)
																(list
																	(current_index
																		1
																	)
																	"max"
																)
																(+
																	(current_value)
																	feature_residual
																)
															)
														)
													)
													dependent_continuous_features_map
												)
											)

											;else approximate residual for each dependent context feature
											(let
												(assoc
													regional_case_ids (first
															regional_model_cases_tuple
														)
												)
												(declare
													(assoc
														local_case_ids (trunc
																regional_cases
																local_k
															)
													)
												)
												(map
													(lambda
														(let
															(assoc
																feature (current_index
																		1
																	)
															)
															(declare
																(assoc
																	feature_residual (max
																			(get
																				cachedFeatureMinGapMap
																				feature
																			)
																			(min
																				(compute_on_contained_entities
																					(list
																						(query_in_entity_list
																							local_case_ids
																						)
																						(query_max_difference
																							feature
																							(get
																								cyclicFeaturesMap
																								feature
																							)
																						)
																					)
																				)
																				(compute_on_contained_entities
																					(list
																						(query_in_entity_list
																							regional_case_ids
																						)
																						(query_max_difference
																							feature
																							(get
																								cyclicFeaturesMap
																								feature
																							)
																						)
																					)
																				)
																			)
																		)
																)
															)
															(accum
																"dependent_features_map"
																(list
																	feature
																	"min"
																)
																(-
																	(current_value)
																	feature_residual
																)
																(list
																	feature
																	"max"
																)
																(+
																	(current_value)
																	feature_residual
																)
															)
														)
													)
													dependent_continuous_features_map
												)
											)
										)
									)
								)

								;module for trainee_template
								;contains methods for computing residuals and decrease in accuracy via M.A.E. (mean absolute error)
								(null

									;iterate over the specified deviation_features_map and output maximum knwown residuals for each feature
									##ComputeMaxResiduals
									(map
										(lambda

											;if a bounds map is defined, use the max delta for the bounds if min and max are specified
											(if
												(contains_index
													featureBoundsMap
													(current_index)
												)

												;nominals max residual is 1
												(if
													(contains_index
														nominalsSet
														(current_index)
													)
													1

													;datetime features with bounds will have epoch bounds defined
													(get
														featureBoundsMap
														"has_epoch_bounds"
													)
													(-
														(get
															featureBoundsMap
															"epoch_max_value"
														)
														(get
															featureBoundsMap
															"epoch_min_value"
														)
													)

													;continuous, non-datetime features
													(and
														(not
															(contains_index
																featureDateTimeMap
																(current_index)
															)
														)
														(contains_index
															featureBoundsMap
															"min"
														)
														(contains_index
															featureBoundsMap
															"max"
														)
													)
													(-
														(get
															featureBoundsMap
															"max"
														)
														(get
															featureBoundsMap
															"min"
														)
													)

													;if cyclical, output cycle length
													(contains_index
														cyclicFeaturesMap
														(current_index)
													)
													(get
														cyclicFeaturesMap
														(current_index)
													)

													;if defined numeric ordinal, output the total cardinality
													(contains_index
														ordinalOrdinalToStringMap
														(current_index)
													)
													(size
														(get
															ordinalOrdinalToStringMap
															(current_index)
														)
													)

													;else unspecified min/max for feature, return maximum residual
													.infinity
												)

												;no bounds specified, return maximum residual
												.infinity
											)
										)
										deviation_features_map
									)

									;compute and cache specified feature intepretations such as Mean Decrease in Accuracy (MDA) and feature residuals.
									;
									;parameters:
									; residuals: optional, none/true/false. For each context_feature, use the full set of all other context_features to
									;                 predict the feature. false removes cached values.
									; residuals_robust: optional, none/true/false. For each context_feature, use the robust (power set/permutations)
									;                 set of all other context_features to predict the feature.  false removes cached values.
									;
									; contributions: optional, none/true/false.  For each context_feature, use the full set of all other context_features to compute the
									;				 mean absolute delta between prediction of action_feature with and without the context_feature in the model.  false removes cached values.
									; contributions_robust: optional, none/true/false. For each context_feature, use the robust (power set/permutation) set of all other context_features
									;				 to compute the mean absolute delta between prediction of action_feature with and without the context_feature in the model.
									;				false removes cached values.
									;
									; mda: optional, none/true/false. if true will compute Mean Decrease in Accuracy (MDA) for each context feature at predicting mda_action_features.
									;                Drop each feature and use the full set of remaining context features for each prediction.  false removes cached values.
									; mda_permutation: optional, none/true/false. Compute MDA by scrambling each feature and using the full set of remaining context features
									;                for each prediction.  false removes cached values.
									; mda_robust: optional, none/true/false. Compute MDA by dropping each feature and using the robust (power set/permutations) set of
									;                remaining context features for each prediction.  false removes cached values.
									; mda_robust_permutation: optional, none/true/false. Compute MDA by scrambling  each feature and using the robust (power set/permutations)
									;                set of remaining context features for each prediction.  false removes cached values.
									; action_feature: optional, target feature for which to do computations. Default is whatever the model was optimized for, i.e.,
									;				  action feature for MDA and contributions, or ".targetless" if optimized for targetless.
									;				  This parameter is required for any MDA or contributions computation.
									;
									; context_features: optional list of features to use as contexts for computations. default is all features if unspecified.
									; num_samples: optional. Sample size of model to use (using sampling with replacement). Defaults to 1000 for non-robust, for robust
									;				  computations scales the 1000 up dynamically by (1 + log(number of features)).
									;				  If specified uses the unmodified value and overrides sample_model_fraction.
									; sample_model_fraction : optional, value 0.0 - 1.0, percent of model to use in sampling (using sampling without replacement).
									;				  Applicable only to non-robust computation. Ignored if num_samples is specified.
									; sub_model_size: optional. if specified will calculate only on a sub model of the specified size from the full model.
									;				  Applicable only to models > 1000 cases.
									; hyperparameter_param_path: optional. full path for hyperparameters to use for computation.
									;				  If specified for any residual computations, takes precendence over action_feature parameter.
									; use_case_weights: optional, flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									##ReactIntoTrainee
									(declare
										(assoc
											mda_robust (null)
											num_samples (null)
											sample_model_fraction (null)
											sub_model_size (null)
											weight_feature ".case_weight"
											hyperparameter_param_path (null)
											residuals_robust (null)
											use_case_weights (false)
											action_feature (null)
											mda_robust_permutation (null)
											context_features (list)
											residuals (null)
											contributions (null)
											contributions_robust (null)
											mda (null)
											mda_permutation (null)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)
										)
										(declare
											(assoc
												num_training_cases (call
														GetNumTrainingCases
													)
												holdout_entity_name (null)
												num_cases_multiplier 1
											)
										)

										;if a sub_model_size has been specified and the model is non-trivial size
										;hold out random cases that the model that remains is sub_model_size
										(if
											(and
												(>
													sub_model_size
													0
												)
												(>
													num_training_cases
													1000
												)
											)

											;if the sub_model is larger than the full model, don't holdout anything
											(if
												(>
													sub_model_size
													num_training_cases
												)
												(assign
													(assoc
														sub_model_size (null)
													)
												)

												;else holdout cases so that only sub_model_size remain
												(assign
													(assoc
														holdout_entity_name (call
																HoldOutRandomCases
																(assoc
																	num_samples (-
																			num_training_cases
																			sub_model_size
																		)
																)
															)
													)
												)
											)
										)
										(if
											(=
												0
												(size context_features)
											)
											(assign
												(assoc
													context_features defaultFeatures
												)
											)
										)

										;for robust flows, scale the number of cases relative to the log of context_features
										(if
											(or
												contributions_robust
												residuals_robust
												mda_robust
												mda_robust_permutation
											)
											(assign
												(assoc
													num_cases_multiplier (+
															1
															(log
																(size
																	context_features
																)
															)
														)
												)
											)
										)

										;if num_samples was explicitly specified by user, use that many, even if it means
										;it should super-sample the model to match the exact number of samples specified
										;and by default sample 1000 out of the full model if num_samples wasn't specified
										(declare
											(assoc
												case_ids (if
														num_samples
														(call
															SampleCases
															(assoc
																num num_samples
															)
														)
														(>
															sample_model_fraction
															0
														)
														(call
															AllCases
															(assoc
																num (*
																		sample_model_fraction
																		num_training_cases
																	)
															)
														)

														;else sample with replacement 1000
														(call
															SampleCases
															(assoc
																num (*
																		1000
																		num_cases_multiplier
																	)
															)
														)
													)
												mda_map (null)
											)
										)

										;if the hyperparameter action feature hasn't been provided, figure it out dynamically when computing residuals
										(if
											(or residuals residuals_robust)
											(if
												(=
													(null)
													action_feature
												)
												(let
													(assoc
														hp_features (indices
																hyperparameterMetadataMap
															)
													)
													(assign
														(assoc
															action_feature (if
																	hyperparameter_param_path
																	(first
																		hyperparameter_param_path
																	)

																	;else auto-determine action_feature
																	(if
																		(=
																			1
																			(size
																				hp_features
																			)
																		)
																		(first
																			hp_features
																		)

																		;if there are exactly two HP sets, one is the default .targetless, thus the other must be a manually
																		;optimized targeted feature meaning we should assume the user wants to use that one
																		(=
																			2
																			(size
																				hp_features
																			)
																		)
																		(if
																			(=
																				".targetless"
																				(first
																					hp_features
																				)
																			)
																			(last
																				hp_features
																			)
																			(first
																				hp_features
																			)
																		)

																		;otherwise default to .targetless
																		".targetless"
																	)
																)
														)
													)
												)
											)
										)

										;if any of residual sets should be removed
										(if
											(contains_value
												(list
													residuals
													residuals_robust
												)
												(false)
											)
											(let
												(assoc
													residuals_map (retrieve_from_entity
															"residualsMap"
														)
													hyperparam_map (assoc)
												)

												;remove 'full' residuals
												(if
													(=
														(false)
														residuals
													)
													(seq
														(assign
															(assoc
																hyperparam_map (call
																		GetHyperparameters
																		(assoc
																			weight_feature weight_feature
																			feature action_feature
																			mode (if
																					(!=
																						".targetless"
																						action_feature
																					)
																					"full"
																					"robust"
																				)
																		)
																	)
															)
														)
														(assign
															(assoc
																residuals_map (remove
																		residuals_map
																		(apply
																			"concat"
																			(append
																				"full"
																				(get
																					hyperparam_map
																					"paramPath"
																				)
																			)
																		)
																	)
															)
														)
													)
												)

												;remove 'robust' residuals
												(if
													(=
														(false)
														residuals_robust
													)
													(seq
														(assign
															(assoc
																hyperparam_map (call
																		GetHyperparameters
																		(assoc
																			weight_feature weight_feature
																			feature action_feature
																			mode "robust"
																		)
																	)
															)
														)
														(assign
															(assoc
																residuals_map (remove
																		residuals_map
																		(apply
																			"concat"
																			(append
																				"robust"
																				(get
																					hyperparam_map
																					"paramPath"
																				)
																			)
																		)
																	)
															)
														)
													)
												)
												(assign_to_entities
													(assoc
														residualsMap residuals_map
													)
												)
												(accum_to_entities
													(assoc
														revision 1
													)
												)
											)
										)

										;set the custom hp map if user specified a hyperparameter_param_path
										(declare
											(assoc
												custom_hyperparam_map (if
														hyperparameter_param_path
														(get
															hyperparameterMetadataMap
															hyperparameter_param_path
														)
													)
											)
										)
										(if
											residuals
											(call_entity
												trainee
												"CalculateFeatureResiduals"
												(assoc
													robust_residuals (false)
													store_deviations (true)
													weight_feature weight_feature
													custom_hyperparam_map custom_hyperparam_map
													features context_features
													case_ids case_ids
													use_case_weights use_case_weights
													hyperparameter_feature action_feature
												)
											)
										)
										(if
											residuals_robust
											(call_entity
												trainee
												"CalculateFeatureResiduals"
												(assoc
													robust_residuals (true)
													store_deviations (true)
													weight_feature weight_feature
													custom_hyperparam_map custom_hyperparam_map
													features context_features
													case_ids case_ids
													use_case_weights use_case_weights
													hyperparameter_feature action_feature
												)
											)
										)

										;doing contributions
										(if
											(not
												(=
													(null)
													contributions
													contributions_robust
												)
											)
											(seq
												(assign
													(assoc
														context_features (filter
																(lambda
																	(!=
																		action_feature
																		(current_value)
																	)
																)
																context_features
															)
													)
												)

												;if any of the stored contributions sets should be removed
												(if
													(contains_value
														(list
															contributions
															contributions_robust
														)
														(false)
													)
													(let
														(assoc
															contributions_map (retrieve_from_entity
																	"contributionsMap"
																)
														)
														(if
															(=
																(false)
																contributions
															)
															(assign
																(assoc
																	contributions_map (remove
																			contributions_map
																			(concat
																				"full"
																				weight_feature
																				action_feature
																			)
																		)
																)
															)
														)
														(if
															(=
																(false)
																contributions_robust
															)
															(assign
																(assoc
																	contributions_map (remove
																			contributions_map
																			(concat
																				"robust"
																				weight_feature
																				action_feature
																			)
																		)
																)
															)
														)
														(assign_to_entities
															(assoc
																contributionsMap contributions_map
															)
														)
														(accum_to_entities
															(assoc
																revision 1
															)
														)
													)
												)
												(if
													contributions
													(call_entity
														trainee
														"CalculateFeatureContributions"
														(assoc
															robust (false)
															weight_feature weight_feature
															custom_hyperparam_map custom_hyperparam_map
															case_ids case_ids
															action_feature action_feature
															context_features context_features
														)
													)
												)
												(if
													contributions_robust
													(call_entity
														trainee
														"CalculateFeatureContributions"
														(assoc
															robust (true)
															weight_feature weight_feature
															custom_hyperparam_map custom_hyperparam_map
															case_ids case_ids
															action_feature action_feature
															context_features context_features
														)
													)
												)
											)
										)

										;doing MDA
										(if
											(not
												(=
													(null)
													mda
													mda_robust
													mda_permutation
													mda_robust_permutation
												)
											)
											(seq
												(assign
													(assoc
														context_features (filter
																(lambda
																	(!=
																		action_feature
																		(current_value)
																	)
																)
																context_features
															)
													)
												)

												;if any of the stored MDA sets should be removed
												(if
													(contains_value
														(list
															mda
															mda_robust
															mda_permutation
															mda_robust_permutation
														)
														(false)
													)
													(let
														(assoc
															mda_map (retrieve_from_entity
																	"mdaMap"
																)
														)
														(if
															(=
																(false)
																mda
															)
															(assign
																(assoc
																	mda_map (remove
																			mda_map
																			(concat
																				"dropfull"
																				weight_feature
																				action_feature
																			)
																		)
																)
															)
														)
														(if
															(=
																(false)
																mda_robust
															)
															(assign
																(assoc
																	mda_map (remove
																			mda_map
																			(concat
																				"droprobust"
																				weight_feature
																				action_feature
																			)
																		)
																)
															)
														)
														(if
															(=
																(false)
																mda_permutation
															)
															(assign
																(assoc
																	mda_map (remove
																			mda_map
																			(concat
																				"permutationfull"
																				weight_feature
																				action_feature
																			)
																		)
																)
															)
														)
														(if
															(=
																(false)
																mda_robust_permutation
															)
															(assign
																(assoc
																	mda_map (remove
																			mda_map
																			(concat
																				"permutationrobust"
																				weight_feature
																				action_feature
																			)
																		)
																)
															)
														)
														(assign_to_entities
															(assoc
																mdaMap mda_map
															)
														)
														(accum_to_entities
															(assoc
																revision 1
															)
														)
													)
												)
												(if
													mda
													(call_entity
														trainee
														"CalculateMDA"
														(assoc
															robust (false)
															weight_feature weight_feature
															custom_hyperparam_map custom_hyperparam_map
															case_ids case_ids
															use_case_weights use_case_weights
															action_feature action_feature
															sensitivity_to_randomization (false)
															context_features context_features
														)
													)
												)
												(if
													mda_robust
													(call_entity
														trainee
														"CalculateMDA"
														(assoc
															robust (true)
															weight_feature weight_feature
															custom_hyperparam_map custom_hyperparam_map
															case_ids case_ids
															use_case_weights use_case_weights
															action_feature action_feature
															sensitivity_to_randomization (false)
															context_features context_features
														)
													)
												)
												(if
													mda_permutation
													(call_entity
														trainee
														"CalculateMDA"
														(assoc
															robust (false)
															weight_feature weight_feature
															custom_hyperparam_map custom_hyperparam_map
															case_ids case_ids
															use_case_weights use_case_weights
															action_feature action_feature
															sensitivity_to_randomization (true)
															context_features context_features
														)
													)
												)
												(if
													mda_robust_permutation
													(call_entity
														trainee
														"CalculateMDA"
														(assoc
															robust (true)
															weight_feature weight_feature
															custom_hyperparam_map custom_hyperparam_map
															case_ids case_ids
															use_case_weights use_case_weights
															action_feature action_feature
															sensitivity_to_randomization (true)
															context_features context_features
														)
													)
												)
											)
										)
										(if
											holdout_entity_name
											(call
												RestoreHeldOutCases
												(assoc
													holdout_entity_name holdout_entity_name
												)
											)
										)
										(true)
									)

									;Wrapper method for DecreaseInAccuracy method to calculate and store MDA for specified features.
									##CalculateMDA
									(declare
										(assoc
											robust (false)
											weight_feature ".case_weight"
											custom_hyperparam_map (null)
											case_ids (list)
											use_case_weights (false)
											action_feature ""
											sensitivity_to_randomization (false)
											context_features (list)
										)
										(declare
											(assoc
												mda_map (call_entity
														trainee
														"DecreaseInAccuracy"
														(assoc
															robust robust
															weight_feature weight_feature
															case_ids case_ids
															use_case_weights use_case_weights
															action_features (list
																	action_feature
																)
															hyperparam_map custom_hyperparam_map
															sensitivity_to_randomization sensitivity_to_randomization
															context_features context_features
														)
													)
												param_path (concat
														(if
															sensitivity_to_randomization
															"permutation"
															"drop"
														)
														(if
															robust
															"robust"
															"full"
														)
														weight_feature
														action_feature
													)
											)
										)

										;store into mdaMap
										(assign_to_entities
											(assoc
												mdaMap (set
														mdaMap
														param_path
														(append
															mda_map
															(assoc
																".mda_type" (if
																		sensitivity_to_randomization
																		"permutation"
																		"drop"
																	)
																".weight_feature" weight_feature
																".action_feature" action_feature
																".robust" robust
															)
														)
													)
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)
									)

									;calculate feature residual values, i.e. the mae (mean absolute error of predictions on a sample of the model) for each of the specified features
									;returns an assoc of feature residuals. If output_ordinal_residuals is true, outputs a list of 2 assocs, the second being ordinal residuals.
									;
									;parameters:
									; features: optional list of features for which to use as contexts features. If not specified will use defaultFeatures.
									; residual_features: optional list of features for which to calculate the (MAE) residuals. If not specified will be same as features.
									; cases_map: optional assoc of case ids -> distance from a hypothetical case  for which to use in the calculation as a local model,
									;			 if not specified will use num_samples from AllCases to calculate feature residuals. If specified ignores 'case_ids'.
									; case_ids: optional list of case ids to compute residuals. If 'cases_map' is specified, will ignore this parameter.
									; focal_case: optional case id of case for which to compute residuals from the specified cases_map and is to be ignored during computation
									; num_samples : optional case sample size to use in calculation, will be ignored if the cases_map parameter is specified
									; compute_low_and_high_mae : flag, if set to true will additinally compute the low and high mae
									; robust_residuals: flag, default to false. when true calculates residuals robust with respect to the set of contexts used (across the power set of contexts)
									; hyperparameter_feature: optional  default '.targetless'.  feature whose hyperparameters to use
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; output_ordinal_residuals: flag, if set to true will output a pair of assoc of feature residuals and assoc of ordinal residuals
									; store_deviations: flag, default false, will not update model hyperpaprameters. if true  will update model hyperparameters
									; custom_hyperparam_map: optional, hyperparameters to use for resdiuals computation
									##CalculateFeatureResiduals
									(declare
										(assoc
											compute_low_and_high_mae (false)
											focal_case (null)
											robust_residuals (false)
											num_samples 1000
											store_deviations (false)
											residual_features (null)
											weight_feature ".case_weight"
											custom_hyperparam_map (null)
											features (null)
											case_ids (null)
											use_case_weights (false)
											hyperparameter_feature ".targetless"
											output_ordinal_residuals (false)
											cases_map (null)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)
										)

										;if focal case is specified, ensure that it's not in the provided cases_map since its influence should be ignored
										(if
											(!= (null) focal_case)
											(assign
												(assoc
													cases_map (remove
															cases_map
															focal_case
														)
												)
											)
										)

										;set the passed in one as the hyperparam map to use if specified
										(declare
											(assoc hyperparam_map custom_hyperparam_map)
										)
										(if
											(= (null) hyperparam_map)
											(assign
												(assoc
													hyperparam_map (call
															GetHyperparameters
															(assoc
																weight_feature weight_feature
																feature hyperparameter_feature
																mode (if
																		(!=
																			".targetless"
																			hyperparameter_feature
																		)
																		"full"
																		"robust"
																	)
															)
														)
												)
											)
										)

										;flag set to automatically cache the calculated residuals if being calculated for the whole model
										(declare
											(assoc
												num_training_cases (call
														GetNumTrainingCases
													)
												case_weights (null)
												ordinal_features_map (zip
														ordinalFeatures
													)
												feature_deviations_map (null)
												param_path (get
														hyperparam_map
														"paramPath"
													)
											)
										)

										;if the param_path is for some reason missing, create it here
										(if
											(= (null) param_path)
											(assign
												(assoc
													param_path (list
															hyperparameter_feature
															(if
																robust_residuals
																"robust"

																;mode stays "full" only if it's there in the hyperparameterMetadataMap along with the weight_feature
																(contains_index
																	hyperparameterMetadataMap
																	(list
																		hyperparameter_feature
																		"full"
																		weight_feature
																	)
																)
																"full"

																;defaults back to robust
																"robust"
															)
															weight_feature
														)
												)
											)
										)

										;if features aren't specified, assume all defaultFeatures will need to have their mae calculated
										(if
											(= (null) features)
											(assign
												(assoc
													features defaultFeatures
												)
											)
										)

										;if for some reason expected values haven't been cached, do that here
										(if
											(=
												0
												(size expectedValuesMap)
											)
											(call
												CacheExpectedValuesAndProbabilities
												(assoc
													weight_feature weight_feature
													use_case_weights use_case_weights
													features features
												)
											)
										)

										;if cases_map (assoc of case -> weight) was not specified, select case_ids for computation here
										(if
											(=
												0
												(size cases_map)
											)
											(seq

												;if case_ids weren't specified either, use a random num_samples sampling of cases from the whole model
												(if
													(=
														0
														(size
															case_ids
														)
													)
													(assign
														(assoc
															case_ids
																;if there are more cases than the sample size, randomly select that many cases, by default cases are in random order
																;unless the model is 1000 or less, in which case just train the whole mode
																(if
																	(and
																		(>
																			num_training_cases
																			num_samples
																		)
																		(>
																			num_training_cases
																			1000
																		)
																	)
																	(call
																		AllCases
																		(assoc
																			num num_samples
																			rand_seed (rand)
																		)
																	)

																	;else just use all the case ids because the model size is <= num_samples or the model is small
																	(call
																		AllCases
																	)
																)
														)
													)
												)

												;when calculating residuals for the entire model, cache the heuristic residual values
												;if they haven't been cached yet
												(if
													(!=
														(list)

														;filter out all the features that are already in cachedFeatureMinResidualMap. if any remain,
														;that means we need to cache values, may as well recalculate them all since something in the model probalby changed
														(filter
															(lambda
																(not
																	(contains_index
																		cachedFeatureMinResidualMap
																		(current_value)
																	)
																)
															)
															features
														)
													)
													(seq
														(assign_to_entities
															(assoc
																cachedFeatureMinGapMap (map
																		(lambda
																			(let
																				(assoc
																					smallest_gap
																						;gap is always 1 for nominals
																						(if
																							(contains_index
																								nominalsSet
																								(get_value
																									(current_index
																										1
																									)
																								)
																							)
																							1

																							;else compute the gap
																							(compute_on_contained_entities
																								(list
																									(query_min_difference
																										(current_index
																											2
																										)
																										(get
																											cyclicFeaturesMap
																											(current_index
																												2
																											)
																										)
																									)
																								)
																							)
																						)
																				)

																				;infinity means there was no gap, set value to zero
																				(if
																					(=
																						.infinity
																						smallest_gap
																					)
																					0

																					;nan means that all values are nulls and a gap couldn't be computed, set value to zero
																					(=
																						.nan
																						smallest_gap
																					)
																					0

																					;else set the smallest gap to gap / 2
																					(/
																						smallest_gap
																						2
																					)
																				)
																			)
																		)
																		(zip
																			features
																		)
																	)
															)
														)
														(assign_to_entities
															(assoc
																cachedFeatureMinResidualMap (map
																		(lambda

																			;unique features don't have a residual
																			(if
																				(contains_index
																					uniqueNominalsMap
																					(current_index)
																				)
																				0

																				;else set the residual_value to the smallest theoretical value: gap * 1/2 * 1 / (num_cases + 1)
																				(/
																					(current_value)
																					(+
																						1
																						(size
																							case_ids
																						)
																					)
																				)
																			)
																		)
																		cachedFeatureMinGapMap
																	)
															)
														)
													)
												)
											)

											;else cases were specified via cases_map, calculate the corresponding weights
											(seq

												;ensure there's no sub model size since explicit cases have been provided
												(assign
													(assoc
														sub_model_size (null)
														case_ids (indices
																cases_map
															)
													)
												)

												;if there are exact matches, filter out the cases to just those that are exact matches
												(if
													(contains_value
														cases_map
														.infinity
													)

													;and no need to set case_weights since these are all exact matches, they are weighed evenly
													(assign
														(assoc
															case_ids (filter
																	(lambda
																		(=
																			.infinity
																			(get
																				cases_map
																				(current_value)
																			)
																		)
																	)
																	case_ids
																)
														)
													)

													;else calculate the corresponding weights for each case
													(let
														(assoc
															total_case_weight (apply
																	(lambda
																		(+)
																	)
																	(values
																		cases_map
																	)
																)
														)
														(assign
															(assoc
																case_weights
																	;if there are no weights, don't apply them
																	(if
																		(=
																			0
																			total_case_weight
																		)
																		(null)
																		(map
																			(lambda

																				;normalize the weights
																				(/
																					(get
																						cases_map
																						(current_value)
																					)
																					total_case_weight
																				)
																			)
																			case_ids
																		)
																	)
															)
														)
													)
												)
											)
										)

										;if there are ordinals but the hyperparameter map doesn't have a featureOrdinalDeviations assoc, initialize it
										(if
											(and
												store_deviations
												(size ordinal_features_map)
												(=
													(null)
													(get
														hyperparam_map
														"featureOrdinalDeviations"
													)
												)
											)
											(accum
												(assoc
													hyperparam_map (assoc
															featureOrdinalDeviations (assoc)
														)
												)
											)
										)

										;if storing deviations ensure that featureDeviations is an assoc instead of (null) for correct accumulation
										(if
											(and
												store_deviations
												(=
													(null)
													(get
														hyperparam_map
														"featureDeviations"
													)
												)
											)
											(assign
												(assoc
													hyperparam_map (set
															hyperparam_map
															"featureDeviations"
															(assoc)
														)
												)
											)
										)

										;if calculating and storing or all features, set the allFeatureResidualsCached flag to true
										(if
											(and
												store_deviations
												(=
													(null)
													residual_features
												)
												(=
													(sort
														defaultFeatures
													)
													(sort
														features
													)
												)
											)
											(accum
												(assoc
													hyperparam_map (assoc
															allFeatureResidualsCached (true)
														)
												)
											)
										)

										;create a map whose indices will be used as the context_features, for ease of knocking out a feature to use as the action
										(declare
											(assoc
												features_map (zip
														features
													)
											)
										)

										;the specific features for which to calculate the residuals
										(declare
											(assoc
												deviation_features_map (if
														(=
															(null)
															residual_features
														)
														features_map
														(zip
															residual_features
														)
													)
												ordinal_residuals_map (assoc)
											)
										)

										;since residuals cannot be computed, return the max uncertainty for each feature
										(if
											(< num_training_cases 2)
											(conclude
												(accum
													(assoc
														hyperparam_map (assoc
																featureDeviations (call
																		ComputeMaxResiduals
																		(assoc
																			deviation_features_map deviation_features_map
																		)
																	)
															)
													)
												)
											)
										)

										;iterate over deviation_features_map, calculating every feature's mean absolute error
										(declare
											(assoc
												output_residuals_map ||(map
														(lambda
															(let

																;flag set to true if this feature is nominal
																(assoc
																	feature_is_ordinal (contains_index
																			ordinal_features_map
																			(get_value
																				(current_index
																					1
																				)
																			)
																		)
																	feature (get_value
																			(current_index
																				1
																			)
																		)
																	feature_is_nominal (contains_index
																			nominalsSet
																			(get_value
																				(current_index
																					1
																				)
																			)
																		)
																)
																(declare
																	(assoc
																		residuals_map (call
																				CalculateResidualsOnCasesForFeature
																				(assoc
																					focal_case focal_case
																					robust_residuals robust_residuals
																					feature_is_ordinal feature_is_ordinal
																					weight_feature weight_feature
																					case_weights case_weights
																					feature feature
																					case_ids case_ids
																					use_case_weights use_case_weights
																					feature_is_nominal feature_is_nominal
																					compute_low_and_high_residuals compute_low_and_high_mae
																					hyperparam_map hyperparam_map
																					context_features (indices
																							(remove
																								features_map
																								feature
																							)
																						)
																				)
																			)
																	)
																)
																(declare
																	(assoc
																		case_count (get
																				residuals_map
																				"num_cases"
																			)
																		high_residuals (get
																				residuals_map
																				"high_residuals"
																			)
																		low_residuals (get
																				residuals_map
																				"low_residuals"
																			)
																		nominal_residual_map (get
																				residuals_map
																				"nominal_residual_map"
																			)
																		sum_residuals (get
																				residuals_map
																				"sum_residuals"
																			)
																	)
																)
																(if
																	feature_is_ordinal
																	(accum
																		(assoc
																			ordinal_residuals_map (associate
																					feature
																					(if
																						(=
																							(null)
																							case_weights
																						)
																						(/
																							(get
																								residuals_map
																								"ordinal_residual_sum"
																							)
																							case_count
																						)
																						(get
																							residuals_map
																							"ordinal_residual_sum"
																						)
																					)
																				)
																		)
																	)
																)

																;when low and high mae is needed for nominals, compute the rates instead
																(if
																	(and
																		feature_is_nominal
																		compute_low_and_high_mae
																	)
																	(assign
																		(assoc
																			nominal_residual_map (map
																					(lambda
																						(assoc
																							correct_rate (/
																									(-
																										case_count
																										(+
																											(get
																												(current_value
																													1
																												)
																												"wrong"
																											)
																											(get
																												(current_value
																													1
																												)
																												"false_positive"
																											)
																										)
																									)
																									case_count
																								)
																							false_negative_rate (/
																									(get
																										(current_value
																											1
																										)
																										"wrong"
																									)
																									case_count
																								)
																							false_positive_rate (/
																									(get
																										(current_value
																											1
																										)
																										"false_positive"
																									)
																									case_count
																								)
																						)
																					)
																					nominal_residual_map
																				)
																		)
																	)
																)

																;output the residual (new mean absolute error) for this feature, keeping the max of computed vs user specified
																;vs smallest feature gap
																(declare
																	(assoc
																		feature_is_datetime (and
																				hasDateTimeFeatures
																				(contains_index
																					featureDateTimeMap
																					feature
																				)
																			)
																		residual_value (max
																				(get
																					cachedFeatureMinResidualMap
																					feature
																				)

																				;if there are no case weights, the residual_value is the mean of all residuals, otherwise
																				;it's already a weighted sum of the residuals, and is the residual_value itself
																				(if
																					(=
																						(null)
																						case_weights
																					)
																					(/
																						sum_residuals
																						case_count
																					)
																					sum_residuals
																				)
																				(get
																					userSpecifiedFeatureErrorsMap
																					feature
																				)
																			)
																	)
																)

																;do a live update of the residuals being used for these computes if either user specified a custom hp map or store_deviations is true
																(if
																	(and
																		(!=
																			.nan
																			residual_value
																		)
																		(or
																			store_deviations
																			(!=
																				(null)
																				custom_hyperparam_map
																			)
																		)
																	)
																	(seq

																		;immediatelly update the stored residuals so they can be used in all subsequent queries
																		;Note: for laplace LK metric, use the residual_value as sigma
																		(if
																			(=
																				(null)
																				(get
																					hyperparam_map
																					"featureDeviations"
																				)
																			)

																			;if deviations assoc hasn't been initialized yet, create it as an assoc
																			(assign
																				"hyperparam_map"
																				(list
																					"featureDeviations"
																				)
																				(associate
																					feature
																					residual_value
																				)
																			)

																			;else set the residual value for this feature in the deviations assoc
																			(assign
																				"hyperparam_map"
																				(list
																					"featureDeviations"
																					feature
																				)
																				residual_value
																			)
																		)

																		;store ordinal residual into 'featureOrdinalDeviations
																		(if
																			feature_is_ordinal
																			(assign
																				"hyperparam_map"
																				(list
																					"featureOrdinalDeviations"
																					feature
																				)
																				(get
																					ordinal_residuals_map
																					feature
																				)
																			)
																		)
																	)
																)

																;if computing low and high residual_value, return additional details besides just the residual_value
																(if
																	compute_low_and_high_mae
																	(if
																		feature_is_nominal
																		(assoc
																			mean_absolute_error residual_value
																			nominal_prediction_rates nominal_residual_map
																		)

																		;else return residual_value high and low values
																		(assoc
																			mean_absolute_error (if
																					feature_is_datetime
																					(call
																						DecodeTimeDelta
																						(assoc
																							feature feature
																							feature_value residual_value
																						)
																					)
																					residual_value
																				)
																			mean_absolute_error_high
																				;prevent divide by zero when there's no high residual_value
																				(if
																					(>
																						(size
																							high_residuals
																						)
																						0
																					)
																					(if
																						feature_is_datetime
																						(call
																							DecodeTimeDelta
																							(assoc
																								feature feature
																								feature_value (/
																										(apply
																											"+"
																											high_residuals
																										)
																										(size
																											high_residuals
																										)
																									)
																							)
																						)
																						(if
																							(=
																								(null)
																								case_weights
																							)
																							(/
																								(apply
																									"+"
																									high_residuals
																								)
																								(size
																									high_residuals
																								)
																							)

																							;if there are case weights, the individual high residual values were weighted
																							;thus the high residual is the sum of all the weighted values
																							(apply
																								"+"
																								high_residuals
																							)
																						)
																					)

																					;else no high residual_value
																					0
																				)
																			mean_absolute_error_low
																				;prevent divide by zero when there's no high residual_value
																				(if
																					(>
																						(size
																							low_residuals
																						)
																						0
																					)
																					(if
																						feature_is_datetime
																						(call
																							DecodeTimeDelta
																							(assoc
																								feature feature
																								feature_value (/
																										(apply
																											"+"
																											low_residuals
																										)
																										(size
																											low_residuals
																										)
																									)
																							)
																						)
																						(if
																							(=
																								(null)
																								case_weights
																							)
																							(/
																								(apply
																									"+"
																									low_residuals
																								)
																								(size
																									low_residuals
																								)
																							)

																							;if there are case weights, the individual low residual values were weighted
																							;thus the low residual is the sum of all the weighted values
																							(apply
																								"+"
																								low_residuals
																							)
																						)
																					)

																					;else no low residual_value
																					0
																				)
																		)
																	)

																	;else just return the residual_value for the feature
																	residual_value
																)
															)
														)
														deviation_features_map
													)
											)
										)

										;store deviations to the model at the end
										(if
											store_deviations
											(seq

												;only update hyperparameterMetadataMap if they have no deviations cached or the type of residuals computed matches the hyperparameters
												(if
													(or
														(=
															0
															(size
																(get
																	hyperparameterMetadataMap
																	(append
																		param_path
																		"featureDeviations"
																	)
																)
															)
														)
														(and
															robust_residuals
															(=
																"robust"
																(get
																	param_path
																	1
																)
															)
														)
														(and
															(not
																robust_residuals
															)
															(=
																"full"
																(get
																	param_path
																	1
																)
															)
														)
													)
													(assign_to_entities
														(assoc
															hyperparameterMetadataMap (set
																	hyperparameterMetadataMap
																	param_path
																	hyperparam_map
																)
														)
													)
												)

												;always update the residualsMap
												(assign_to_entities
													(assoc
														residualsMap (set
																residualsMap
																(apply
																	"concat"
																	(append
																		(if
																			robust_residuals
																			"robust"
																			"full"
																		)
																		param_path
																	)
																)
																(append
																	(get
																		hyperparam_map
																		"featureDeviations"
																	)
																	(assoc
																		".robust" (=
																				(true)
																				robust_residuals
																			)
																		".hyperparam_path" param_path
																	)
																)
															)
													)
												)
												(accum_to_entities
													(assoc
														revision 1
													)
												)
											)
										)
										(if
											output_ordinal_residuals
											(list output_residuals_map ordinal_residuals_map)
											output_residuals_map
										)
									)

									;calculate residual values for one feature on a specific set of cases by knocking out one case at a time, using ignore_case in react
									;and reacting to the remaining model, accumulating residual values
									;parameters:
									; feature : the feature for which to calculate residuals
									; feature_is_nominal : flag set if the feature is nominal
									; feature_is_ordinal : flag set if the feature is ordinal
									; context_features: list of context feature names
									; case_ids: list of case ids for which to use in the calculation
									; case_weights: optional list of weights to be applied to the residual for each case
									; focal_case: optional case id of case for which to compute residuals from the specified cases_map and is to be ignored during computation
									; compute_low_and_high_residuals : flag, if set to true will additinally compute the low and high resdiuals
									; robust_residuals: flag, default to false. when true calculates residuals robust with respect to the set of contexts used (across the power set of contexts)
									; hyperparam_map: assoc of hyperparameters to use when calculating residuals
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									##CalculateResidualsOnCasesForFeature
									(declare
										(assoc
											focal_case (null)
											robust_residuals (false)
											feature_is_ordinal (false)
											weight_feature ".case_weight"
											case_weights (null)
											feature (null)
											case_ids (list)
											use_case_weights (false)
											feature_is_nominal (false)
											compute_low_and_high_residuals (false)
											context_features (list)
										)

										;unique nominal features have a residual of 0 because they are all unique and cannot be predicted using LOO
										(if
											(and
												feature_is_nominal
												(contains_index
													uniqueNominalsMap
													feature
												)
											)
											(conclude
												(assoc
													high_residuals 0
													low_residuals 0
													nominal_residual_map 0
													std_residuals 0
													sum_residuals 0
												)
											)
										)
										(declare
											(assoc
												sum_squares_residuals 0
												high_residuals (list)
												num_cases_tested (size
														case_ids
													)
												low_residuals (list)
												ordinal_residual_sum 0
												sum_residuals 0
												action_features (list
														feature
													)
												nominal_residual_map (assoc)
											)
										)

										;if case weights were specified and we're doing robust residuals, we need to expand the case_weights list to match the number of case_ids
										(if
											(and
												robust_residuals
												(size case_weights)
												(!=
													(size
														case_weights
													)
													num_cases_tested
												)
											)
											(let
												(assoc
													case_weights_map (zip
															case_ids
															case_weights
														)
													total_weight 0
												)
												(assign
													(assoc
														case_weights (map
																(lambda
																	(get
																		case_weights_map
																		(current_value)
																	)
																)
																case_ids
															)
													)
												)

												;since total weight now != 1, we need to re-normalize the weights so they add up to 1
												(assign
													(assoc
														total_weight (apply
																"+"
																case_weights
															)
													)
												)
												(assign
													(assoc
														case_weights (map
																(lambda
																	(/
																		(current_value)
																		total_weight
																	)
																)
																case_weights
															)
													)
												)
											)
										)
										(declare
											(assoc
												predictions_list
													;iterate over every sample case, ignore it, react to the action feature and compare output to expected value from the case
													||(map
														(lambda
															(let
																(assoc
																	use_expected_value (false)
																	react_context_features context_features
																	case_id (current_value
																			1
																		)
																	expected_feature_value (null)
																)

																;if robust residuals take a random sample of context features to use as contexts
																(if
																	robust_residuals
																	(seq
																		(assign
																			(assoc
																				react_context_features (filter
																						(lambda
																							(<
																								(rand)
																								0.5
																							)
																						)
																						context_features
																					)
																			)
																		)

																		;if no context features, use expected value for feature
																		(if
																			(=
																				0
																				(size
																					react_context_features
																				)
																			)
																			(assign
																				(assoc
																					use_expected_value (true)
																					expected_feature_value (if
																							feature_is_nominal
																							(assoc
																								action_values (list
																										(call
																											CalculateFeatureExpectedValue
																											(assoc
																												allow_nulls (false)
																												feature feature
																												case_ids case_ids
																											)
																										)
																									)
																							)

																							;else continuous
																							(list
																								(call
																									CalculateFeatureExpectedValue
																									(assoc
																										allow_nulls (false)
																										feature feature
																										case_ids case_ids
																									)
																								)
																							)
																						)
																				)
																			)
																		)
																	)
																)
																(declare
																	(assoc
																		react_values (if
																				use_expected_value
																				expected_feature_value
																				(call
																					ReactDiscriminative
																					(assoc
																						focal_case focal_case
																						ignore_case case_id
																						return_action_values_only (true)
																						details (if
																								feature_is_nominal
																								(assoc
																									ignore_case (null)
																									categorical_action_probabilities (true)
																								)
																								(null)
																							)
																						skip_decoding 1
																						context_values (retrieve_from_entity
																								case_id
																								react_context_features
																							)
																						weight_feature weight_feature
																						has_dependent_features (false)
																						use_case_weights use_case_weights
																						substitute_output (false)
																						action_features action_features
																						hyperparam_map hyperparam_map
																						skip_encoding 1
																						context_features react_context_features
																					)
																				)
																			)
																		expected_values (retrieve_from_entity
																				case_id
																				action_features
																			)
																	)
																)

																;output as a tuple
																(list
																	react_values
																	use_expected_value
																	expected_values
																)
															)
														)

														;iterate over these cases
														case_ids
													)
											)
										)

										;process the predictions and compute the residual for the feature
										(map
											(lambda
												(let
													(assoc
														react_values (first
																(current_value
																	1
																)
															)
														use_expected_value (get
																(current_value
																	1
																)
																1
															)
														expected_values (last
																(current_value
																	1
																)
															)
													)

													;if the case being compared to has a null for a value, skip it and decrease the count of cases tested
													(if
														(=
															(list
																(null)
															)
															expected_values
														)
														(accum
															(assoc
																num_cases_tested -1
															)
														)

														;if action feature is nominal, diff is (1 - categorical_action_probability), meaning diff will be 0 if the probability is 1
														(let
															(assoc
																diff (if
																		feature_is_nominal

																		;if using expected values, the diff for nominals is 1 - model nominal class probability
																		(if
																			use_expected_value
																			(-
																				1
																				(get
																					(call
																						ComputeModelNominalClassProbabilities
																						(assoc
																							feature feature
																							case_ids case_ids
																						)
																					)
																					(first
																						expected_values
																					)
																				)
																			)
																			(-
																				1
																				(get
																					react_values
																					(list
																						"categorical_action_probabilities"
																						feature
																						(first
																							expected_values
																						)
																					)
																				)
																			)
																		)

																		;else just take the absolute diff of the actual values
																		(abs
																			(-
																				(first
																					expected_values
																				)
																				(first
																					react_values
																				)
																			)
																		)
																	)
															)

															;if diff is nan, there was a (null) in the above calculation
															(if
																(=
																	.nan
																	diff
																)

																;for nominals if the prediction isn't null but the expected nominal class is not in the categorical action probabilities
																;set diff to the max value of 1
																(if
																	(and
																		feature_is_nominal
																		(!=
																			(null)
																			(get
																				react_values
																				(list
																					"action_values"
																					0
																				)
																			)
																		)
																	)
																	(assign
																		(assoc
																			diff 1
																		)
																	)

																	;else, the reaction is (null), which can happen when we allow nulls, skip this case
																	(seq
																		(accum
																			(assoc
																				num_cases_tested -1
																			)
																		)
																		(conclude)
																	)
																)
															)
															(if
																feature_is_ordinal
																(seq
																	(assign
																		(assoc
																			ordinal_diff (/
																					diff
																					(get
																						ordinalFeaturesRangesMap
																						feature
																					)
																				)
																		)
																	)
																	(if
																		(!=
																			(null)
																			case_weights
																		)
																		(assign
																			(assoc
																				ordinal_diff (*
																						ordinal_diff
																						(get
																							case_weights
																							(current_index
																								1
																							)
																						)
																					)
																			)
																		)
																	)
																	(if
																		(!=
																			.nan
																			ordinal_diff
																		)
																		(accum
																			(assoc
																				ordinal_residual_sum ordinal_diff
																			)
																		)
																	)
																)
															)

															;if case weights are specified, modify the difference to the prediction by the corresponding weight for the case
															(if
																(!=
																	(null)
																	case_weights
																)
																(assign
																	(assoc
																		diff (*
																				diff
																				(get
																					case_weights
																					(current_index
																						1
																					)
																				)
																			)
																	)
																)
															)
															(accum
																(assoc
																	sum_squares_residuals (*
																			diff
																			diff
																		)
																	sum_residuals diff
																)
															)

															;compute matrix of counts for nominal features only if computing low and high mae
															(if
																feature_is_nominal
																(if
																	compute_low_and_high_residuals
																	(declare

																		;convert from raw nominal enum values back to human-friendly nominal value
																		(assoc
																			react_value (first
																					(get
																						react_values
																						"action_values"
																					)
																				)
																			expected_value (first
																					expected_values
																				)
																		)
																		(if
																			(and
																				hasSubstituteFeatureValues
																				substitute_output
																				(contains_index
																					substitutionValueMap
																					feature
																				)
																			)
																			(assign
																				(assoc
																					react_value (first
																							(call
																								SubstituteFeatureValues
																								(assoc
																									feature_values (list
																											react_value
																										)
																									features (list
																											feature
																										)
																								)
																							)
																						)
																					expected_value (first
																							(call
																								SubstituteFeatureValues
																								(assoc
																									feature_values (list
																											expected_value
																										)
																									features (list
																											feature
																										)
																								)
																							)
																						)
																				)
																			)
																		)
																		(if
																			(=
																				react_value
																				expected_value
																			)

																			;if the map doesn't have this nominal value in it, store it into the map
																			(if
																				(=
																					(null)
																					(get
																						nominal_residual_map
																						expected_value
																					)
																				)
																				(accum
																					(assoc
																						nominal_residual_map (associate
																								expected_value
																								(assoc
																									correct 1
																									wrong 0
																									false_positive 0
																								)
																							)
																					)
																				)

																				;else value is in the map, increase the 'correct' count for this nominal value
																				(accum
																					"nominal_residual_map"
																					(list
																						expected_value
																						"correct"
																					)
																					1
																				)
																			)

																			;else got prediction ... wrong! increase 'wrong' count and 'false_positive' count
																			(seq

																				;if the map doesn't have this expected nominal value in it, store it into the map
																				(if
																					(=
																						(null)
																						(get
																							nominal_residual_map
																							expected_value
																						)
																					)
																					(accum
																						(assoc
																							nominal_residual_map (associate
																									expected_value
																									(assoc
																										correct 0
																										wrong 1
																										false_positive 0
																									)
																								)
																						)
																					)

																					;else value is in the map, so just increase the 'wrong' count
																					(accum
																						"nominal_residual_map"
																						(list
																							expected_value
																							"wrong"
																						)
																						1
																					)
																				)

																				;if the map doesn't have this prediction nominal value in it, store it into the map
																				(if
																					(=
																						(null)
																						(get
																							nominal_residual_map
																							react_value
																						)
																					)
																					(accum
																						(assoc
																							nominal_residual_map (associate
																									react_value
																									(assoc
																										correct 0
																										wrong 0
																										false_positive 1
																									)
																								)
																						)
																					)

																					;else value is in the map, so just increase the 'false_positive' count
																					(accum
																						"nominal_residual_map"
																						(list
																							react_value
																							"false_positive"
																						)
																						1
																					)
																				)
																			)
																		)
																	)
																)

																;else does not have nominals,
																;compute low and high mae for non-nominals only if there is an error
																(if
																	(and
																		compute_low_and_high_residuals
																		(!=
																			diff
																			0
																		)
																	)
																	(if
																		(>
																			(first
																				react_values
																			)
																			(first
																				expected_values
																			)
																		)
																		(accum
																			(assoc
																				high_residuals diff
																			)
																		)
																		(accum
																			(assoc
																				low_residuals diff
																			)
																		)
																	)
																)
															)
														)
													)
												)
											)
											predictions_list
										)

										;return the assoc with the calculated values
										(assoc
											num_cases num_cases_tested
											high_residuals high_residuals
											low_residuals low_residuals
											ordinal_residual_sum ordinal_residual_sum
											nominal_residual_map nominal_residual_map
											std_residuals (sqrt
													(/
														sum_squares_residuals
														num_cases_tested
													)
												)
											sum_residuals sum_residuals
										)
									)

									;calculate the decrease in accuracy for the specified list of context and action features
									;outputs an assoc of context features -> decrease in accuracy Mean Absolute Error value
									; if output_ratio, the ratio is: feature_mae / baseline_mae
									; else:  feature_mae - baseline_mae
									;
									;parameters:
									; action_features : list of action features
									; context_features : list of context features
									; case_ids : optional list of case_ids, will use the full model if not provided, otherwise will validate against only the specified case_ids
									; sensitivity_to_randomization: optional flag. if set to true will scramble feature values being reacted to instead of dropping out the feature
									; output_ratio : optional flag, if set to true will output of ratio of Feature-error / model-error
									; classification_precision: 0=low, 1=medium, 2=high. low uses 1 or 0 for residuals. medium uses categorical action probability for incorrect
									;			predictions, high uses categorical action probabilities for both correct and incorrect predictions
									; num_samples: run decrease in accuracy only a specified sample of the model, default is 1000
									; robust: flag, default to false. when true, the power set/permutations of features are used as contexts
									;			to calculate the decrease in accuracy for a given feature. when false, the full set of features is used to calculate the
									;			decrease in accuracy for a given feature.
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									##DecreaseInAccuracy
									(declare
										(assoc
											classification_precision 1
											num_samples 1000
											robust (false)
											weight_feature ".case_weight"
											case_ids (null)
											use_case_weights (false)
											action_features (list)
											hyperparam_map (null)
											output_ratio (false)
											sensitivity_to_randomization (false)
											context_features (list)
										)
										(if
											(= (null) hyperparam_map)
											(assign
												(assoc
													hyperparam_map (if
															(=
																1
																(size
																	action_features
																)
															)
															(call
																GetHyperparameters
																(assoc
																	weight_feature weight_feature
																	feature (first
																			action_features
																		)
																	mode "full"
																)
															)
														)
												)
											)
										)
										(declare
											(assoc
												context_features_mda (zip
														context_features
													)
											)
										)

										;if case_ids were not explicitly specified but num_samples was, we're computing global MDA, randomly sample case_ids to be the num_samples
										(if
											(and
												(!=
													(null)
													num_samples
												)
												(=
													(null)
													case_ids
												)
											)
											(assign
												(assoc
													case_ids (call
															SampleCases
															(assoc
																num num_samples
															)
														)
												)
											)
										)
										(declare
											(assoc
												baseline_error (call
														CalculateModelMAE
														(assoc
															classification_precision classification_precision
															robust_residuals robust
															weight_feature weight_feature
															custom_hyperparam_map hyperparam_map
															case_ids case_ids
															use_case_weights use_case_weights
															action_features action_features
															ignore_exact_cases (true)
															context_features context_features
														)
													)
											)
										)
										(declare
											(assoc
												output
													;knock out each feature one by one and calculate the decrease in accuracy for each feature
													(zip
														context_features
														(map
															(lambda
																(let
																	(assoc
																		mae_context_features context_features
																	)

																	;regular Decrease in accuracy is feature knockout instead of scrambling the feature
																	(if
																		(not
																			sensitivity_to_randomization
																		)

																		;remove the feature
																		(assign
																			(assoc
																				mae_context_features (indices
																						(remove
																							context_features_mda
																							(current_value
																								1
																							)
																						)
																					)
																			)
																		)
																	)
																	(let
																		(assoc
																			feature_mda (call
																					CalculateModelMAE
																					(assoc
																						classification_precision classification_precision
																						robust_residuals robust
																						weight_feature weight_feature
																						custom_hyperparam_map hyperparam_map
																						scramble_feature_index (if
																								sensitivity_to_randomization
																								(current_index
																									2
																								)
																								(null)
																							)
																						case_ids case_ids
																						use_case_weights use_case_weights
																						action_features action_features
																						ignore_exact_cases (true)
																						context_features mae_context_features
																					)
																				)
																		)

																		;output the decrease in accuracy as a ratio of the feature / baseline MAE
																		(if
																			output_ratio

																			;prevent output of .nan in case all maes are 0
																			(if
																				(=
																					0
																					baseline_error
																				)
																				.infinity
																				(/
																					feature_mda
																					baseline_error
																				)
																			)

																			;else output the difference in the MAE
																			(-
																				feature_mda
																				baseline_error
																			)
																		)
																	)
																)
															)
															context_features
														)
													)
											)
										)
										output
									)

									;calculates the model Mean Absolute Error (MAE) using one-by-one case knockout, validating against each knockout out case
									;using the specified parameters and returns the total geometric mean of the MAE
									;if a scramble feature index is specified, will scramble the specified feature values being reacted to instead of knocking the feature it out
									;this is done so that the model doesn't need to be retrain and shows how sensitive is the feature to randomized input
									;parameters:
									; action_features : list of action features
									; context_features : list of context features
									; p_param_categorical_mean : optional, default to 1. used to calculate the mean of all MAEs for categorical feature values for a feature
									; case_ids : optional list of case_ids, will use the full model if not provided, otherwise will validate against only the specified case_ids
									; cases_already_removed : optional flag, if set to true, will assume the passed in case_ids are already in a temp entity/removed from the model
									; scramble_feature_index : optional index of the context feature that should be scrambled. if unspecified will use feature knockout
									; classification_precision: 0=low, 1=medium, 2=high. low uses 1 or 0 for residuals. medium uses categorical action probability for incorrect
									;			predictions, high uses categorical action probabilities for both correct and incorrect predictions
									; ignore_exact_cases: flag, if set to true will call ReactDiscriminative with the case ids so that perfect matches will be ignored
									; robust_residuals: flag, default to false. when true calculates residuals robust with respect to the set of contexts used (across the power set of contexts)
									; custom_hyperparam_map: optional assoc of hyperparameters to use (instead of system-determined ones) when calculating MAE
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									##CalculateModelMAE
									(declare
										(assoc
											p_param_categorical_mean 1
											classification_precision 1
											robust_residuals (false)
											cases_already_removed (false)
											weight_feature ".case_weight"
											custom_hyperparam_map (null)
											scramble_feature_index (null)
											case_ids (null)
											use_case_weights (false)
											action_features (list)
											p_param_accuracy_mean 0.2
											ignore_exact_cases (false)
											context_features (list)
										)
										(declare
											(assoc
												num_cases (if
														(=
															(null)
															case_ids
														)
														(call
															GetNumTrainingCases
														)
														(size
															case_ids
														)
													)
												scrambled_feature_data (null)
												action_feature_indices
													;remove all unique features for targetless MAE calculation since uniques can't be predicted and don't have an MAE
													(if
														(and
															targetless
															(>
																(size
																	uniqueNominalsMap
																)
																0
															)
														)
														(filter
															(lambda

																;leave only action features that are not unique
																(not
																	(contains_index
																		uniqueNominalsMap
																		(get
																			action_features
																			(current_value)
																		)
																	)
																)
															)
															(indices
																action_features
															)
														)
														(indices
															action_features
														)
													)
											)
										)

										;scramble the specified feature as necessary
										(if
											(!= (null) scramble_feature_index)
											(let
												(assoc
													scramble_feature (get
															context_features
															scramble_feature_index
														)
												)

												;scramble the feature data by pulling the feature value out of a randomized case list
												(assign
													(assoc
														scrambled_feature_data (map
																(lambda
																	(retrieve_from_entity
																		(current_value)
																		scramble_feature
																	)
																)
																(unzip
																	(if
																		(=
																			(null)
																			case_ids
																		)
																		(call
																			AllCases
																		)
																		case_ids
																	)
																	(rand
																		(range
																			0
																			(-
																				num_cases
																				1
																			)
																		)
																		num_cases
																		(true)
																	)
																)
															)
													)
												)
											)
										)
										(declare
											(assoc
												targetless_cases_per_feature 0
												action_feature_maes (map
														(lambda
															(if
																(contains_index
																	nominalsSet
																	(get
																		action_features
																		(current_value)
																	)
																)
																(assoc
																	num_incorrect_map (assoc)
																	num_total_map (assoc)
																)
																0
															)
														)
														action_feature_indices
													)
												action_feature_counts_map (map
														(lambda
															0
														)
														action_feature_indices
													)
											)
										)

										;for targetless flow, if the dataset size is at least 5x the number of features, calculate how many cases should be used to predict each
										;action feature
										(if
											targetless
											(if
												(>=
													num_cases
													(*
														5
														(size
															action_feature_indices
														)
													)
												)
												(assign
													(assoc
														targetless_cases_per_feature (/
																num_cases
																(size
																	action_feature_indices
																)
															)
													)
												)
											)
										)

										;iterate over the cases and store all the predictions and expected values so that they can be processed afterwards
										(declare
											(assoc
												predictions_list ||(map
														(lambda
															(let
																(assoc
																	react_context_features context_features
																	case_index (current_index
																			1
																		)
																	react_action_features action_features
																	case_id (current_value
																			1
																		)
																	corresponding_context_values (list)
																)
																(assign
																	(assoc
																		corresponding_context_values (if
																				(=
																					(null)
																					scramble_feature_index
																				)

																				;if case was already removed, pull the values from its temp storage, othrewise pull the values directly from the case
																				(retrieve_from_entity
																					(if
																						cases_already_removed
																						(list
																							"_temp_"
																							case_id
																						)
																						case_id
																					)
																					react_context_features
																				)

																				;else scramble set the feature value to a scrambled value
																				(set
																					(retrieve_from_entity
																						case_id
																						react_context_features
																					)
																					scramble_feature_index
																					(get
																						scrambled_feature_data
																						case_index
																					)
																				)
																			)
																	)
																)

																;when doing targetless optimization, for each case, randomly pick a feature to react to, set it as the action feature
																;and set all other features as context features.  also store the context features corresponding nominal flags and values
																(if
																	targetless
																	(let
																		(assoc
																			rand_index (if
																					targetless_cases_per_feature

																					;select the action feature index based on how many cases have been processed so that an equal
																					;number of cases are used to predict any action feature
																					(floor
																						(/
																							case_index
																							targetless_cases_per_feature
																						)
																					)

																					;else select random action feature
																					(rand
																						action_feature_indices
																					)
																				)
																		)
																		(assign
																			(assoc
																				react_context_features (remove
																						react_action_features
																						rand_index
																					)
																				corresponding_context_values (remove
																						corresponding_context_values
																						rand_index
																					)
																			)
																		)
																		(assign
																			(assoc
																				react_action_features (list
																						(get
																							react_action_features
																							rand_index
																						)
																					)
																			)
																		)
																	)
																)

																;if using robust residuals flow, randomly pick context features instead of using all of them
																(if
																	robust_residuals
																	(let
																		(assoc
																			context_feature_indices_map (zip
																					(filter
																						(lambda
																							(<
																								(rand)
																								0.5
																							)
																						)
																						(indices
																							react_context_features
																						)
																					)
																				)
																		)
																		(if
																			(!=
																				0
																				(size
																					context_feature_indices_map
																				)
																			)
																			(assign
																				(assoc
																					react_context_features (filter
																							(lambda
																								(contains_index
																									context_feature_indices_map
																									(get_value
																										(current_index)
																									)
																								)
																							)
																							react_context_features
																						)
																					corresponding_context_values (filter
																							(lambda
																								(contains_index
																									context_feature_indices_map
																									(get_value
																										(current_index)
																									)
																								)
																							)
																							corresponding_context_values
																						)
																				)
																			)
																		)
																	)
																)
																(declare
																	(assoc
																		expected_values (retrieve_from_entity
																				(if
																					cases_already_removed
																					(list
																						"_temp_"
																						case_id
																					)
																					case_id
																				)
																				react_action_features
																			)
																		reaction_values (call
																				ReactDiscriminative
																				(assoc
																					ignore_case (if
																							ignore_exact_cases
																							case_id
																							(null)
																						)
																					return_action_values_only (true)
																					details (assoc
																							ignore_case (null)
																							categorical_action_probabilities (true)
																						)
																					skip_decoding 1
																					context_values corresponding_context_values
																					weight_feature weight_feature
																					has_dependent_features (false)
																					use_case_weights use_case_weights
																					substitute_output (false)
																					action_features react_action_features
																					hyperparam_map custom_hyperparam_map
																					skip_encoding 1
																					context_features react_context_features
																				)
																			)
																	)
																)
																(if
																	(contains_value
																		expected_values
																		(null)
																	)
																	(null)

																	;output as a tuple
																	(list
																		reaction_values
																		react_action_features
																		expected_values
																	)
																)
															)
														)

														;iterate over all cases if the specific list of cases to iterate over was not specified
														(if
															(=
																(null)
																case_ids
															)
															(call
																AllCases
																(assoc
																	num num_cases
																	rand_seed (rand)
																)
															)

															;else use the specified case_ids, shuffled randomly in place
															(rand
																case_ids
																(size
																	case_ids
																)
																(true)
															)
														)
													)
											)
										)

										;iterate over the prediction pairs and accumulate/compute the errors
										(map
											(lambda
												(let
													(assoc
														prediction_tuple (current_value
																1
															)
													)
													(if
														(=
															(null)
															prediction_tuple
														)

														;if the case being compared to has a null for a feature value, skip it and decrease the count of cases tested
														(accum
															(assoc
																num_cases -1
															)
														)

														;else process the prediction
														(let
															(assoc
																react_action_features (get
																		prediction_tuple
																		1
																	)
																expected_values (last
																		prediction_tuple
																	)
																reaction_values (first
																		prediction_tuple
																	)
															)

															;accumulate errors into a list matching each action feature:
															;for continous features the values in the list will have the summed up error value
															;for categorical features the values in the list will have an assoc of total and incorrect counts for each feature value
															(assign
																(assoc
																	action_feature_maes
																		;iterate over the list all action features, accumulating errors for each one
																		;the list of action_feature_maes is size of all the action features
																		(map
																			(lambda

																				;if targetless optimization, reacting to only one action feature, action_features is of size 1 (index=0),
																				;therefore we skip over all the other action features, and only store the mae for that action feature
																				;otherwise pull the action value for each action feature as their index matches the index of each action
																				;feature's accumulated error
																				(if
																					(or
																						(not
																							targetless
																						)
																						(=
																							(get
																								action_features
																								(get
																									action_feature_indices
																									(current_index)
																								)
																							)
																							(first
																								react_action_features
																							)
																						)
																					)
																					(seq

																						;targetless optimization deals with one action feature at a time, set index to be 0
																						(assign
																							(assoc
																								index (if
																										targetless
																										0
																										(get_value
																											(current_index
																												1
																											)
																										)
																									)
																							)
																						)

																						;if this is a nominal feature, do balanced accuracy check:
																						;add up total encountered and total incorrect for every feature value
																						;this will provide an mae for each classification feature value
																						;the maes of all the feature values will be averaged out later to provide the mae of feature as a whole
																						(if
																							(contains_index
																								nominalsSet
																								(get
																									react_action_features
																									index
																								)
																							)
																							(let
																								(assoc
																									num_incorrect_map (get
																											(current_value
																												1
																											)
																											"num_incorrect_map"
																										)
																									probability_correct
																										;or statement converts nulls to false/0
																										(or
																											(get
																												reaction_values
																												(list
																													"categorical_action_probabilities"
																													(get
																														react_action_features
																														index
																													)
																													(get
																														expected_values
																														index
																													)
																												)
																											)
																										)
																									prediction_correct (+
																											(=
																												(get
																													expected_values
																													index
																												)
																												(get
																													reaction_values
																													(list
																														"action_values"
																														index
																													)
																												)
																											)
																										)
																									expected_value (get
																											expected_values
																											index
																										)
																									num_total_map (get
																											(current_value
																												1
																											)
																											"num_total_map"
																										)
																								)

																								;increase the count of total wrong predictions for this feature value if the values don't match
																								(accum
																									(assoc
																										num_incorrect_map (associate
																												expected_value
																												(+
																													(if
																														classification_precision

																														;for incorrect predictions or if using high classification precision
																														;use (1 - categorical_action_probability) of the correct answer such that
																														;if probability is 0, it's same as increasing the incorrect count by 1
																														(if
																															(or
																																(not
																																	prediction_correct
																																)
																																(=
																																	2
																																	classification_precision
																																)
																															)
																															(-
																																1
																																probability_correct
																															)
																															0
																														)

																														;else this is low precision, use either 0 or 1 for residual value
																														(if
																															prediction_correct
																															0

																															;else just increase the count by one if incorrect
																															1
																														)
																													)
																													(or
																														(get
																															num_incorrect_map
																															expected_value
																														)
																													)
																												)
																											)
																									)
																								)

																								;increase the total count this feature value has been encountered
																								(accum
																									"num_total_map"
																									(list
																										expected_value
																									)
																									1
																								)

																								;output the assoc of updated counts of incorrect and total for each feature value
																								(assoc
																									num_incorrect_map num_incorrect_map
																									num_total_map num_total_map
																								)
																							)

																							;else this is a continuous feature, add the difference to the total
																							(seq

																								;targetless optimization deals with one action feature at a time, set index to be 0
																								(if
																									targetless
																									(assign
																										(assoc
																											action_feature_counts_map (set
																													action_feature_counts_map
																													(first
																														react_action_features
																													)
																													(+
																														1
																														(get
																															action_feature_counts_map
																															(first
																																react_action_features
																															)
																														)
																													)
																												)
																											index 0
																										)
																									)
																								)
																								(+
																									(current_value)
																									(abs
																										(-
																											(get
																												expected_values
																												index
																											)
																											(get
																												reaction_values
																												(list
																													"action_values"
																													index
																												)
																											)
																										)
																									)
																								)
																							)
																						)
																					)

																					;else doing targetless optimization and this feature wasn't reacted to, keep the value as-is
																					(current_value)
																				)
																			)
																			action_feature_maes
																		)
																)
															)
														)
													)
												)
											)

											;iterate over all predictions
											predictions_list
										)

										;calculate the mean of each of the accumulated error values
										(assign
											(assoc
												action_feature_maes (map
														(lambda
															(let
																(assoc
																	feature (get
																			action_features
																			(get
																				action_feature_indices
																				(current_index
																					1
																				)
																			)
																		)
																	mae_value (current_value
																			1
																		)
																)

																;if nominal, the MAE is the average of all the incorrect/total counts for all the feature values
																(if
																	(contains_index
																		nominalsSet
																		feature
																	)
																	(let
																		(assoc
																			maes_for_each_categorical_value
																				;iterate over each feature value and calculate its mae
																				(map
																					(lambda
																						(/
																							(get
																								mae_value
																								(list
																									"num_incorrect_map"
																									(current_value
																										1
																									)
																								)
																							)
																							(get
																								mae_value
																								(list
																									"num_total_map"
																									(current_value
																										1
																									)
																								)
																							)
																						)
																					)
																					(indices
																						(get
																							mae_value
																							"num_total_map"
																						)
																					)
																				)
																		)

																		;output the average of the mae for each of the categorical values as the mae for this categorical feature
																		; use 1 / num categories with distance to compute average
																		(generalized_distance
																			(/
																				1
																				(size
																					maes_for_each_categorical_value
																				)
																			)
																			(null)
																			(null)
																			(null)
																			p_param_categorical_mean
																			maes_for_each_categorical_value
																		)
																	)

																	;else continuous, take the mean of the summed errors
																	(if
																		targetless

																		;if targetless, each feature has its own count
																		(/
																			mae_value
																			(get
																				action_feature_counts_map
																				feature
																			)
																		)

																		;targeted count matches the number of cases
																		(/
																			mae_value
																			num_cases
																		)
																	)
																)
															)
														)
														action_feature_maes
													)
											)
										)

										;output a 'mean' of all the maes for all the features. using a P of 0.1 is somewhere between 0(geometric) and 1(arithmetic)
										;and provides a somewhat balanced mean, even for features with large mae values
										(generalized_distance
											(null)
											(null)
											(null)
											(null)
											p_param_accuracy_mean
											action_feature_maes
										)
									)

									;Wrapper method for computing regional model residuals that doesn't run the full method if the regional model is only of size 1.
									;Computes regional residuals for all 'residual_features' provided a 'regional_model_cases_map' and 'features' to use as contexts.
									;returns an assoc of feature -> residual values for each feature in 'residual_features'
									##ComputeRegionalResiduals
									(if
										(=
											1
											(size regional_model_cases_map)
										)

										;if regional model is of size of 1, residual cannot be calculated, therefore for continuous features
										;set the residual to: boundary_max - boundary_min (if boundaries are specified)
										(map
											(lambda
												(let
													(assoc
														feature (current_index)
													)
													(declare
														(assoc
															boundaries_tuple (call
																	ConstrainBoundariesForFeature
																	(assoc
																		feature feature
																		is_datetime (and
																				hasDateTimeFeatures
																				(contains_index
																					featureDateTimeMap
																					feature
																				)
																			)
																		cycle_length cycle_length
																		bounds_map (get
																				feature_bounds_map
																				feature
																			)
																	)
																)
														)
													)

													;residual is: feature range / 4 to average out residual in each direction
													;if a boundary value is not specified, residual is unknown, set it to 0
													(if
														(contains_value
															boundaries_tuple
															(null)
														)
														0

														;for cyclics with exclusionary bounds where the min is larger than the max,
														;e.g., to allow +/- 60 degrees, boundary_min=300, boundary_max=60
														;therefore the range is: boundary_max + (cycle_length - boundary_min)
														(and
															cycle_length
															(>
																(first
																	boundaries_tuple
																)
																(last
																	boundaries_tuple
																)
															)
														)
														(/
															(+
																(last
																	boundaries_tuple
																)
																(-
																	cycle_length
																	(first
																		boundaries_tuple
																	)
																)
															)
															4
														)

														;else residual is simply the range: (boundary_max - boundary_min)
														(/
															(-
																(last
																	boundaries_tuple
																)
																(first
																	boundaries_tuple
																)
															)
															4
														)
													)
												)
											)
											(zip residual_features)
										)

										;else return the regional residuals for all the provided features
										(call
											CalculateFeatureResiduals
											(assoc
												focal_case ignore_case
												robust_residuals (false)
												residual_features residual_features
												weight_feature weight_feature
												features features
												use_case_weights use_case_weights
												hyperparameter_feature (if
														(=
															1
															(size
																feature
															)
														)
														feature
														".targetless"
													)
												output_ordinal_residuals output_ordinal_residuals
												cases_map regional_model_cases_map
											)
										)
									)

									;returns cached feature residuals in the format of assoc feature -> residual value
									;parameters are optional, when not specified will auto-select a cached Residuals set for output, when specified will attempt to
									;output the cached residuals best matching the requested parameters, null if none match.
									;
									;parameters:
									; robust: flag, optional. if specified will attempt to return residuals that were computed with the specified robust or non-robust type.
									; action_feature: string, optional. if specified will attempt to return residuals that were computed for this specified action_feature.
									;				  Note: ".targetless" is the action feature used during targetless optimization.
									; robust_hyperparameters: flag, optional. if true, will attempt to return residuals that were computed using hyperpparameters with the
									;						  specified robust or non-robust type.
									; weight_feature: string, optional. if specified, will attempt to return residuals that were computed using this weight_feature.
									##GetFeatureResiduals
									(declare
										(assoc
											robust (null)
											weight_feature (null)
											robust_hyperparameters (null)
											action_feature (null)
										)
										(if
											(=
												(null)
												robust
												action_feature
												robust_hyperparameters
												weight_feature
											)

											;if only one residuals set has been computed, return it
											(if
												(=
													1
													(size
														residualsMap
													)
												)
												(remove
													(first
														(values
															residualsMap
														)
													)
													(list
														".hyperparam_path"
														".robust"
													)
												)

												;there are several cached residuals, pick one 'smartly':
												(remove
													(call
														!AutoSelectResiduals
													)
													(list
														".hyperparam_path"
														".robust"
													)
												)
											)

											;else user specified parameters, try to find the matching one
											(call !SelectResiduals)
										)
									)

									;Helper method for GetFeatureResiduals, attempts to find a Residuals set from the cached residualsMap that matches any of the
									;optionaly specified user parameters of robust, action_feature robust_hyperparameters and/or weight_feature
									##!SelectResiduals
									(let
										(assoc
											filtered_residuals_map (retrieve_from_entity "residualsMap")
										)

										;leave only those matching specified robust flag
										(if
											(!= (null) robust)
											(assign
												(assoc
													filtered_residuals_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		".robust"
																	)
																	robust
																)
															)
															filtered_residuals_map
														)
												)
											)
										)

										;leave only those matching specified action_feature
										(if
											(!= (null) action_feature)
											(assign
												(assoc
													filtered_residuals_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		(list
																			".hyperparam_path"
																			0
																		)
																	)
																	action_feature
																)
															)
															filtered_residuals_map
														)
												)
											)
										)

										;leave only those matching specified robust_hyperparameters
										(if
											(!= (null) robust_hyperparameters)
											(assign
												(assoc
													filtered_residuals_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		(list
																			".hyperparam_path"
																			1
																		)
																	)
																	robust_hyperparameters
																)
															)
															filtered_residuals_map
														)
												)
											)
										)

										;leave only those matching specified weight_feature
										(if
											(!= (null) weight_feature)
											(assign
												(assoc
													filtered_residuals_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		(list
																			".hyperparam_path"
																			2
																		)
																	)
																	weight_feature
																)
															)
															filtered_residuals_map
														)
												)
											)
										)
										(if
											(=
												0
												(size filtered_residuals_map)
											)
											(conclude (null))
											(=
												1
												(size filtered_features_map)
											)
											(conclude
												(remove
													(first
														(values
															filtered_residuals_map
														)
													)
													(list
														".hyperparam_path"
														".robust"
													)
												)
											)
										)

										;else if there are still multiple choices and user didn't select action_feature, attempt to output .targetless residuals
										(if
											(= (null) action_feature)
											(let
												(assoc
													backup_map filtered_residuals_map
												)
												(assign
													(assoc
														filtered_residuals_map (filter
																(lambda
																	(=
																		(get
																			(current_value)
																			(list
																				".hyperparam_path"
																				0
																			)
																		)
																		".targetless"
																	)
																)
																filtered_residuals_map
															)
													)
												)

												;revert if we filtered out all residuals
												(if
													(=
														0
														filtered_residuals_map
													)
													(assign
														(assoc
															filtered_residuals_map backup_map
														)
													)
												)
											)
										)

										;user did not specify weight_feature but there are multiple weight features cached, filter out non default weight_features
										(if
											(and
												(=
													(null)
													weight_feature
												)
												(>
													(size
														filtered_mda_map
													)
													1
												)
											)
											(let
												(assoc
													backup_map filtered_residuals_map
												)
												(assign
													(assoc
														filtered_residuals_map (filter
																(lambda
																	(=
																		(get
																			(current_value)
																			(list
																				".hyperparam_path"
																				2
																			)
																		)
																		".none"
																	)
																)
																filtered_residuals_map
															)
													)
												)

												;revert if all residuals were filtered out
												(if
													(=
														0
														(size
															filtered_residuals_map
														)
													)
													(assign
														(assoc
															filtered_residuals_map backup_map
														)
													)
												)
											)
										)

										;at this point output the first one, whatever it happens to be
										(remove
											(first
												(values filtered_residuals_map)
											)
											(list ".hyperparam_path" ".robust")
										)
									)

									;Helper method for GetFeatureResiduals, attempts to find the most appropriate Residuals set from the cached residualsMap
									##!AutoSelectResiduals
									(let
										(assoc
											filtered_residuals_map (assoc)
											residuals_map (retrieve_from_entity "residualsMap")
										)

										;leave only ".targetless"
										(assign
											(assoc
												filtered_residuals_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	(list
																		".hyperparam_path"
																		0
																	)
																)
																".targetless"
															)
														)
														residuals_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_residuals_map)
											)
											(conclude
												(first
													(values
														filtered_residuals_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_residuals_map)
											)
											(assign
												(assoc
													filtered_residuals_map residuals_map
												)
											)

											;else backup the filtered residuals map for further filtering below
											(assign
												(assoc
													residuals_map filtered_residuals_map
												)
											)
										)

										;leave only 'robust' residuals
										(assign
											(assoc
												filtered_residuals_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	".robust"
																)
																(true)
															)
														)
														filtered_residuals_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_residuals_map)
											)
											(conclude
												(first
													(values
														filtered_residuals_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_residuals_map)
											)
											(assign
												(assoc
													filtered_residuals_map residuals_map
												)
											)

											;else backup the filtered residuals map for further filtering below
											(assign
												(assoc
													residuals_map filtered_residuals_map
												)
											)
										)

										;leave only 'robust' hyperparam residuals
										(assign
											(assoc
												filtered_residuals_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	(list
																		".hyperparam_path"
																		1
																	)
																)
																"robust"
															)
														)
														filtered_residuals_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_residuals_map)
											)
											(conclude
												(first
													(values
														filtered_residuals_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_residuals_map)
											)
											(assign
												(assoc
													filtered_residuals_map residuals_map
												)
											)

											;else backup the filtered residuals map for further filtering below
											(assign
												(assoc
													residuals_map filtered_residuals_map
												)
											)
										)

										;leave only case weight of .none
										(assign
											(assoc
												filtered_residuals_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	(list
																		".hyperparam_path"
																		2
																	)
																)
																".none"
															)
														)
														filtered_residuals_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_residuals_map)
											)
											(conclude
												(first
													(values
														filtered_residuals_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_residuals_map)
											)
											(assign
												(assoc
													filtered_residuals_map residuals_map
												)
											)

											;else backup the filtered residuals map for further filtering below
											(assign
												(assoc
													residuals_map filtered_residuals_map
												)
											)
										)

										;leave only case weight of .case_weight
										(assign
											(assoc
												filtered_residuals_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	(list
																		".hyperparam_path"
																		2
																	)
																)
																".case_weight"
															)
														)
														filtered_residuals_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_residuals_map)
											)
											(conclude
												(first
													(values
														filtered_residuals_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_residuals_map)
											)
											(assign
												(assoc
													filtered_residuals_map residuals_map
												)
											)

											;else backup the filtered residuals map for further filtering below
											(assign
												(assoc
													residuals_map filtered_residuals_map
												)
											)
										)

										;at this point output the first one, whatever it happens to be
										(first
											(values filtered_residuals_map)
										)
									)

									;returns cached feature mda in the format of assoc feature -> mda value
									;parameters are optional, when not specified will auto-select a cached MDA for output, when specified will attempt to output the cached
									;MDA best matching the requested parameters, null if none match.
									;
									;parameters:
									;
									; robust: flag, optional. if specified will attempt to return MDA that was computed with the specified robust or non-robust type.
									; permutation: flag, optional. if false, will attempt to return MDA that was computed with mda_type of drop. if true will attempt to return MDA that was computed with mda_type of permutation.
									; action_feature: string, optional. if specified will attempt to return MDA that was computed for the specified action_feature.
									; weight_feature: string, optional. if specified, will attempt to return MDA that was computed using this weight_feature.
									##GetFeatureMDA
									(declare
										(assoc
											robust (null)
											weight_feature (null)
											permutation (null)
											action_feature (null)
										)
										(if
											(=
												(null)
												robust
												permutation
												action_feature
												weight_feature
											)

											;if only one mda has been computed, return it
											(if
												(=
													1
													(size
														mdaMap
													)
												)
												(remove
													(first
														(values
															mdaMap
														)
													)
													(list
														".action_feature"
														".mda_type"
														".robust"
														".weight_feature"
													)
												)

												;there are several cached MDAs, pick one 'smartly':
												(remove
													(call
														!AutoSelectMDA
													)
													(list
														".action_feature"
														".mda_type"
														".robust"
														".weight_feature"
													)
												)
											)

											;else user specified parameters, try to find the matching one
											(call !SelectMDA)
										)
									)

									;Helper method for GetFeatureMDA, attempts to find an MDA set from the cached mdaMap that matches any of the optionaly
									;specified user parameters of robust, permutation, action_feature and/or weight_feature
									##!SelectMDA
									(let
										(assoc
											filtered_mda_map (retrieve_from_entity "mdaMap")
										)

										;leave only those matching specified robust flag
										(if
											(!= (null) robust)
											(assign
												(assoc
													filtered_mda_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		".robust"
																	)
																	robust
																)
															)
															filtered_mda_map
														)
												)
											)
										)

										;leave only those matching specified permutation
										(if
											(!= (null) permutation)
											(assign
												(assoc
													filtered_mda_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		".mda_type"
																	)
																	(if
																		permutation
																		"permutation"
																		"drop"
																	)
																)
															)
															filtered_mda_map
														)
												)
											)
										)

										;leave only those matching specified weight_feature
										(if
											(!= (null) weight_feature)
											(assign
												(assoc
													filtered_mda_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		".weight_feature"
																	)
																	weight_feature
																)
															)
															filtered_mda_map
														)
												)
											)
										)

										;leave only those matching specified action_feature
										(if
											(!= (null) action_feature)
											(assign
												(assoc
													filtered_mda_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		".action_feature"
																	)
																	action_feature
																)
															)
															filtered_mda_map
														)
												)
											)
										)

										;user did not specify weight_feature but there are multiple weight features cached, filter out non default weight_features
										(if
											(and
												(=
													(null)
													weight_feature
												)
												(>
													(size
														filtered_mda_map
													)
													1
												)
											)
											(let
												(assoc
													backup_mda_map filtered_mda_map
												)
												(assign
													(assoc
														filtered_mda_map (filter
																(lambda
																	(=
																		(get
																			(current_value)
																			".weight_feature"
																		)
																		".none"
																	)
																)
																filtered_mda_map
															)
													)
												)

												;revert if all mdas were filtered out
												(if
													(=
														0
														(size
															filtered_mda_map
														)
													)
													(assign
														(assoc
															filtered_mda_map backup_mda_map
														)
													)
												)
											)
										)
										(if
											(=
												0
												(size filtered_mda_map)
											)
											(null)

											;else output the remaining mda map
											(remove
												(first
													(values
														filtered_mda_map
													)
												)
												(list
													".action_feature"
													".mda_type"
													".robust"
													".weight_feature"
												)
											)
										)
									)

									;Helper method for GetFeatureMDA, attempts to find the most appropriate MDA set from the cached mdaMap
									##!AutoSelectMDA
									(let
										(assoc
											filtered_mda_map (assoc)
											mda_map (retrieve_from_entity "mdaMap")
										)

										;leave only "drop" (non-permutation) type mda
										(assign
											(assoc
												filtered_mda_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	".mda_type"
																)
																"drop"
															)
														)
														mda_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_mda_map)
											)
											(conclude
												(first
													(values
														filtered_mda_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_mda_map)
											)
											(assign
												(assoc
													filtered_mda_map mda_map
												)
											)

											;else backup the filtered mda map for further filtering below
											(assign
												(assoc
													mda_map filtered_mda_map
												)
											)
										)

										;leave only 'full' (ie. non-robust) MDA
										(assign
											(assoc
												filtered_mda_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	".robust"
																)
																(false)
															)
														)
														filtered_mda_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_mda_map)
											)
											(conclude
												(first
													(values
														filtered_mda_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_mda_map)
											)
											(assign
												(assoc
													filtered_mda_map mda_map
												)
											)

											;else backup the filtered mda map for further filtering below
											(assign
												(assoc
													mda_map filtered_mda_map
												)
											)
										)

										;leave only case weight of .none
										(assign
											(assoc
												filtered_mda_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	".weight_feature"
																)
																".none"
															)
														)
														filtered_mda_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_mda_map)
											)
											(conclude
												(first
													(values
														filtered_mda_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_mda_map)
											)
											(assign
												(assoc
													filtered_mda_map mda_map
												)
											)

											;else backup the filtered mda map for further filtering below
											(assign
												(assoc
													mda_map filtered_mda_map
												)
											)
										)

										;leave only case weight of .case_weight
										(assign
											(assoc
												filtered_mda_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	".weight_feature"
																)
																".case_weight"
															)
														)
														filtered_mda_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_mda_map)
											)
											(conclude
												(first
													(values
														filtered_mda_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_mda_map)
											)
											(assign
												(assoc
													filtered_mda_map mda_map
												)
											)
										)

										;at this point output the first one, whatever it happens to be
										(first
											(values filtered_mda_map)
										)
									)

									;Calculate and cache feature contributions - average delta between predicted value for action_feature with and without a context feature
									; for all specified context_features.
									;
									;parameters:
									;
									; context_features: list of features to use as contexts for computations.
									; action_feature: string,  compute contributions of each context feature at predicting this specified action feature
									; robust: flag, optional. if true will use the robust (power set/permutation) set of all other context_features
									;				 to compute the difference between prediction of action_feature with and without the context_feature in the model.
									; case_ids: list of cases to use for computing contributions
									; custom_hyperparam_map: optional, hyperparameters to use for computation
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									##CalculateFeatureContributions
									(declare
										(assoc
											robust (false)
											weight_feature ".case_weight"
											custom_hyperparam_map (null)
											case_ids (list)
											action_feature ""
											context_features (list)
										)
										(declare
											(assoc
												case_values_map (map
														(lambda
															(zip
																context_features
																(retrieve_from_entity
																	(current_index)
																	context_features
																)
															)
														)
														(zip
															case_ids
														)
													)
												context_features_map (zip
														context_features
													)
												base_react_map (assoc)
												hyperparam_map (if
														custom_hyperparam_map
														custom_hyperparam_map

														;else auto-determine
														(call
															GetHyperparameters
															(assoc
																weight_feature weight_feature
																feature action_feature
																mode (if
																		robust
																		"robust"
																		"full"
																	)
															)
														)
													)
												action_is_nominal (contains_index
														nominalsSet
														action_feature
													)
											)
										)

										;if doing full compute flow, can run a single pass of the baseline reacts since we don't need to iterate over features to hold any out
										(if
											(not robust)
											(assign
												(assoc
													base_react_map (map
															(lambda
																(let
																	(assoc
																		case_id (current_index
																				1
																			)
																	)
																	(call
																		ReactDiscriminative
																		(assoc
																			context_values (unzip
																					(get
																						case_values_map
																						case_id
																					)
																					context_features
																				)
																			skip_decoding (true)
																			details (assoc
																					categorical_action_probabilities action_is_nominal
																				)
																			ignore_case case_id
																			action_features (list
																					action_feature
																				)
																			hyperparam_map hyperparam_map
																			context_features context_features
																		)
																	)
																)
															)
															(zip
																case_ids
															)
														)
												)
											)
										)
										(declare
											(assoc
												contributions_map ||(map
														(lambda
															(let
																(assoc
																	feature (current_index
																			1
																		)
																	filtered_features_map (remove
																			context_features_map
																			(current_index
																				1
																			)
																		)
																	deltas (list)
																)
																(assign
																	(assoc
																		deltas (map
																				(lambda
																					(let
																						(assoc
																							base_reaction (null)
																							filtered_context_features (if
																									robust
																									(filter
																										(lambda
																											(<
																												(rand)
																												0.5
																											)
																										)
																										(indices
																											filtered_features_map
																										)
																									)
																									(indices
																										filtered_features_map
																									)
																								)
																							reaction (null)
																							action_value (null)
																							case_id (current_value
																									1
																								)
																							nom_action_prob (null)
																						)
																						(assign
																							(assoc
																								base_reaction (if
																										robust
																										(call
																											ReactDiscriminative
																											(assoc
																												context_values (unzip
																														(get
																															case_values_map
																															case_id
																														)
																														(append
																															filtered_context_features
																															feature
																														)
																													)
																												skip_decoding (true)
																												details (assoc
																														categorical_action_probabilities action_is_nominal
																													)
																												ignore_case case_id
																												action_features (list
																														action_feature
																													)
																												hyperparam_map hyperparam_map
																												context_features (append
																														filtered_context_features
																														feature
																													)
																											)
																										)

																										;else pull the cached reaction from base_react_map
																										(get
																											base_react_map
																											case_id
																										)
																									)
																								reaction (call
																										ReactDiscriminative
																										(assoc
																											context_values (unzip
																													(get
																														case_values_map
																														case_id
																													)
																													filtered_context_features
																												)
																											skip_decoding (true)
																											details (assoc
																													categorical_action_probabilities action_is_nominal
																												)
																											ignore_case case_id
																											action_features (list
																													action_feature
																												)
																											hyperparam_map hyperparam_map
																											context_features filtered_context_features
																										)
																									)
																							)
																						)
																						(assign
																							(assoc
																								action_value (get
																										base_reaction
																										(list
																											"action_values"
																											0
																										)
																									)
																							)
																						)

																						;compute delta
																						(if
																							action_is_nominal
																							(let
																								(assoc
																									case_action_prob (get
																											reaction
																											(list
																												"categorical_action_probabilities"
																												action_feature
																												action_value
																											)
																										)
																									nom_action_prob (get
																											base_reaction
																											(list
																												"categorical_action_probabilities"
																												action_feature
																												action_value
																											)
																										)
																								)

																								;if this action value wasn't in the local model, that's same as having a 0 case_action_prob
																								(abs
																									(if
																										(=
																											(null)
																											case_action_prob
																										)
																										(-
																											0
																											nom_action_prob
																										)
																										(-
																											case_action_prob
																											nom_action_prob
																										)
																									)
																								)
																							)

																							;else continuous: abs( predicted - base action value )
																							(abs
																								(-
																									(get
																										reaction
																										(list
																											"action_values"
																											0
																										)
																									)
																									action_value
																								)
																							)
																						)
																					)
																				)
																				case_ids
																			)
																	)
																)

																;output mean abs contribution
																(/
																	(apply
																		"+"
																		deltas
																	)
																	(size
																		deltas
																	)
																)
															)
														)
														context_features_map
													)
												param_path (concat
														(if
															robust
															"robust"
															"full"
														)
														weight_feature
														action_feature
													)
											)
										)

										;store into contributionsMap
										(assign_to_entities
											(assoc
												contributionsMap (set
														contributionsMap
														param_path
														(append
															contributions_map
															(assoc
																".weight_feature" weight_feature
																".action_feature" action_feature
																".robust" robust
															)
														)
													)
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)
									)

									;returns cached feature contributions in the format of assoc feature -> contribution value
									;parameters are optional, when not specified will auto-select cached contributions for output, when specified will attempt to output the cached
									;contributions best matching the requested parameters, null if none match.
									;
									;parameters:
									;
									; robust: flag, optional. if specified will attempt to return contributions that was computed with the specified robust or non-robust type.
									; action_feature: string, optional. if specified will attempt to return contributions that were computed for the specified action_feature.
									; weight_feature: string, optional. if specified, will attempt to return contributions that were computed using this weight_feature.
									##GetFeatureContributions
									(declare
										(assoc
											robust (null)
											weight_feature (null)
											action_feature (null)
										)
										(if
											(=
												(null)
												robust
												action_feature
												weight_feature
											)

											;if only one contributions set has been computed, return it
											(if
												(=
													1
													(size
														contributionsMap
													)
												)
												(remove
													(first
														(values
															contributionsMap
														)
													)
													(list
														".action_feature"
														".robust"
														".weight_feature"
													)
												)

												;there are several cached contributions, pick one 'smartly':
												(remove
													(call
														!AutoSelectContributions
													)
													(list
														".action_feature"
														".robust"
														".weight_feature"
													)
												)
											)

											;else user specified parameters, try to find the matching one
											(call !SelectContributions)
										)
									)

									;Helper method for GetFeatureContributions, attempts to find a contributions set from the cached contributionsMap that matches any of
									;the optionaly specified user parameters of robust, action_feature and/or weight_feature
									##!SelectContributions
									(let
										(assoc
											filtered_contributions_map (retrieve_from_entity "contributionsMap")
										)

										;leave only those matching specified robust flag
										(if
											(!= (null) robust)
											(assign
												(assoc
													filtered_contributions_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		".robust"
																	)
																	robust
																)
															)
															filtered_contributions_map
														)
												)
											)
										)

										;leave only those matching specified weight_feature
										(if
											(!= (null) weight_feature)
											(assign
												(assoc
													filtered_contributions_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		".weight_feature"
																	)
																	weight_feature
																)
															)
															filtered_contributions_map
														)
												)
											)
										)

										;leave only those matching specified action_feature
										(if
											(!= (null) action_feature)
											(assign
												(assoc
													filtered_contributions_map (filter
															(lambda
																(=
																	(get
																		(current_value)
																		".action_feature"
																	)
																	action_feature
																)
															)
															filtered_contributions_map
														)
												)
											)
										)

										;user did not specify weight_feature but there are multiple weight features cached, filter out non default weight_features
										(if
											(and
												(=
													(null)
													weight_feature
												)
												(>
													(size
														filtered_contributions_map
													)
													1
												)
											)
											(let
												(assoc
													backup_contributions_map filtered_contributions_map
												)
												(assign
													(assoc
														filtered_contributions_map (filter
																(lambda
																	(=
																		(get
																			(current_value)
																			".weight_feature"
																		)
																		".none"
																	)
																)
																filtered_contributions_map
															)
													)
												)

												;revert if all contributions were filtered out
												(if
													(=
														0
														(size
															filtered_contributions_map
														)
													)
													(assign
														(assoc
															filtered_contributions_map backup_contributions_map
														)
													)
												)
											)
										)
										(if
											(=
												0
												(size filtered_contributions_map)
											)
											(null)

											;else output the remaining contributions map
											(remove
												(first
													(values
														filtered_contributions_map
													)
												)
												(list
													".action_feature"
													".robust"
													".weight_feature"
												)
											)
										)
									)

									;Helper method for GetFeatureContributions, attempts to find the most appropriate contributions set from the cached contributions
									##!AutoSelectContributions
									(let
										(assoc
											filtered_contributions_map (assoc)
											contributions_map (retrieve_from_entity "contributionsMap")
										)

										;leave only 'full' (ie. non-robust) contributions
										(assign
											(assoc
												filtered_contributions_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	".robust"
																)
																(false)
															)
														)
														contributions_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_contributions_map)
											)
											(conclude
												(first
													(values
														filtered_contributions_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_contributions_map)
											)
											(assign
												(assoc
													filtered_contributions_map contributions_map
												)
											)

											;else backup the filtered contributions map for further filtering below
											(assign
												(assoc
													contributions_map filtered_contributions_map
												)
											)
										)

										;leave only case weight of .none
										(assign
											(assoc
												filtered_contributions_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	".weight_feature"
																)
																".none"
															)
														)
														filtered_contributions_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_contributions_map)
											)
											(conclude
												(first
													(values
														filtered_contributions_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_contributions_map)
											)
											(assign
												(assoc
													filtered_contributions_map contributions_map
												)
											)

											;else backup the filtered contributions map for further filtering below
											(assign
												(assoc
													contributions_map filtered_contributions_map
												)
											)
										)

										;leave only case weight of .case_weight
										(assign
											(assoc
												filtered_contributions_map (filter
														(lambda
															(=
																(get
																	(current_value)
																	".weight_feature"
																)
																".case_weight"
															)
														)
														filtered_contributions_map
													)
											)
										)
										(if
											(=
												1
												(size filtered_contributions_map)
											)
											(conclude
												(first
													(values
														filtered_contributions_map
													)
												)
											)

											;revert because all were filtered out
											(=
												0
												(size filtered_contributions_map)
											)
											(assign
												(assoc
													filtered_contributions_map contributions_map
												)
											)
										)

										;at this point output the first one, whatever it happens to be
										(first
											(values filtered_contributions_map)
										)
									)
								)

								;module for trainee_template
								;contains methods for hyperparameter optimization and feature deviation calculations
								(null
									##Optimize
									(if
										(!= "omni_targeted" targeted_model)
										(if
											(or
												(=
													"targetless"
													targeted_model
												)
												(=
													1
													(size
														action_features
													)
												)
											)
											(call
												OptimizeHyperparameters
												(assoc
													targeted_model targeted_model
													robust_mode (if
															(=
																"targetless"
																targeted_model
															)
															"robust"
															"full"
														)
													action_feature (if
															(=
																"targetless"
																targeted_model
															)
															".targetless"
															(first
																action_features
															)
														)
													context_features context_features
												)
											)

											;else single_targeted but with multiple action features, all feature optimize iterations should be 'robust' until the last one which is 'full'
											(map
												(lambda
													(let
														(assoc
															action_feature (current_value
																	1
																)
															accumulated_context_features context_features
														)
														(call
															OptimizeHyperparameters
															(assoc
																targeted_model "single_targeted"
																robust_mode (if
																		(=
																			action_feature
																			(last
																				action_features
																			)
																		)
																		"full"
																		"robust"
																	)
																action_feature action_feature
																context_features accumulated_context_features
															)
														)

														;accumulate the action feature to the contexts for the next iteration
														(accum
															(assoc
																accumulated_context_features action_feature
															)
														)
													)
												)
												action_features
											)
										)

										;else for omni-targeted, loop over every action feature and optimize each one as 'single_targeted', 'full'
										(map
											(lambda
												(let
													(assoc
														filtered_context_features (filter
																(lambda
																	(!=
																		(current_value)
																		(current_value
																			2
																		)
																	)
																)
																context_features
															)
														action_feature (current_value
																1
															)
													)
													(call
														OptimizeHyperparameters
														(assoc
															targeted_model "single_targeted"
															robust_mode "full"
															action_feature action_feature
															context_features filtered_context_features
														)
													)
												)
											)
											action_features
										)
									)

									;called on none or one action feature at a time by #Optimize
									; targeted_model : enumeration, default is "single_targeted"
									;   "single_targeted" = optimize hyperparameters for the specified action_features
									;   "targetless" = optimize hyperparameters for all context features as possible action features, ignores action_features parameter
									; context_features: list of context features to optimize for
									; action_features: list of action features to optimize for
									; inverse_residuals_as_weights : optional, default is null, will be set to false for targeted and true for targetless
									;			when true will forcibly compute and use inverse of residuals as feature weights
									; robust_mode: which type of context feature optimization to use during error computation, one of "robust" or "full".
									##OptimizeHyperparameters
									(declare
										(assoc
											targeted_model "targetless"
											inverse_residuals_as_weights (null)
											action_feature (null)
											robust_mode "robust"
											context_features (list)
										)
										(declare
											(assoc
												num_cases (call
														GetNumTrainingCases
													)
											)
										)

										;can't optimize 1 or 0 cases
										(if
											(< num_cases 2)
											(conclude 1)
										)

										;optimize one action feature at a time (for targeted only)
										(if
											(!= ".targetless" action_feature)
											(assign
												(assoc
													action_features (list
															action_feature
														)
												)
											)
										)
										(declare
											(assoc
												grid_search_error (null)
												previous_optimized_hp_map (null)
												optimized_hp_map (null)
												baseline_hyperparameter_map (null)
											)
										)
										(call InitOptimize)
										(call
											UpdateHyperparameters
											(assoc
												use_weights (false)
												use_deviations (false)
											)
										)
										(call GridSearch)
										(if
											inverse_residuals_as_weights
											(conclude
												(seq
													(call
														ConvergeIRW
														(assoc
															use_deviations (false)
														)
													)

													;iterations of ComputeResiduals and GridSearch
													(call
														BackupOptimizedHyperparameters
													)
													(if
														(=
															(false)
															use_deviations
														)
														(conclude
															(call
																SetModelHyperParameters
															)
														)
													)
													(call
														ConvergeIRW
														(assoc
															use_deviations (true)
														)
													)

													;iterations of ComputeResiduals and GridSearch
													(if
														(=
															(null)
															use_deviations
														)
														(call
															KeepOrRevertHyperparameters
														)
													)
													(call
														SetModelHyperParameters
													)
												)
											)
										)
										(call ComputeAndUseWeights)
										(call TestAccuracyAndKeepOrRevertHyperparameters)

										;w or w/o weights
										(if
											(= (false) use_deviations)
											(conclude
												(call SetModelHyperParameters)
											)
										)
										(declare
											(assoc non_deviation_hp_map baseline_hyperparameter_map)
										)

										;deviations, no weights
										(call
											UpdateHyperparameters
											(assoc
												use_weights (false)
												use_deviations (true)
												feature_deviations (call
														ComputeInitialDeviations
													)
											)
										)
										(call ConvergeResiduals)
										(call GridSearch)

										;now with weights
										(call ComputeAndUseWeights)
										(call TestAccuracyAndKeepOrRevertHyperparameters)

										;deviations w or w/o weights
										;if use of deviations should be auto determined, do that here, compare to non_deviation hyperparameters
										;and revert if to non-deviation if those were as good or better
										(if
											(= (null) use_deviations)
											(if
												(<=
													(get
														non_deviation_hp_map
														"gridSearchError"
													)
													(get
														baseline_hyperparameter_map
														"gridSearchError"
													)
												)
												(assign
													(assoc
														baseline_hyperparameter_map non_deviation_hp_map
													)
												)

												;residuals were converged using non_deviation parameters, if the currently optimized k or p are different
												;we re-converge the residuals using these updated p and k
												(or
													(!=
														(get
															non_deviation_hp_map
															"p"
														)
														(get
															baseline_hyperparameter_map
															"p"
														)
													)
													(!=
														(get
															non_deviation_hp_map
															"k"
														)
														(get
															baseline_hyperparameter_map
															"k"
														)
													)
												)
												(call ConvergeResiduals)
											)
										)
										(call SetModelHyperParameters)
									)

									; contains, p, k, dwe, gridSearchError, etc
									##BackupOptimizedHyperparameters
									(assign
										(assoc
											previous_optimized_hp_map optimized_hp_map
											baseline_hyperparameter_map optimized_hp_map
										)
									)

									;updates baseline_hyperparameter_map
									##KeepOrRevertHyperparameters
									(if
										(<=
											(get previous_optimized_hp_map "gridSearchError")
											(get optimized_hp_map "gridSearchError")
										)
										(assign
											(assoc baseline_hyperparameter_map previous_optimized_hp_map)
										)

										;else update with optimized
										(assign
											(assoc baseline_hyperparameter_map optimized_hp_map)
										)
									)

									;updates baseline_hyperparameter_map
									##UpdateHyperparameters
									(declare
										(assoc
											ordinal_feature_deviations (null)
											use_weights (null)
											feature_weights (null)
											attribute_map (assoc)
											use_deviations (null)
											feature_deviations (null)
										)
										(accum
											(assoc
												attribute_map (append

														;if clearing weights, set them to null
														(if
															(=
																(false)
																use_weights
															)

															;if there are inactive features, we have to reset active features to 1s and inactives to 0s
															(if
																hasInactiveFeatures
																(assoc
																	featureWeights (append
																			(zip
																				(indices
																					(get
																						baseline_hyperparameter_map
																						"featureWeights"
																					)
																				)
																				1
																			)
																			inactiveFeaturesMap
																		)
																)

																;else null out the weights
																(assoc
																	featureWeights (null)
																)
															)
															(assoc)
														)
														(if
															feature_weights
															(assoc
																featureWeights feature_weights
															)
															(assoc)
														)
														(if
															use_deviations
															(assoc
																useDeviations (true)
															)
															(assoc)
														)
														(if
															feature_deviations
															(assoc
																featureDeviations feature_deviations
															)
															(assoc)
														)
														(if
															(size
																ordinal_feature_deviations
															)
															(assoc
																featureOrdinalDeviations ordinal_feature_deviations
															)
															(assoc)
														)
													)
											)
										)
										(accum
											(assoc baseline_hyperparameter_map attribute_map)
										)
									)

									;write baseline_hyperparameter_map out to the model's hyperparameterMetadataMap
									##SetModelHyperParameters
									(seq
										(assign_to_entities
											(assoc
												hyperparameterMetadataMap (set
														hyperparameterMetadataMap
														(list
															action_feature
															robust_mode
															weight_feature
														)
														baseline_hyperparameter_map
													)
											)
										)
										(declare
											(assoc
												deviations (get
														baseline_hyperparameter_map
														"featureDeviations"
													)
											)
										)

										;if deviations were computed, store them in residualsMap
										(if
											deviations
											(assign_to_entities
												(assoc
													residualsMap (set
															residualsMap
															(concat
																robust_mode
																action_feature
																robust_mode
																weight_feature
															)
															(append
																deviations
																(assoc
																	".robust" (=
																			"robust"
																			robust_mode
																		)
																	".hyperparam_path" (list
																			action_feature
																			robust_mode
																			weight_feature
																		)
																)
															)
														)
												)
											)
										)
									)

									;updates baseline_hyperparameter_map
									;wrapper method to grid searches hyperparameters and backs up the results into previous_optimized_hp_map
									##GridSearch
									(seq
										(set_rand_seed sampling_random_seed)
										(assign
											(assoc
												optimized_hp_map (call
														ComputeResidualsAcrossParametersAndSelectOptimal
														(assoc
															k_values k_values
															num_optimization_samples num_optimization_samples
															targetless (=
																	targeted_model
																	"targetless"
																)
															action_features action_features
															k_folds_by_indices k_folds_by_indices
															k_folds k_folds
															dwe_values dwe_values
															p_values p_values
															baseline_hyperparameter_map baseline_hyperparameter_map
															context_features context_features
														)
													)
											)
										)
										(call BackupOptimizedHyperparameters)
									)

									;updates optimized_hp_map
									;run multiple iterations of grid search and resdiuals to either use with the inverse_residuals_as_weights flow
									##ConvergeIRW
									(declare
										(assoc
											num_iterations 3
											iteration 0
											num_samples_converge 1000
											use_deviations (false)
											hyperparam_map (assoc)
										)
										(set_rand_seed sampling_random_seed)

										;set the useDeviations flag
										(call
											UpdateHyperparameters
											(assoc use_deviations use_deviations)
										)
										(declare
											(assoc
												features (if
														(=
															targeted_model
															"targetless"
														)
														context_features
														(indices
															(zip
																(append
																	context_features
																	action_features
																)
															)
														)
													)
												residuals_tuple (list)
											)
										)

										;At this point we have hyperparameters that provide decent results, calculates residuals to use as weights, if they haven't been
										;calculated yet.  These first-pass residuals are likely not so good.
										;Now that thare are some feature weights, second pass finds better hyperparmeters, which then allow calculation of
										;decent residuals to use as weights.
										;Last pass finds usable hyperparams using these decent residuals and then calculates better residuals for weights.
										;At this point the hyperparameters and residuals/weights are stable enough to use.
										(while
											(< iteration num_iterations)
											(assign
												(assoc
													residuals_tuple (call
															CalculateFeatureResiduals
															(assoc
																robust_residuals (=
																		robust_mode
																		"robust"
																	)
																num_samples (if
																		(or
																			(<
																				iteration
																				(-
																					num_iterations
																					1
																				)
																			)
																			(!=
																				targeted_model
																				"targetless"
																			)
																		)
																		residual_num_samples

																		;else on the last iteration, use
																		(max
																			residual_num_samples
																			num_samples_converge
																		)
																	)
																custom_hyperparam_map baseline_hyperparameter_map
																features features
																output_ordinal_residuals (true)
															)
														)
												)
											)
											(call
												UpdateHyperparameters
												(assoc
													ordinal_feature_deviations (last
															residuals_tuple
														)
													feature_weights (map
															(lambda

																;ensure that inactive features always maintain a feature weight of 0
																(if
																	(contains_index
																		inactiveFeaturesMap
																		(current_index)
																	)
																	0

																	;tiny values < 1e13 mean it's a floating point percision error, set IRW to 1 / residual ^ p
																	(if
																		(>
																			(current_value)
																			1e-13
																		)
																		(/
																			1
																			(pow
																				(current_value)
																				(get
																					baseline_hyperparameter_map
																					"p"
																				)
																			)
																		)

																		;else set it to 1 because there is no residual
																		1
																	)
																)
															)
															(first
																residuals_tuple
															)
														)
													feature_deviations (first
															residuals_tuple
														)
												)
											)
											(assign
												(assoc
													optimized_hp_map (call
															ComputeResidualsAcrossParametersAndSelectOptimal
															(assoc
																k_values k_values
																num_optimization_samples num_optimization_samples
																use_inverse_weights (true)
																targetless (=
																		targeted_model
																		"targetless"
																	)
																action_features action_features
																k_folds_by_indices k_folds_by_indices
																k_folds k_folds
																dwe_values dwe_values
																p_values (filter
																		(lambda
																			(!=
																				0
																				(current_value)
																			)
																		)
																		p_values
																	)
																baseline_hyperparameter_map baseline_hyperparameter_map
																context_features context_features
															)
														)
												)
											)
											(accum
												(assoc
													iteration 1
												)
											)
										)
										(if
											(=
												(sort defaultFeatures)
												(sort features)
											)
											(accum
												(assoc
													optimized_hp_map (assoc
															allFeatureResidualsCached (true)
														)
												)
											)
										)
									)

									;updates baseline_hyperparameter_map
									;calculate feature residuals several times to converge on stable deviation values
									##ConvergeResiduals
									(declare
										(assoc
											num_iterations 3
											resdiuals (assoc)
											iteration 0
											num_samples 100
										)
										(declare
											(assoc
												features (if
														(=
															targeted_model
															"targetless"
														)
														context_features
														(indices
															(zip
																(append
																	context_features
																	action_features
																)
															)
														)
													)
												residuals_tuple (list)
											)
										)
										(while
											(< iteration num_iterations)
											(assign
												(assoc
													residuals_tuple (call
															CalculateFeatureResiduals
															(assoc
																robust_residuals (=
																		robust_mode
																		"robust"
																	)
																num_samples
																	;for robust the first iteration needs just enough to run a few samples for each feature to establish some reasonable value
																	(if
																		(and
																			robust_residuals
																			(=
																				0
																				iteration
																			)
																		)
																		(min
																			num_samples
																			(*
																				10
																				(size
																					features
																				)
																			)
																		)

																		;on the last iteration use the larger of 1000 or the specified samples to attain more accurate residuals
																		(=
																			2
																			iteration
																		)
																		(max
																			num_samples
																			1000
																		)
																		num_samples
																	)
																custom_hyperparam_map baseline_hyperparameter_map
																features features
																hyperparameter_feature action_feature
																output_ordinal_residuals (true)
															)
														)
												)
											)
											(call
												UpdateHyperparameters
												(assoc
													ordinal_feature_deviations (last
															residuals_tuple
														)
													feature_deviations (first
															residuals_tuple
														)
												)
											)
											(accum
												(assoc
													iteration 1
												)
											)
											(if
												(=
													1
													iteration
												)
												(if
													(=
														(sort
															defaultFeatures
														)
														(sort
															features
														)
													)
													(accum
														(assoc
															baseline_hyperparameter_map (assoc
																	allFeatureResidualsCached (true)
																)
														)
													)
												)
											)
										)
									)

									;updates baseline_hyperparameter_map
									;wrapper method to compute context feature weights for a specified action_feature and update baseline_hyperparameter_map with those weights
									##ComputeAndUseWeights
									(let

										;compute an assoc of feature -> weight for the action_feature
										(assoc
											weights_map (call
													ComputeActionFeatureWeights
													(assoc
														weight_feature weight_feature
														use_case_weights use_case_weights
														action_feature action_feature
														hyperparam_map baseline_hyperparameter_map
														context_features
															;ensure context_features don't have the action_feature in it
															(filter
																(lambda
																	(!=
																		action_feature
																		(current_value)
																	)
																)
																context_features
															)
													)
												)
										)

										;store the computed feature weights into baseline_hyperparameter_map
										(accum
											(assoc
												baseline_hyperparameter_map (assoc
														featureWeights weights_map
													)
											)
										)
									)

									;outputs weights_map for as action_feature for specified context_features
									##ComputeActionFeatureWeights
									(declare
										(assoc
											weight_feature ".case_weight"
											use_case_weights (false)
											action_feature (null)
											hyperparam_map (null)
											context_features (list)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)
										)

										;mda for each context feature as a ratio of error_with_feature_removed / baseline_error (where baseline uses all the context features)
										(declare
											(assoc
												context_features_mda_map (call
														DecreaseInAccuracy
														(assoc
															weight_feature weight_feature
															use_case_weights use_case_weights
															action_features (list
																	action_feature
																)
															output_ratio (true)
															hyperparam_map hyperparam_map
															context_features context_features
														)
													)
											)
										)

										;if baseline accuracy was 100% (MAE was 0), the ratios will be infinities (divided by 0), so set all weights to 1
										(if
											(contains_value context_features_mda_map .infinity)
											(conclude

												;if MDA was calculated using feature weights, return those exact weights since they result in a perfect score
												(if
													(get
														hyperparam_map
														"featureWeights"
													)

													;only return the weights for the requested context_features
													(keep
														(get
															hyperparam_map
															"featureWeights"
														)
														context_features
													)

													;else return 1 for all weights since we can't get any better score using all the context fetaures
													(map
														(lambda
															1
														)
														context_features_mda_map
													)
												)
											)
										)
										(declare
											(assoc
												good_features_mda_map (filter
														(lambda
															(>
																(current_value)
																1
															)
														)
														context_features_mda_map
													)
												weights_map (filter
														(lambda
															(<=
																(current_value)
																1
															)
														)
														context_features_mda_map
													)
											)
										)

										;find the max and the range for the max mda values
										(declare
											(assoc
												mda_max (apply
														"max"
														(values
															context_features_mda_map
														)
													)
											)
										)
										(declare
											(assoc
												mda_good_range (-
														mda_max
														1
													)
												num_features (-
														(max
															mda_max
															(size
																context_features_mda_map
															)
														)
														1
													)
											)
										)
										(declare
											(assoc
												normalized_map
													;handle extreme edge case of all ratio values being 1, resulting in a range of 0
													(if
														(=
															0
															mda_good_range
														)
														(map
															(lambda
																1
															)
															good_features_mda_map
														)

														;else normalize all positive values
														(map
															(lambda
																(/
																	(-
																		(current_value)
																		1
																	)
																	mda_good_range
																)
															)
															good_features_mda_map
														)
													)
											)
										)

										;transform normalized values to be relative to max(value, num_features) + 1 (add 1 since normalized values are 0-based)
										(accum
											(assoc
												weights_map (append
														(associate
															action_feature
															1
														)
														(map
															(lambda
																(+
																	1
																	(*
																		(current_value)
																		num_features
																	)
																)
															)
															normalized_map
														)
													)
											)
										)
										(if
											hasInactiveFeatures
											(accum
												(assoc
													weights_map inactiveFeaturesMap
												)
											)
										)

										;output weights map
										weights_map
									)

									;updates baseline_hyperparameter_map
									;uses provided baseline_hyperparameter_map to compute the model MAE (gridSerachError), if computed error is less than current/y stored error,
									;updates baseline_hyperparameter_map with the new error value, otherwise reverts it back to previous_optimized_hp_map
									##TestAccuracyAndKeepOrRevertHyperparameters
									(seq

										;re-set the defined random seed to run gridsearch the same way as it was run above
										(set_rand_seed sampling_random_seed)

										;run through one pass using feature weights to see if they should be used
										(assign
											(assoc
												model_mae (call
														ComputeModelResidualForParameters
														(assoc
															targetless (=
																	targeted_model
																	"targetless"
																)
														)
													)
											)
										)

										;if previous pass did better than this pass, revert baseline_hyperparameter_map
										(if
											(>=
												model_mae
												(get
													baseline_hyperparameter_map
													"gridSearchError"
												)
											)
											(assign
												(assoc
													baseline_hyperparameter_map previous_optimized_hp_map
												)
											)

											;else keep update current hyperparams with new error value and back them up
											(seq
												(assign
													(assoc
														baseline_hyperparameter_map (set
																baseline_hyperparameter_map
																"gridSearchError"
																model_mae
															)
													)
												)
												(assign
													(assoc
														previous_optimized_hp_map baseline_hyperparameter_map
													)
												)
											)
										)
									)

									;output initial deviations to be the smallest gaps for each feature scaled by the number of features
									##ComputeInitialDeviations
									(let
										(assoc
											all_features (indices
													(zip
														(append
															context_features
															action_features
														)
													)
												)
										)
										(map
											(lambda
												(/
													(current_value)
													(size
														all_features
													)
												)
											)
											(call
												CalculateSmallestFeatureGap
												(assoc
													features all_features
												)
											)
										)
									)

									;initialize variables and cache feature expected values
									##InitOptimize
									(seq

										;if optimize is being called without any context features, default them to the full set of all features
										;targeted_model will already have be set to 'targetless' if no features are passed in
										(if
											(=
												0
												(size context_features)
											)
											(assign
												(assoc
													context_features defaultFeatures
												)
											)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)

											;else compute id-based case weights
											(seq
												(call ComputeAndStoreIdFeatureCaseWeights)

												;if there are no id features and user didn't specify a custom weight feature, treat as without case weight
												(if
													(and
														(not
															hasPopulatedCaseWeight
														)
														(=
															weight_feature
															".case_weight"
														)
													)
													(assign
														(assoc
															weight_feature ".none"
															use_case_weights (false)
														)
													)
												)
											)
										)

										;if inverse_residuals_as_weights isn't defined, default it to true for targetless, false for targeted
										(if
											(= (null) inverse_residuals_as_weights)
											(assign
												(assoc
													inverse_residuals_as_weights (if
															(=
																targeted_model
																"targetless"
															)
															(true)
															(false)
														)
												)
											)
										)
										(assign
											(assoc
												baseline_hyperparameter_map (call
														GetHyperparameters
														(assoc
															weight_feature weight_feature
															feature action_feature
															mode robust_mode
														)
													)
											)
										)

										;store the paramPath for this hyperparameter set so it has a reference to where it's stored in hyperparameterMetadataMap
										(accum
											(assoc
												baseline_hyperparameter_map (assoc
														paramPath (list
																action_feature
																robust_mode
																weight_feature
															)
													)
											)
										)

										;check if auto optimization is enabled and the optimization threshold should be increased
										(if
											(and
												autoOptimizeEnabled
												(>=
													num_cases
													autoOptimizeThreshold
												)
											)

											;set the next auto optimization threshold
											(assign_to_entities
												(assoc
													autoOptimizeThreshold (*
															autoOptimizeThreshold
															autoOptimizeGrowthFactorAmount
														)
												)
											)
										)

										;for k_folds = 1, set the default num_optimization_samples to be 1000
										(if
											(and
												(=
													1
													k_folds
												)
												(=
													(null)
													num_optimization_samples
												)
											)
											(assign
												(assoc
													num_optimization_samples 1000
												)
											)
										)

										;pre-compute and cache all the expected feature values and nominal probabilities so that they don't have to be
										;lazy computed later during residual computations
										(assign_to_entities
											(assoc
												expectedValuesMap (assoc)
												nominalClassProbabilitiesMap (assoc)
												cachedFeatureMinResidualMap (assoc)
												cachedFeatureMinGapMap (assoc)
												featureNullRatiosMap (assoc)
											)
										)
										(call
											CacheExpectedValuesAndProbabilities
											(assoc
												weight_feature weight_feature
												use_case_weights use_case_weights
												features (indices
														(zip
															(append
																context_features
																action_features
															)
														)
													)
											)
										)
									)

									;autotunes the model to use the 'best' hyperparameters using grid-search (with optional k-fold cross validation)
									;outputs updated hyperparameter map
									;parameters:
									; context_features: list of context features
									; action_features: list of action features for action inputs
									; k_folds: number of cross validation folds to do. value of 1 does hold-one-out instead of k-fold
									; k_values : optional list of k values to grid search, if null will use default list.
									; p_values : optional list of p values to grid search, if null will use default list.
									; dwe_values : optional list of distanceWeightExponent values to grid search, if null will use -1.
									; use_k_values: optional flag default true. if false, will use k value specified in 'baseline_hyperparameter_map'
									; use_p_values: optional flag default true. if false, will use p value specified in 'baseline_hyperparameter_map'
									; use_dwe_values: optional flag default true. if false, will use dwe value specified in 'baseline_hyperparameter_map'
									; p_param_categorical_mean : optional parameter to specify the lp space for calculating the mean of Mean Absolute Errors for categorical features
									; p_param_accuracy_mean : optional parameter to specify the lp space for calculating the mean of Mean Absolute Errors among all features
									; k_folds_by_indices : optional flag, if true will do k_folds ordered by session id indices
									; targetless : optional flag, if true will randomly select a context feature as an action feature for each case during grid search
									; num_optimization_samples : optional. number of cases to sample during optimization. only applies for k_folds = 1
									; baseline_hyperparameter_map : the base hyperparameters to use for computation
									; use_inverse_weights: if true, will compute inverse residual weights (IRW) during the grid search for use in error computations
									##ComputeResidualsAcrossParametersAndSelectOptimal
									(declare
										(assoc
											p_param_categorical_mean 1
											k_values (null)
											use_k_values (true)
											num_optimization_samples (null)
											use_inverse_weights (false)
											targetless (false)
											use_p_values (true)
											action_features (list)
											k_folds 1
											k_folds_by_indices (false)
											p_param_accuracy_mean 0.2
											context_features (list)
											dwe_values (null)
											p_values (null)
											baseline_hyperparameter_map (assoc)
											use_dwe_values (true)
										)

										;can't do optimization if there is a max of one context feature provided and no different action features
										(if
											(and
												(<
													(size
														context_features
													)
													2
												)
												(or

													;no action features, or the one context feature is also the action feature
													(=
														(size
															action_features
														)
														0
													)
													(=
														context_features
														action_features
													)
												)
											)

											;return valid existing hyperparameters
											(conclude baseline_hyperparameter_map)
										)
										(if
											(= (null) k_values)
											(assign
												(assoc
													k_values
														;grid search fibonacci sequence
														(if
															(=
																targeted_model
																"targetless"
															)
															(list
																5
																8
																13
															)
															(list
																3
																5
																8
																13
																21
																34
																55
																89
																144
															)
														)
												)
											)
										)
										(if
											(= (null) p_values)
											(assign
												(assoc
													p_values (if
															(=
																targeted_model
																"targetless"
															)
															(list
																0.1
																0.5
																1
																2
															)
															(list
																0.01
																0.1
																0.5
																1
																2
															)
														)
												)
											)
										)

										;if dwe is null, default it to -1, if it's empty list set it to the recommended default search list
										(if
											(= (null) dwe_values)
											(assign
												(assoc
													dwe_values (list
															-1
														)
												)
											)
											(= (list) dwe_values)
											(assign
												(assoc
													dwe_values (list
															-8
															-2
															-1
															-0.5
															0
														)
												)
											)
										)

										;if the dataset is smaller than the max K value, reduce the possible k_values search
										(declare
											(assoc
												smallest_k (first
														(sort
															k_values
														)
													)
											)
										)
										(if
											(<=
												num_cases
												(apply
													"max"
													k_values
												)
											)
											(assign
												(assoc
													k_values (filter
															(lambda
																(<
																	(current_value)
																	num_cases
																)
															)
															k_values
														)
												)
											)
										)

										;if there are no valid k_values because they have all been filtered out, use the smallest one
										(if
											(= (list) k_values)
											(assign
												(assoc
													k_values (list
															smallest_k
														)
												)
											)
										)

										;ensure the k_values are sorted largest to smallest,(ie there's a knn cache internally, when the largest K value is processed and cached
										;subsequent calls with smaller Ks will be fast)
										(assign
											(assoc
												k_values (sort
														(lambda
															(>
																(current_value
																	1
																)
																(current_value)
															)
														)
														k_values
													)
											)
										)
										(if
											(not use_k_values)
											(assign
												(assoc
													k_values (list
															(get
																baseline_hyperparameter_map
																"k"
															)
														)
												)
											)
										)
										(if
											(not use_p_values)
											(assign
												(assoc
													p_values (list
															(get
																baseline_hyperparameter_map
																"p"
															)
														)
												)
											)
										)
										(if
											(not use_dwe_values)
											(assign
												(assoc
													dwe_values (list
															(get
																baseline_hyperparameter_map
																"dwe"
															)
														)
												)
											)
										)

										;action_features are empty for targetless,set them to be same as context features
										(if
											targetless
											(assign
												(assoc
													action_features context_features
												)
											)
										)
										(declare
											(assoc
												accumulated_results_map (assoc)
												p_k_dwe_key (null)
												best_accuracy_distance .infinity
												output_map (assoc)
												sample_case_ids (if
														(!=
															(null)
															num_optimization_samples
														)
														(call
															AllCases
															(assoc
																num num_optimization_samples
																rand_seed (rand)
															)
														)
														(null)
													)
												best_params_key (null)
											)
										)

										;grid search over the P, K and DWE values
										;
										;foreach p:
										;	foreach k:
										;		foreach dwe:
										;			calculate MAE for each action feature
										;	best = choose the one with the best validation error (lowest MAE among all features)
										(if
											(= k_folds 1)
											(call AccumulateErrorsViaGridSearch)

											;else do k-fold validation, where each fold iterates over p k and dwe and accumulates errors
											(call AccumulateErrorsViaKFoldsGridSearch)
										)

										;convert the list of distances for each hyperparameter tuple into an avg distance
										;and while iterating store the best (smallest) distance and corresponding key
										(assign
											(assoc
												accumulated_results_map (map
														(lambda
															(let
																(assoc
																	avg_distance (/
																			(apply
																				"+"
																				(get
																					(current_value
																						1
																					)
																					"distances"
																				)
																			)
																			k_folds
																		)
																)
																(if
																	(<
																		avg_distance
																		best_accuracy_distance
																	)
																	(assign
																		(assoc
																			best_accuracy_distance avg_distance
																			best_params_key (get_value
																					(current_index
																						1
																					)
																				)
																		)
																	)
																)

																;overwrite 'distances' with the average of the distances
																(set
																	(current_value)
																	"distances"
																	avg_distance
																)
															)
														)
														accumulated_results_map
													)
											)
										)

										;sort the best params that all have the same 'best' accuracy distance by their P value
										(declare
											(assoc
												best_params (sort
														(lambda
															(<
																(get
																	(current_value
																		1
																	)
																	"p"
																)
																(get
																	(current_value)
																	"p"
																)
															)
														)
														(filter
															(lambda
																(=
																	(get
																		(current_value)
																		"distances"
																	)
																	best_accuracy_distance
																)
															)
															(values
																accumulated_results_map
															)
														)
													)
												best_p (get
														accumulated_results_map
														(list
															best_params_key
															"p"
														)
													)
											)
										)

										;sort the best remaining params that have all the same 'best' p and accuracy distance by their K value
										(assign
											(assoc
												best_params (sort
														(lambda
															(<
																(get
																	(current_value
																		1
																	)
																	"k"
																)
																(get
																	(current_value)
																	"k"
																)
															)
														)

														;filter out all params that did not have a matching p
														(filter
															(lambda
																(=
																	(get
																		(current_value)
																		"p"
																	)
																	best_p
																)
															)
															best_params
														)
													)
											)
										)

										;at this point best_params should either have one set, that we can use, or it's sorted by K values, take the median in that case
										(assign
											(assoc
												best (if
														(=
															(size
																best_params
															)
															0
														)
														(first
															best_params
														)

														;take the median value
														(get
															best_params
															(floor
																(/
																	(size
																		best_params
																	)
																	2
																)
															)
														)
													)
											)
										)
										(assign
											(assoc
												output_map (assoc
														dwe (get
																best
																"dwe"
															)
														k (get
																best
																"k"
															)
														gridSearchError (get
																best
																"distances"
															)
														p (get
																best
																"p"
															)
													)
											)
										)

										;output updated hyperparam map
										(append
											baseline_hyperparameter_map

											;overwrite with the autotuned k and p values
											(if
												(not use_inverse_weights)
												output_map

												;else compute and output the corresponding IRW with the parameters
												(append
													output_map
													(assoc
														featureWeights
															;set inverted residuals to be 1 / (residual^p), unless it's 0 (or within floating point error of 0)
															(map
																(lambda

																	;ensure that inactive features always maintain a feature weight of 0
																	(if
																		(contains_index
																			inactiveFeaturesMap
																			(current_index)
																		)
																		0

																		;tiny values < 1e13 mean it's a floating point percision error, set IRW to 1 / residual ^ p
																		(if
																			(>
																				(current_value)
																				1e-13
																			)
																			(/
																				1
																				(pow
																					(current_value)
																					(get
																						output_map
																						"p"
																					)
																				)
																			)

																			;else set it to 1 because there is no residual
																			1
																		)
																	)
																)
																(get
																	baseline_hyperparameter_map
																	"featureDeviations"
																)
															)
													)
												)
											)
										)
									)

									;output model Mean Absolute Error (MAE) for the provided baseline_hyperparameter_map
									##ComputeModelResidualForParameters
									(seq
										(if
											targetless
											(assign
												(assoc
													action_features context_features
												)
											)
										)
										(declare
											(assoc
												accumulated_kfold_errors (list)
												sample_case_ids (if
														(!=
															(null)
															num_optimization_samples
														)
														(call
															AllCases
															(assoc
																num num_optimization_samples
																rand_seed (rand)
															)
														)
													)
											)
										)
										(if
											(= k_folds 1)
											(call
												CalculateModelMAE
												(assoc
													robust_residuals (false)
													weight_feature weight_feature
													custom_hyperparam_map baseline_hyperparameter_map
													case_ids sample_case_ids
													use_case_weights use_case_weights
													action_features action_features
													ignore_exact_cases (true)
													context_features context_features
												)
											)

											;else do k-fold, average out the value across the k-folds
											(seq

												;The method ComputeAndAccumulateKFoldsMAE accumulates all k_fold maes into 'accumulated_kfold_errors'
												(call
													AccumulateErrorsViaKFoldsGridSearch
													(assoc
														accumulate_error_method "ComputeAndAccumulateKFoldsMAE"
													)
												)
												(/
													(apply
														"+"
														accumulated_kfold_errors
													)
													k_folds
												)
											)
										)
									)

									;accumulate model MAE during kfold validation using provided baseline_hyperparameter_map
									##ComputeAndAccumulateKFoldsMAE
									(accum
										(assoc
											accumulated_kfold_errors (call
													CalculateModelMAE
													(assoc
														robust_residuals (false)
														cases_already_removed (true)
														weight_feature weight_feature
														custom_hyperparam_map baseline_hyperparameter_map
														case_ids validation_case_ids
														use_case_weights use_case_weights
														action_features action_features
														context_features context_features
													)
												)
										)
									)

									;doing k-fold validation, so each validation block is 1/k_folds of all the cases
									##AccumulateErrorsViaKFoldsGridSearch
									(declare
										(assoc
											validation_size (if
													(>
														k_folds
														1
													)
													(/
														num_cases
														k_folds
													)
													.infinity
												)
											accumulate_error_method "AccumulateErrorsViaGridSearch"
										)

										;temporary entity storage for the validation cases
										(create_entities "_temp_" (null))

										;do k-fold cross validation by taking out k even chunks of all the cases and then validating on each one
										(map
											(lambda
												(let
													(assoc
														p_k_dwe_key (null)
														validation_case_ids (if
																k_folds_by_indices
																(contained_entities
																	(list
																		(query_exists
																			internalLabelSession
																		)
																		(query_between
																			internalLabelSessionTrainingIndex
																			(*
																				(current_value
																					2
																				)
																				validation_size
																			)
																			(-
																				(+
																					validation_size
																					(*
																						(current_value
																							2
																						)
																						validation_size
																					)
																				)
																				1
																			)
																		)
																	)
																)
																(call
																	AllCases
																	(assoc
																		start_offset (*
																				(current_value
																					2
																				)
																				validation_size
																			)
																		num validation_size
																	)
																)
															)
													)

													;move this chunk of validation cases into _temp_ so that they aren't in the model during the reaction/validation process
													(map
														(lambda
															(move_entities
																(current_value)
																(list
																	"_temp_"
																	(current_value
																		1
																	)
																)
															)
														)
														validation_case_ids
													)

													;call the method to compute the error
													(call
														(retrieve_from_entity
															accumulate_error_method
														)
													)

													;restore the validation cases from backup
													(map
														(lambda
															(move_entities
																(list
																	"_temp_"
																	(current_value
																		1
																	)
																)
																(current_value)
															)
														)
														validation_case_ids
													)
												)
											)

											;k-fold, 0-based indexing
											(range
												0
												(-
													k_folds
													1
												)
											)
										)

										;no longer need the temporary entity container
										(destroy_entities "_temp_")
									)
									##AccumulateErrorsViaGridSearch
									(map
										(lambda
											(let
												(assoc
													inverted_residuals_map (null)
													p_value (current_value
															1
														)
												)

												;compute IRW if residuals for IRW map was provided
												(if
													use_inverse_weights
													(assign
														(assoc
															inverted_residuals_map (map
																	(lambda

																		;ensure that inactive features always maintain a feature weight of 0
																		(if
																			(contains_index
																				inactiveFeaturesMap
																				(current_index)
																			)
																			0

																			;tiny values < 1e13 mean it's a floating point percision error, set IRW to 1 / residual ^ p
																			(if
																				(>
																					(current_value)
																					1e-13
																				)
																				(/
																					1
																					(pow
																						(current_value)
																						p_value
																					)
																				)

																				;else set it to 1 because there is no residual
																				1
																			)
																		)
																	)
																	(get
																		baseline_hyperparameter_map
																		"featureDeviations"
																	)
																)
														)
													)
												)
												(map
													(lambda
														(let
															(assoc
																k_value (current_value
																		1
																	)
															)
															(map
																(lambda
																	(let
																		(assoc
																			mae_hyperparam_map baseline_hyperparameter_map
																			dwe_value (current_value
																					1
																				)
																		)

																		;overwrite the k/p/dwe and inverse weights and deviations if appropriate
																		(accum
																			(assoc
																				mae_hyperparam_map (append
																						(assoc
																							dwe dwe_value
																							k k_value
																							p p_value
																						)

																						;if using inverse weights, overwrite existing weights in baseline_hyperparameter_map
																						(if
																							use_inverse_weights
																							(assoc
																								featureDeviations (get
																										baseline_hyperparameter_map
																										"featureDeviations"
																									)
																								featureWeights inverted_residuals_map
																							)
																							(assoc)
																						)
																					)
																			)
																		)

																		;accumulate the accuracy distance for each set of parameters
																		(declare
																			(assoc
																				accuracy_distance
																					;else do k-fold cross validation if K is specified, otherwise do 1-by-1 knockout
																					(if
																						(>
																							k_folds
																							1
																						)

																						;iterate over all the validation_case_ids and react to each one
																						;returning the mean absolute error (MAE) for each action feature
																						(call
																							CalculateModelMAE
																							(assoc
																								p_param_categorical_mean p_param_categorical_mean
																								robust_residuals (false)
																								cases_already_removed (true)
																								weight_feature weight_feature
																								custom_hyperparam_map mae_hyperparam_map
																								case_ids validation_case_ids
																								use_case_weights use_case_weights
																								action_features action_features
																								p_param_accuracy_mean p_param_accuracy_mean
																								context_features context_features
																							)
																						)

																						;else do hold-one-out validation
																						(call
																							CalculateModelMAE
																							(assoc
																								robust_residuals (false)
																								weight_feature weight_feature
																								custom_hyperparam_map mae_hyperparam_map
																								case_ids sample_case_ids
																								use_case_weights use_case_weights
																								action_features action_features
																								ignore_exact_cases (true)
																								context_features context_features
																							)
																						)
																					)
																			)
																		)
																		(assign
																			(assoc
																				p_k_dwe_key (concat
																						p_value
																						k_value
																						dwe_value
																					)
																			)
																		)

																		;a map of   { k_p_dwe_key : {  k: K, p: P, dwe: DWE, dist: [ ...] } }
																		(assign
																			(assoc
																				accumulated_distances (if
																						(=
																							(null)
																							(get
																								accumulated_results_map
																								(list
																									p_k_dwe_key
																									"distances"
																								)
																							)
																						)
																						(list
																							accuracy_distance
																						)
																						(append
																							(get
																								accumulated_results_map
																								(list
																									p_k_dwe_key
																									"distances"
																								)
																							)
																							accuracy_distance
																						)
																					)
																			)
																		)

																		;store both the distance calculated using the p value and the geometric mean
																		(accum
																			(assoc
																				accumulated_results_map (associate
																						p_k_dwe_key
																						(assoc
																							dwe dwe_value
																							k k_value
																							distances accumulated_distances
																							p p_value
																						)
																					)
																			)
																		)
																	)
																)
																dwe_values
															)
														)
													)
													k_values
												)
											)
										)
										p_values
									)

									;return an assoc of feature -> the smallest gap value for the feature
									;parameters:
									; features: list of features for which to return gap values
									##CalculateSmallestFeatureGap
									(declare
										(assoc features (list))
										(map
											(lambda
												(let
													(assoc
														smallest_gap
															;gap is always 1 for nominals
															(if
																(contains_index
																	nominalsSet
																	(get_value
																		(current_index
																			1
																		)
																	)
																)
																1

																;else compute the gap
																(compute_on_contained_entities
																	(list
																		(query_min_difference
																			(current_index
																				2
																			)
																			(get
																				cyclicFeaturesMap
																				(current_index
																					2
																				)
																			)
																		)
																	)
																)
															)
													)

													;gap / 2, unless it's infinity in which case set it to 0.5
													;smallest_gap of infinity that means all the feature values are exactly the same,  for nominals and most normal numbers,
													;the gap is 1, therefore 0.5 is a reasonable gap/2 value
													(if
														(=
															.infinity
															smallest_gap
														)
														0.5
														smallest_gap
													)
												)
											)
											(zip features)
										)
									)

									;Holds out random cases and returns the name of the contained entity holding them.
									;
									;parameters:
									; num_samples : number of random samples to hold out
									; rand_seed : random seed to use for selection of cases
									##HoldOutRandomCases
									(declare
										(assoc rand_seed (rand))
										(declare
											(assoc
												holdout_entity_name (concat
														"_temp"
														rand_seed
													)
											)
										)
										(create_entities holdout_entity_name (null))
										(map
											(lambda
												(move_entities
													(current_value)
													(list
														holdout_entity_name
														(current_value
															1
														)
													)
												)
											)
											(call
												AllCases
												(assoc
													num num_samples
													rand_seed rand_seed
												)
											)
										)
										holdout_entity_name
									)

									;Restores cases that were being held in entity named 'holdout_entity_name' back to the model
									;
									;parameters:
									; holdout_entity_name: name of entity that was returned whyn HoldOutRandomCases was called
									##RestoreHeldOutCases
									(declare
										(assoc holdout_entity_name (null))

										;restore the validation cases from backup
										(if
											(!= (null) holdout_entity_name)
											(seq
												(map
													(lambda
														(move_entities
															(list
																holdout_entity_name
																(current_value
																	1
																)
															)
															(current_value)
														)
													)
													(contained_entities
														holdout_entity_name
													)
												)
												(destroy_entities holdout_entity_name)
											)
										)
									)

									;Iterate over all the passed in cases and accumulate their corresponding neighbor weights into the neighbors' weight_feature
									;parameters:
									; features: feature set to use for finding neighbors
									; cases: list of lists of values (non model-stored cases) for whose neighbors to accumulate weights for.
									; accumulate_weight_feature : name of feature into which to accumulate neighbors' influences as weight.
									##AccumulateCaseInfluenceWeights
									(declare
										(assoc
											features defaultFeatures
											accumulate_weight_feature ".case_weight"
											cases (list)
										)
										(declare
											(assoc
												new_weight_label_and_value (zip_labels
														(list
															accumulate_weight_feature
														)
														(list
															1
														)
													)
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature ".none"
															feature ".targetless"
															mode "robust"
														)
													)
											)
										)
										(map
											(lambda
												(let
													(assoc
														case_values (current_value
																1
															)
														closest_cases_map (assoc)
														total_weight 0
													)
													(assign
														(assoc
															closest_cases_map (compute_on_contained_entities
																	(list
																		(query_nearest_generalized_distance
																			(get
																				hyperparam_map
																				"k"
																			)
																			features
																			case_values
																			(get
																				hyperparam_map
																				"featureWeights"
																			)
																			nominalClassCountsMap
																			cyclicFeaturesMap
																			(if
																				(get
																					hyperparam_map
																					"useDeviations"
																				)
																				(get
																					hyperparam_map
																					"featureDeviations"
																				)
																			)
																			(get
																				hyperparam_map
																				"p"
																			)
																			(get
																				hyperparam_map
																				"dwe"
																			)
																			(if
																				(!=
																					weight_feature
																					".none"
																				)
																				weight_feature
																				(null)
																			)

																			;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																			"fixed rand seed"
																			(null)

																			;radius
																			lpSpaceHeuristicMultiplier
																			(true)
																		)
																	)
																)
														)
													)

													;if there are perfect matches (value is infinite), keep only those and set their weight to 1
													(if
														(contains_value
															(values
																closest_cases_map
															)
															.infinity
														)
														(assign
															(assoc
																closest_cases_map
																	;keep only perfect matches
																	(map
																		1
																		(filter
																			(lambda
																				(=
																					(current_value)
																					.infinity
																				)
																			)
																			closest_cases_map
																		)
																	)
															)
														)
													)
													(assign
														(assoc
															total_weight (apply
																	"+"
																	(values
																		closest_cases_map
																	)
																)
														)
													)

													;iterate over all the closest cases and accumulate the normalized weight to each one
													(map
														(lambda
															(seq

																;if accumulate_weight_feature label doesn't exist in this case, add it with a weight `1`
																(if
																	(not
																		(contains_label
																			(current_index)
																			accumulate_weight_feature
																		)
																	)
																	(accum_entity_roots
																		(current_index)
																		new_weight_label_and_value
																	)
																)
																(accum_to_entities
																	(current_index)
																	(associate
																		accumulate_weight_feature
																		(/
																			(current_value
																				1
																			)
																			total_weight
																		)
																	)
																)
															)
														)
														closest_cases_map
													)
												)
											)
											cases
										)
									)

									;Iterate over the specified model cases, pull their weight and distribute it to their corresponding neighbors into the neighbors' distribute_weight_feature
									;parameters:
									; features: feature set to use for finding neighbors
									; case_ids: list of model case ids whose weights need to be distributed
									; distribute_weight_feature : name of feature into which to pull cases' weight and distribute neighbors' influences as weight.
									##DistributeCaseInfluenceWeights
									(declare
										(assoc
											distribute_weight_feature ".case_weight"
											features defaultFeatures
											case_ids (list)
										)
										(declare
											(assoc
												new_weight_label_and_value (zip_labels
														(list
															distribute_weight_feature
														)
														(list
															1
														)
													)
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature ".none"
															feature ".targetless"
															mode "robust"
														)
													)
											)
										)
										(map
											(lambda
												(let
													(assoc
														case (current_value
																1
															)
														case_weight (retrieve_from_entity
																(current_value
																	1
																)
																distribute_weight_feature
															)
														closest_cases_map (assoc)
														total_weight 0
													)

													;if case doesn't have a weight, default it to 1.0
													(if
														(=
															(null)
															case_weight
														)
														(assign
															(assoc
																case_weight 1
															)
														)
													)
													(assign
														(assoc
															closest_cases_map (compute_on_contained_entities
																	(list
																		(query_not_in_entity_list
																			(list
																				case
																			)
																		)
																		(query_nearest_generalized_distance
																			(get
																				hyperparam_map
																				"k"
																			)
																			features
																			(retrieve_from_entity
																				case
																				features
																			)
																			(get
																				hyperparam_map
																				"featureWeights"
																			)
																			nominalClassCountsMap
																			cyclicFeaturesMap
																			(if
																				(get
																					hyperparam_map
																					"useDeviations"
																				)
																				(get
																					hyperparam_map
																					"featureDeviations"
																				)
																			)
																			(get
																				hyperparam_map
																				"p"
																			)
																			(get
																				hyperparam_map
																				"dwe"
																			)
																			(if
																				(!=
																					weight_feature
																					".none"
																				)
																				weight_feature
																				(null)
																			)

																			;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																			"fixed rand seed"
																			(null)

																			;radius
																			lpSpaceHeuristicMultiplier
																			(true)
																		)
																	)
																)
														)
													)

													;if there are perfect matches (value is infinite), keep only those and set their weight to 1
													(if
														(contains_value
															(values
																closest_cases_map
															)
															.infinity
														)
														(assign
															(assoc
																closest_cases_map
																	;keep only perfect matches
																	(map
																		1
																		(filter
																			(lambda
																				(=
																					(current_value)
																					.infinity
																				)
																			)
																			closest_cases_map
																		)
																	)
															)
														)
													)
													(assign
														(assoc
															total_weight (apply
																	"+"
																	(values
																		closest_cases_map
																	)
																)
														)
													)

													;iterate over all the closest cases and accumulate the normalized weight to each one
													(map
														(lambda
															(seq

																;if distribute_weight_feature label doesn't exist in this case, add it with a weight `1`
																(if
																	(not
																		(contains_label
																			(current_index)
																			distribute_weight_feature
																		)
																	)
																	(accum_entity_roots
																		(current_index)
																		new_weight_label_and_value
																	)
																)

																;distribute the corresponding portion of this case's weight based on the neighbor's influence
																(accum_to_entities
																	(current_index)
																	(associate
																		distribute_weight_feature
																		(*
																			case_weight
																			(/
																				(current_value
																					1
																				)
																				total_weight
																			)
																		)
																	)
																)
															)
														)
														closest_cases_map
													)
												)
											)
											case_ids
										)
									)
								)

								;module for trainee_template
								;contains methods for calculating explanations and audit data output during react flow
								(null

									;Returns explanation and audit data for a given reaction for the specified audit data flags. Explanations for actions are applicable only for the
									;first action feature.
									;
									;	Local and regional models are used to determine explanations:
									;		Local model -  only the most similar cases used to directly determine the prediction value, used to compute affects of cases directly
									;						responsible for the predicted output.
									;		Regional model - the most similar cases to the prediction, represented by the maximum of either 30 or the local model size. Used in
									;						situations where relying on a small local model may produce noisy results.
									; details: an assoc of flags for which type of audit data to return, and corresponding values to return (if applicable) in the format of:
									;	(assoc
									;		"prediction_conviction" true or false. If true returns prediction conviction for case, which is defined as the ratio of expected
									;			surprisal to observed surprisal based on the the probability density functions corresponding to distance of the residual
									;			compared to the expected residual. Will also output similarity_conviction, residual_conviction and residual_dissimilarity_conviction.
									;		"influential_cases" true or false. If true returns the most influential cases and their influence weights based on generalized
									;			distances as probability mass.
									;		"influential_cases_familiarity_conviction" true or false. If true returns familiarity convction for each of the influential cases.
									;		"raw_influence_weights" true or false. If true returns generalized distance modified by distance weight exponent for each of the influential cases.
									;		"most_similar_cases" true or false. Returns an automatically determined relevant number of similar cases, which will first include the influential cases.
									;		"num_most_similar_cases" num_cases_to_return. Returns the specified number similar cases, the number of the closest cases specified,
									;			which will first include the influential cases. Takes precedence over 'most_similar_cases' parameter.
									;       "num_most_similar_case_indices" num_case_indices_to_return. Returns the specified number of most similar case indices.
									;			Relies on the "distance_ratio" flag.
									;		"boundary_cases" true or false. Returns the an automatically determined relevant number of boundary cases.
									;		"num_boundary_cases" num_cases_to_return. Returns the specified number of boundary cases. Takes precedence over 'boundary_cases' parameter.
									;		'boundary_cases_familiarity_conviction" true or false. If true returns familiarity convction for each of the boundary cases.
									;		"feature_familiarity_conviction" true or false. If true returns the expected feature familiarity convictions of the region.
									;		"feature_familiarity_conviction_ratios" true or false; If true returns regional feature familiarity conviction values and ratios to the full model
									;			Selecting features are those whose ratio of regional feature familiarity conviction to model feature familiarity conviction
									;			deviates the most from a ratio value of one.
									;		"feature_prediction_conviction" true or false. If true returns expected feature prediction convictions for the region and feature prediction contributions.
									;			Relevant features are those whose prediction contribution is the most positive.
									;			Noisy features are those whose prediction contribution is the most negative.
									;			Irrelevant features are those whose prediction contribution is close to zero.
									;		"outlying_feature_values" true or false. If true returns the prediction's feature values that are outside of the regional model's
									;			min or max for those features.
									;		"categorical_action_probabilities" true or false. If true returns probabilities for the action features if they are categorical.
									;		"robust_computation" true or false. Default is False, uses leave-one-out for features (or cases, as needed) for all relevant computations. When True, uses
									;			uniform sampling from the power set of all combinations of features (or cases, as needed) instead.
									;		"feature_residuals" true or false. If true returns feature residuals for the regional model around the prediction. Relies on 'robust_computation' flag.
									;		"feature_mda" true or false. If true returns the mean decrease in accuracy for the local model as an interpretation
									;			to how the prediction was made. Relies on 'robust_computation' flag.
									;		"feature_mda_ex_post" true or false. If true returns the mean decrease in accuracy for the local model as an explanation
									;			given that the specified prediction was made. Relies on 'robust_computation' flag.
									;		"feature_contributions" true or false. If true returns an assoc of difference between the predicted action_value and the predicted action_value if
									;			each feature were not in the model. The output is an assoc of feature -> delta value from prediction action_value. Relies on 'robust_computation' flag.
									;		"case_mda" true or false. If true returns the mean decrease in accuracy for the local model, as if each individual case were not in the model.
									;			The output list is of assocs where each contains a cases's .session, .session_training_index and mda. Relies on 'robust_computation' flag.
									;		"case_contributions" true or false. If true returns a list of difference between the predicted action_value and the predicted action_value if
									;			each individual case were not in the model. The output list is of assocs where each contains a cases's .session, .session_training_index and action_delta.
									;			Relies on 'robust_computation' flag.
									;		"case_feature_residuals"  true or false. If true returns the hold-one-out 'case_feature_residuals' for the prediction of each feature in just this case.
									;			Relies on 'robust_computation' flag.
									;		"local_case_feature_residual_convictions" true or false. If true this case's feature residual convictions for the local model.
									;			Relies on 'robust_computation' flag.
									;		"global_case_feature_residual_convictions" true or false. If true this case's feature residual convictions for the global model.
									;			Relies on 'robust_computation' flag.
									;		"hypothetical_values" assoc context feature -> values.  If specified, will iterate over all influential cases, replacing each cases's
									;			feature value with the specified one, then leaves the case out while predicting action_features. Outputs predicted arithmetic
									;			average for each action feature.
									;		"distance_ratio" true or false. If true, returns the ratio of the minimum distance in the local model to the nearest distance to the
									;			context values.
									;	)
									; action_features: list of action features
									; action_values: list of values for each action feature
									; context_features: list of context features
									; context_values: current values of the world state
									; extra_audit_features: list of additional features to return with audit data
									; num_features_returned: if return audit data, will return up to this many specified features in the explanation
									; ignore_case: case_id, if set will ignore the this case during explanation calculations, however if details assoc has ignore_case as a key in it, its value will override this parameter
									; force_targetless: flag, if set to true forces use of targetless hyperparameters if available
									;returns:
									; an assoc with keys:
									;	"action_features"
									;  	"action_values"
									;  	"context_values"
									; and the following keys as appropriately requested:
									;	"influential_cases"
									;	"most_similar_cases"
									;	"boundary_cases"
									;	"categorical_action_probabilities"
									;	"prediction_conviction"
									;	"similarity_conviction"
									;	"residual_conviction"
									;	"residual_dissimilarity_conviction"
									;	"feature_residuals"
									;	"user_specified_feature_deviations"
									;	"locally_outlying_feature_values"
									;	"feature_mda"
									;	"feature_mda_ex_post"
									;	"feature_contributions"
									;	"case_mda"
									;	"case_contributions"
									;	"case_feature_residuals"
									;	"local_case_feature_residual_convictions"
									;	"global_case_feature_residual_convictions"
									;	"feature_prediction_contribution"
									;	"feature_prediction_conviction"
									;	"feature_familiarity_conviction"
									;	"feature_familiarity_conviction_ratios"
									;   "hypothetical_values"]
									##RetrieveAuditData
									(declare
										(assoc
											context_values (list)
											details (assoc)
											ignore_case (null)
											force_targetless (false)
											extra_audit_features (list)
											action_values (list)
											action_features (list)
											hyperparam_map (null)
											context_features (list)
											num_features_returned (null)
										)

										;override the ignore_case parameter if it's specified in the details instead
										(if
											(contains_index details "ignore_case")
											(assign
												(assoc
													ignore_case (get
															details
															"ignore_case"
														)
												)
											)
										)
										(declare
											(assoc
												model_size (call
														GetNumTrainingCases
													)
												has_datetime_features hasDateTimeFeatures
												has_rounded_features hasRoundedFeatures
											)
										)
										(if
											(= (null) hyperparam_map)
											(assign
												(assoc
													hyperparam_map (call
															GetHyperparameters
															(assoc
																weight_feature weight_feature
																feature (last
																		action_features
																	)
																mode (if
																		force_targetless
																		"robust"
																		"full"
																	)
															)
														)
												)
											)
										)
										(assign
											(assoc
												context_deviations (if
														(get
															hyperparam_map
															"useDeviations"
														)
														(get
															hyperparam_map
															"featureDeviations"
														)
													)
											)
										)

										;must be an empty list if not specified as to not break queries
										(if
											(= (null) filtering_queries)
											(assign
												(assoc
													filtering_queries (list)
												)
											)
										)
										(declare
											(assoc
												p_parameter (get
														hyperparam_map
														"p"
													)
												feature_weights (get
														hyperparam_map
														"featureWeights"
													)
												k_parameter (get
														hyperparam_map
														"k"
													)
												features (append
														context_features
														action_features
													)
												robust_computation (get
														details
														"robust_computation"
													)
												min_regional_model_size_by_percent (max
														3
														(get
															hyperparam_map
															"k"
														)
														(*
															model_size
															regionalModelMinPercent
														)
													)
												dwe_parameter (get
														hyperparam_map
														"dwe"
													)
												output (assoc
														action_values (if
																(and
																	hasEncodedFeatures
																	(not
																		skip_decoding
																	)
																)

																;decode nominal features
																(call
																	ConvertToOutput
																	(assoc
																		has_datetime_features has_datetime_features
																		feature_values action_values
																		features action_features
																		has_rounded_features has_rounded_features
																	)
																)

																;else round if needed
																has_rounded_features
																(call
																	RoundContinuousFeatures
																	(assoc
																		feature_values action_values
																		features action_features
																	)
																)

																;else just return the values
																action_values
															)
														context_values (if
																(and
																	hasEncodedFeatures
																	(not
																		skip_decoding
																	)
																)

																;decode nominal features if necessary
																(call
																	ConvertToOutput
																	(assoc
																		feature_values context_values
																		features context_features
																	)
																)
																hasRoundedFeatures
																(call
																	RoundContinuousFeatures
																	(assoc
																		feature_values context_values
																		features context_features
																	)
																)

																;else just return the values
																context_values
															)
													)
											)
										)
										(if
											(or
												(get
													details
													"case_feature_residuals"
												)
												(get
													details
													"local_case_feature_residual_convictions"
												)
												(get
													details
													"global_case_feature_residual_convictions"
												)
											)
											(call
												CalculateResidualsForCase
												(assoc
													case_values (append
															context_values
															action_values
														)
													ignore_case ignore_case
													features features
												)
											)
										)
										(if
											(or
												(get
													details
													"influential_cases"
												)
												(get
													details
													"hypothetical_values"
												)
											)
											(call ComputeInfluentialCases)
										)
										(if
											(get details "hypothetical_values")
											(call ComputeHypotheticalValues)
										)
										(declare
											(assoc
												most_similar_cases_parameter (if
														(>
															(get
																details
																"num_most_similar_cases"
															)
															0
														)
														(get
															details
															"num_most_similar_cases"
														)
														(get
															details
															"most_similar_cases"
														)
													)
											)
										)
										(if
											(and
												(!=
													(null)
													most_similar_cases_parameter
												)
												(!=
													(false)
													most_similar_cases_parameter
												)
											)
											(call ComputeMostSimilarCases)
										)
										(if
											(get details "prediction_conviction")
											(let
												(assoc
													prediction_conviction_tuple (call
															ComputeCasePredictionConviction
															(assoc
																feature_values (append
																		context_values
																		action_values
																	)
																weight_feature weight_feature
																case_id ignore_case
																features features
																use_case_weights use_case_weights
																action_features action_features
															)
														)
												)

												;update the output with conviction for this react case
												(accum
													(assoc
														output (assoc
																similarity_conviction (/
																		1
																		(first
																			prediction_conviction_tuple
																		)
																	)
																residual_dissimilarity_conviction (get
																		prediction_conviction_tuple
																		1
																	)
																prediction_conviction (/
																		2
																		(+
																			(first
																				prediction_conviction_tuple
																			)
																			(last
																				prediction_conviction_tuple
																			)
																		)
																	)
																residual_conviction (/
																		1
																		(last
																			prediction_conviction_tuple
																		)
																	)
															)
													)
												)
											)
										)
										(declare
											(assoc
												boundary_cases_parameter (if
														(>
															(get
																details
																"num_boundary_cases"
															)
															0
														)
														(get
															details
															"num_boundary_cases"
														)
														(get
															details
															"boundary_cases"
														)
													)
											)
										)
										(if
											(and
												(!=
													(null)
													boundary_cases_parameter
												)
												(!=
													(false)
													boundary_cases_parameter
												)
											)
											(call ComputeBoundaryCases)
										)

										;a dict of feature -> dict of local_min/local_max and input_case_value for features whose context values are outside the locals' min-max
										(if
											(get details "outlying_feature_values")
											(call ComputeOutlyingFeatureValues)
										)
										(if
											(get details "feature_mda")
											(call ComputeFeatureMDA)
										)
										(if
											(get details "feature_mda_ex_post")
											(call ComputeFeatureMDAExPost)
										)
										(if
											(get details "feature_contributions")
											(if
												(>=
													model_size
													2
												)
												(call ComputeFeatureContributions)

												;can't compute contributions if model is too small
												(accum
													(assoc
														output (assoc
																feature_contributions (zip
																		context_features
																		0
																	)
															)
													)
												)
											)
										)
										(if
											(get details "case_contributions")
											(if
												robust_computation
												(call ComputeCaseContributionsRobust)
												(call ComputeCaseContributions)
											)
										)
										(if
											(get details "case_mda")
											(call ComputeCaseMDA)
										)

										;any feature explanations requested
										(if
											(or
												(get
													details
													"feature_familiarity_conviction"
												)
												(get
													details
													"feature_prediction_conviction"
												)
												(get
													details
													"feature_familiarity_conviction_ratios"
												)
											)
											(call ComputeFeatureExplationConvictions)
										)

										;append feature errors and deviations
										(if
											(get details "feature_residuals")
											(call ComputeReactFeatureResiduals)
										)
										(if
											(get details "categorical_action_probabilities")
											(call ComputeCategoricalActionProbabilities)
										)
										(declare
											(assoc
												most_similar_case_indices_parameter (if

														; If the user manually specifies a number of most similar case indices to fetch
														; when computing distance ratios,
														(!=
															(get
																details
																"num_most_similar_case_indices"
															)
															(null)
														)

														; Use that number
														(get
															details
															"num_most_similar_case_indices"
														)

														; Else use 5
														5
													)
											)
										)
										(if
											(get details "distance_ratio")
											(call ComputeDistanceRatio)
										)

										;return the output audit data
										output
									)

									;Helper method to compute and add to output influential cases and influence weights
									##ComputeInfluentialCases
									(let
										(assoc
											output_raw_influence_weights (get
													details
													"raw_influence_weights"
												)
											closest_cases_map (assoc)
										)

										;if there is aren't enough cases in the influence weights map  - ie, if the action value was specified by user and not from a reaction,
										;then use the nearest neighbors as influencers
										(if
											(or
												(<
													(size
														influence_weights_map
													)
													k_parameter
												)
												output_raw_influence_weights
											)
											(seq
												(assign
													(assoc
														closest_cases_map (compute_on_contained_entities
																(append
																	filtering_queries
																	(query_nearest_generalized_distance
																		k_parameter
																		context_features
																		context_values
																		feature_weights
																		nominalClassCountsMap
																		cyclicFeaturesMap
																		context_deviations
																		p_parameter
																		dwe_parameter
																		(if
																			valid_weight_feature
																			weight_feature
																			(null)
																		)

																		;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																		"fixed rand seed"
																		(null)

																		;radius
																		lpSpaceHeuristicMultiplier
																		(true)
																	)
																)
															)
													)
												)
												(assign
													(assoc
														influence_weights_map
															;if there are perfect matches (influence value is infinite), set all influence to same (or weighted), all others are 0
															(if
																(contains_value
																	(values
																		closest_cases_map
																	)
																	.infinity
																)
																(map
																	(lambda
																		(if
																			(=
																				(current_value)
																				.infinity
																			)
																			(if
																				valid_weight_feature

																				;whatever the weight of the case, numerified so a null weight is 0
																				(+
																					(retrieve_from_entity
																						(current_index)
																						weight_feature
																					)
																				)

																				;else all perfect matches have same weight
																				1
																			)
																			0
																		)
																	)
																	closest_cases_map
																)

																;keep as is
																closest_cases_map
															)
													)
												)
											)
										)
										(declare
											(assoc
												total_influence_weight (apply
														"+"
														(values
															influence_weights_map
														)
													)
												sorted_influence_cases (sort
														(lambda
															(>
																(get
																	influence_weights_map
																	(current_value
																		1
																	)
																)
																(get
																	influence_weights_map
																	(current_value)
																)
															)
														)
														(indices
															influence_weights_map
														)
													)
											)
										)
										(declare
											(assoc
												accumulated_influence_weight_percent 0
												influential_k 0
											)
										)

										;figure out the influential_k that influences the majority (influenceWeightThreshold, default 99%) of the react value
										;by incrementing the weight of each of the most influential cases until the total weight passes the threshold
										;the count of those cases is the influential_k.
										(while
											(and
												(<=
													accumulated_influence_weight_percent
													influenceWeightThreshold
												)
												(<
													influential_k
													k_parameter
												)
											)
											(accum
												(assoc
													accumulated_influence_weight_percent (/
															(get
																influence_weights_map
																(get
																	sorted_influence_cases
																	influential_k
																)
															)
															total_influence_weight
														)
												)
											)
											(accum
												(assoc
													influential_k 1
												)
											)
										)

										;return the influential_K
										(declare
											(assoc
												candidate_case_ids (trunc
														sorted_influence_cases
														influential_k
													)
											)
										)

										;pull all the feature values for the cases
										(declare
											(assoc
												audit_data (map
														(lambda
															(let
																(assoc
																	case_data (retrieve_from_entity
																			(current_value
																				1
																			)
																			(zip
																				(append
																					features
																					internalLabelSession
																					internalLabelSessionTrainingIndex
																					internalLabelImputed
																					extra_audit_features
																				)
																			)
																		)
																)

																;don't show imputed list if it's empty
																(if
																	(=
																		(null)
																		(get
																			case_data
																			internalLabelImputed
																		)
																	)
																	(remove
																		case_data
																		internalLabelImputed
																	)
																	case_data
																)
															)
														)
														candidate_case_ids
													)
											)
										)

										;append influence weight to output and normalize it by the total_influence_weight
										(assign
											(assoc
												audit_data (map
														(lambda
															(append
																(current_value)
																(assoc
																	".influence_weight" (/
																			(or
																				(get
																					influence_weights_map
																					(get
																						candidate_case_ids
																						(current_index
																							1
																						)
																					)
																				)
																			)
																			total_influence_weight
																		)
																)
																(if
																	output_raw_influence_weights
																	(assoc
																		".raw_influence_weight" (get
																				closest_cases_map
																				(get
																					candidate_case_ids
																					(current_index
																						1
																					)
																				)
																			)
																	)

																	;else append nothing
																	(assoc)
																)
															)
														)
														audit_data
													)
											)
										)

										;compute and set conviction for each of the similar cases if requested
										(if
											(and
												(get
													details
													"influential_cases_familiarity_conviction"
												)
												(!=
													(null)
													storedCaseConvictionsFeatureAddition
												)
											)
											(assign
												(assoc
													audit_data (map
															(lambda
																(let
																	(assoc
																		familiarity_conviction (retrieve_from_entity
																				(get
																					candidate_case_ids
																					(current_index
																						1
																					)
																				)
																				storedCaseConvictionsFeatureAddition
																			)
																	)

																	;set the conviction in the audit_data output
																	(set
																		(current_value)
																		storedCaseConvictionsFeatureAddition
																		familiarity_conviction
																	)
																)
															)
															audit_data
														)
												)
											)
										)

										;update the output explanation with this audit data
										(accum
											(assoc
												output (assoc
														influential_cases (if
																(and
																	(not
																		skip_decoding
																	)
																	(or
																		hasEncodedFeatures
																		has_rounded_features
																	)
																)
																(call
																	ConvertToOutputFromCaseList
																	(assoc
																		cases audit_data
																	)
																)

																;else just return the cases as-is
																audit_data
															)
													)
											)
										)
									)

									;Helper method to compute and add to output hypothetical values
									##ComputeHypotheticalValues
									(let
										(assoc
											summed_action_values (list)
											hypothetical_action_values_map (assoc)
											hypothetical_map (get
													details
													"hypothetical_values"
												)
											nominal_count_map (assoc)
										)
										(declare
											(assoc
												reacts (map
														(lambda
															(let
																(assoc
																	hypothetical_context_values (unzip
																			(append
																				(current_value
																					1
																				)
																				hypothetical_map
																			)
																			context_features
																		)
																	session_index_tuple (list
																			(get
																				(current_value
																					2
																				)
																				internalLabelSession
																			)
																			(get
																				(current_value
																					2
																				)
																				internalLabelSessionTrainingIndex
																			)
																		)
																)
																(call
																	ReactDiscriminative
																	(assoc
																		context_values hypothetical_context_values
																		return_action_values_only (true)
																		skip_decoding (true)
																		leave_case_out (true)
																		action_features action_features
																		context_features context_features
																		case_indices session_index_tuple
																	)
																)
															)
														)
														(get
															output
															"influential_cases"
														)
													)
											)
										)

										;reacts will be a list of list of action values.  e.g., (list (list 1 10) (list 2 20) )
										;find the average for each action feature by summing up (via reduce) all the action values per action feature
										(assign
											(assoc
												summed_action_values (reduce
														(lambda
															(let
																(assoc
																	current (current_value
																			1
																		)
																	index (get_value
																			(current_index
																				1
																			)
																		)
																	reduced (previous_result
																			1
																		)
																)
																(map
																	(lambda

																		;nominal features need to count each individual nominal value for each action feature
																		(if
																			(contains_index
																				nominalsSet
																				(current_value)
																			)
																			(let
																				(assoc
																					feature (current_value
																							1
																						)
																					nominal_value (unparse
																							(get
																								current
																								(current_index
																									1
																								)
																							)
																						)
																				)

																				;the first react to should accumulate the 'reduced' value
																				(if
																					(=
																						1
																						index
																					)
																					(accum
																						"nominal_count_map"
																						(list
																							feature
																							(unparse
																								(get
																									reduced
																									(current_index
																										1
																									)
																								)
																							)
																						)
																						1
																					)
																				)

																				;increase the count for this feature for this nominal_value by 1
																				(accum
																					"nominal_count_map"
																					(list
																						feature
																						nominal_value
																					)
																					1
																				)

																				;output 0, it'll be overwritten by the appropriate nominal value determined from counts below
																				0
																			)

																			;else continous, simply add
																			(+
																				(get
																					reduced
																					(current_index)
																				)
																				(get
																					current
																					(current_index)
																				)
																			)
																		)
																	)
																	action_features
																)
															)
														)
														reacts
													)
											)
										)

										;take the average of the summed values
										(assign
											(assoc
												hypothetical_action_values_map (zip
														action_features
														(map
															(lambda
																(/
																	(current_value)
																	(size
																		reacts
																	)
																)
															)
															summed_action_values
														)
													)
											)
										)

										;for each nominal feature, set its value to be the one with the highest count
										(map
											(lambda
												(if
													(contains_index
														nominalsSet
														(current_value)
													)
													(let
														(assoc
															nominal_value_count_map (get
																	nominal_count_map
																	(current_value
																		1
																	)
																)
															feature (current_value
																	1
																)
															output_value (null)
														)
														(assign
															(assoc
																output_value (first
																		(sort
																			(lambda
																				(>
																					(get
																						nominal_value_count_map
																						(current_value
																							1
																						)
																					)
																					(get
																						nominal_value_count_map
																						(current_value)
																					)
																				)
																			)
																			(indices
																				nominal_value_count_map
																			)
																		)
																	)
															)
														)

														;indices of a map are all strings, so convert them to correct types if necessary
														(assign
															"hypothetical_action_values_map"
															(list
																feature
															)
															(if
																(=
																	.nas
																	output_value
																)
																(null)
																(contains_index
																	nonStringNominalFeaturesMap
																	action_feature
																)
																(+
																	output_value
																)
																(contains_index
																	ordinalNumericFeaturesSet
																	action_feature
																)
																(+
																	output_value
																)
																output_value
															)
														)
													)
												)
											)
											action_features
										)

										;add to output, converting to string nominals/dates/rounding as necessary
										(accum
											(assoc
												output (assoc
														hypothetical_values (if
																(and
																	(not
																		skip_decoding
																	)
																	hasEncodedFeatures
																)
																(zip
																	action_features
																	(call
																		ConvertToOutput
																		(assoc
																			feature_values (unzip
																					hypothetical_action_values_map
																					action_features
																				)
																			features action_features
																		)
																	)
																)

																;else just output the the assoc as-is
																hypothetical_action_values_map
															)
													)
											)
										)

										;if influential_cases were not part of the user request, remove them from the explanation output
										(if
											(not
												(get
													details
													"influential_cases"
												)
											)
											(assign
												(assoc
													output (remove
															output
															"influential_cases"
														)
												)
											)
										)
									)

									;Helper method to compute and add to output most similar cases
									##ComputeMostSimilarCases
									(let
										(assoc
											specified_num_exemplars most_similar_cases_parameter
											similar_cases_map (assoc)
										)
										(declare
											(assoc
												num_exemplars
													;only use the specified amount if it's between 1 and 100, true means use default
													(if
														(=
															(true)
															(get_type
																specified_num_exemplars
															)
														)

														;use the default amount
														k_parameter
														(and
															(>
																specified_num_exemplars
																0
															)
															(<=
																specified_num_exemplars
																1000
															)
														)
														specified_num_exemplars
														(<
															specified_num_exemplars
															1
														)
														1
														(>
															specified_num_exemplars
															1000
														)
														1000
													)
											)
										)
										(assign
											(assoc
												similar_cases (compute_on_contained_entities
														(append
															filtering_queries
															(query_nearest_generalized_distance
																num_exemplars
																context_features
																context_values
																feature_weights
																nominalClassCountsMap
																cyclicFeaturesMap
																context_deviations
																p_parameter
																1

																;DWE of 1 queries distance in ascending order
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)

																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
																(true)
															)
														)
													)
											)
										)
										(declare
											(assoc
												item_retrieval_map (zip
														(append
															features
															internalLabelSession
															internalLabelSessionTrainingIndex
															internalLabelImputed
															extra_audit_features
														)
													)
											)
										)

										;pull all the feature values for the cases
										(declare
											(assoc
												audit_data (map
														(lambda
															(let
																(assoc
																	case_data (set
																			(retrieve_from_entity
																				(get
																					(current_value
																						1
																					)
																					0
																				)

																				;case index
																				item_retrieval_map
																			)
																			".distance"
																			(get
																				(current_value
																					1
																				)
																				1
																			)
																		)
																)

																;don't show imputed list if it's empty
																(if
																	(=
																		(null)
																		(get
																			case_data
																			internalLabelImputed
																		)
																	)
																	(remove
																		case_data
																		internalLabelImputed
																	)
																	case_data
																)
															)
														)
														(get
															similar_cases
															0
														)

														;indices are the first item in similar_cases
														(get
															similar_cases
															1
														)
													)
											)
										)

										;update the output explanation with this audit data
										(accum
											(assoc
												output (assoc
														most_similar_cases (if
																(and
																	(not
																		skip_decoding
																	)
																	hasEncodedFeatures
																)
																(call
																	ConvertToOutputFromCaseList
																	(assoc
																		cases audit_data
																	)
																)

																;else just return the cases as-is
																audit_data
															)
													)
											)
										)
									)

									;Helper method to compute distance ratios
									##ComputeDistanceRatio
									(let
										(assoc
											local_model_cases_tuple (compute_on_contained_entities
													(append
														filtering_queries

														; The maximum local model size is 15, even if k is larger
														(query_nearest_generalized_distance
															(min
																15
																k_parameter
															)
															context_features
															context_values
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap

															;Feature deviations are not used in order to ensure that we are measuring privacy
															;assuming it has been maximally preserved. Deviations make cases look farther away than they are.
															(false)

															;feature_deviations
															p_parameter
															1

															; DWE of 1 queries distance in ascending order
															(null)

															; weight_feature is set to null so the computation done here matches the rejection criteria
															; in generate.amlg
															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															; radius
															lpSpaceHeuristicMultiplier
															(true)

															; recompute accurate distances
															(true)
														)
													)
												)
											num_most_similar_case_indices (min
													most_similar_case_indices_parameter
													15
												)
											dist_to_closest_case 0
										)
										(assign
											(assoc
												dist_to_closest_case (first
														(last
															local_model_cases_tuple
														)
													)
											)
										)

										; Compute distance contributions with k=1 to determine the smallest non-zero
										; distance between any two cases in the local model
										(assign
											(assoc
												local_model_min_distance_contribution (call
														QueryLocalModelMinDistanceContribution
														(assoc
															filtering_queries filtering_queries
															use_feature_deviations (false)
															feature_labels context_features
															entity_ids_to_compute (first
																	local_model_cases_tuple
																)
														)
													)
											)
										)

										; pull the session and session training index for the nearest neighbors
										(declare
											(assoc
												audit_data (if
														(>
															num_most_similar_case_indices
															0
														)
														(map
															(lambda
																(set
																	(retrieve_from_entity
																		(first
																			(current_value)
																		)

																		; case index
																		(zip
																			(list
																				".session"
																				".session_training_index"
																			)
																		)
																	)
																	".distance"
																	(last
																		(current_value)
																	)
																)
															)
															(tail
																(first
																	local_model_cases_tuple
																)
																num_most_similar_case_indices
															)
															(tail
																(last
																	local_model_cases_tuple
																)
																num_most_similar_case_indices
															)
														)
														(list)
													)
												distance_ratio (/
														dist_to_closest_case
														local_model_min_distance_contribution
													)
											)
										)
										(accum
											(assoc
												output (assoc
														most_similar_case_indices audit_data
														distance_ratio
															; the distance_ratio can be .infinity or .nan if there are no cases
															; in the model which are different from the cases being reacted to.
															; Since these are effectively no different from duplicates, from a
															; privacy standpoint, we return 0 in these cases.
															(if
																(=
																	distance_ratio
																	.infinity
																)
																0
																(=
																	distance_ratio
																	.nan
																)
																0
																distance_ratio
															)
													)
											)
										)
									)

									;Helper method to compute and add to output boundary cases
									##ComputeBoundaryCases
									(let
										(assoc specified_num_exemplars boundary_cases_parameter)
										(declare
											(assoc
												num_exemplars
													;only use the specified amount if it's between 1 and 100, true means use default
													(if
														(=
															(true)
															(get_type
																specified_num_exemplars
															)
														)

														;use the default amount
														k_parameter
														(and
															(>
																specified_num_exemplars
																0
															)
															(<=
																specified_num_exemplars
																1000
															)
														)
														specified_num_exemplars
														(<
															specified_num_exemplars
															1
														)
														1
														(>
															specified_num_exemplars
															1000
														)
														1000
													)
											)
										)

										;if getting boundary without specifying action features, use familiarity conviction as the boundary feature if it's been computed
										(if
											(and
												(=
													(list)
													action_features
												)
												(!=
													(null)
													storedCaseConvictionsFeatureAddition
												)
											)
											(assign
												(assoc
													details (set
															details
															"boundary_cases_familiarity_conviction"
															(true)
														)
													action_values
														;if conviction has already been computed because this is an existing case, use it
														(if
															(!=
																(null)
																ignore_case
															)
															(list
																(retrieve_from_entity
																	ignore_case
																	storedCaseConvictionsFeatureAddition
																)
															)

															;else use 1 as the default conviction value if none provided
															(list
																1
															)
														)
													action_features (list
															(get_value
																storedCaseConvictionsFeatureAddition
															)
														)
												)
											)
										)

										;get all the boundary case ids
										(declare
											(assoc
												candidate_case_ids (call
														GetBoundaryCaseIds
														(assoc
															context_values context_values
															num_cases_returned num_exemplars
															extra_audit_features extra_audit_features
															action_values action_values
															action_features action_features
															context_features context_features
														)
													)
											)
										)

										;if there is no influence_weights_map, calculate it
										(if
											(=
												(size influence_weights_map)
												0
											)
											(let
												(assoc
													closest_cases_map (compute_on_contained_entities
															(append
																filtering_queries
																(query_nearest_generalized_distance
																	k_parameter
																	context_features
																	context_values
																	feature_weights
																	nominalClassCountsMap
																	cyclicFeaturesMap
																	context_deviations
																	p_parameter
																	dwe_parameter
																	(if
																		valid_weight_feature
																		weight_feature
																		(null)
																	)

																	;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																	"fixed rand seed"
																	(null)
																	lpSpaceHeuristicMultiplier
																	(true)
																)
															)
														)
												)
												(assign
													(assoc
														influence_weights_map
															;if there are perfect matches (weight is infinite), all their influence is same, all others are 0
															(if
																(contains_value
																	(values
																		closest_cases_map
																	)
																	.infinity
																)
																(map
																	(lambda
																		(if
																			(=
																				(current_value)
																				.infinity
																			)
																			1
																			0
																		)
																	)
																	closest_cases_map
																)

																;keep as is
																closest_cases_map
															)
													)
												)
											)
										)

										;pull all the feature values for the cases
										(declare
											(assoc
												audit_data (map
														(lambda
															(let
																(assoc
																	case_data (retrieve_from_entity
																			(current_value
																				1
																			)
																			(zip
																				(append
																					features
																					internalLabelSession
																					internalLabelSessionTrainingIndex
																					internalLabelImputed
																					extra_audit_features
																				)
																			)
																		)
																)

																;don't show imputed list if it's empty
																(if
																	(=
																		(null)
																		(get
																			case_data
																			internalLabelImputed
																		)
																	)
																	(remove
																		case_data
																		internalLabelImputed
																	)
																	case_data
																)
															)
														)
														candidate_case_ids
													)
											)
										)

										;influence weight is scaled by the total and should add up to 1, assuming there are influence weights on boundary cases
										(declare
											(assoc
												total_influence_weight (apply
														"+"
														(values
															influence_weights_map
														)
													)
											)
										)

										;append influence weight to output and normalize it by the total_influence_weight
										(assign
											(assoc
												audit_data (map
														(lambda
															(set
																(current_value)
																".influence_weight"
																(if
																	total_influence_weight
																	(/
																		(or
																			(get
																				influence_weights_map
																				(get
																					candidate_case_ids
																					(current_index)
																				)
																			)
																		)
																		total_influence_weight
																	)

																	; don't divide by an invalid total_influence_weight to prevent outputting nan
																	0
																)
															)
														)
														audit_data
													)
											)
										)

										;compute and set conviction for each of the boundary cases if requested
										(if
											(and
												(get
													details
													"boundary_cases_familiarity_conviction"
												)
												(!=
													(null)
													storedCaseConvictionsFeatureAddition
												)
											)
											(assign
												(assoc
													audit_data (map
															(lambda
																(let
																	(assoc
																		familiarity_conviction (retrieve_from_entity
																				(get
																					candidate_case_ids
																					(current_index
																						1
																					)
																				)
																				storedCaseConvictionsFeatureAddition
																			)
																	)

																	;set the conviction in the audit_data output
																	(set
																		(current_value)
																		storedCaseConvictionsFeatureAddition
																		familiarity_conviction
																	)
																)
															)
															audit_data
														)
												)
											)
										)
										(accum
											(assoc
												output (assoc
														boundary_cases (if
																(and
																	(not
																		skip_decoding
																	)
																	hasEncodedFeatures
																)
																(call
																	ConvertToOutputFromCaseList
																	(assoc
																		cases audit_data
																	)
																)

																;else just return the cases as-is
																audit_data
															)
													)
											)
										)
									)

									;Helper method to compute and add to output outlying feature values
									##ComputeOutlyingFeatureValues
									(let
										(assoc
											react_case (zip
													features
													(append
														context_values
														action_values
													)
												)
											local_model_case_ids (if
													(!=
														(null)
														cached_candidate_cases_map
													)
													(indices
														cached_candidate_cases_map
													)
													(contained_entities
														(append
															filtering_queries
															(query_nearest_generalized_distance
																(min
																	min_regional_model_size_by_percent
																	k_parameter
																)
																context_features
																context_values
																feature_weights
																nominalClassCountsMap
																cyclicFeaturesMap
																context_deviations
																p_parameter
																dwe_parameter
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)

																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
															)
														)
													)
												)
										)
										(declare
											(assoc
												local_model_cases (map
														(lambda
															(retrieve_from_entity
																(current_value)
																(zip
																	features
																)
															)
														)
														local_model_case_ids
													)
											)
										)

										;for the labeled react case, create a map of feature names and their values for all values that are outside min/max boundaries of
										;values in the local model
										;react case values that are beyond the min/max values of the local model's cases for each feature
										(declare
											(assoc
												local_model_outlying_feature_values (map
														(lambda
															(let
																(assoc
																	feature (current_index
																			1
																		)
																)

																;store the values for this feature for all the local model cases
																(declare
																	(assoc
																		local_model_feature_values (map
																				(lambda
																					(get
																						(current_value)
																						feature
																					)
																				)
																				local_model_cases
																			)
																	)
																)
																(declare
																	(assoc
																		local_max (apply
																				"max"
																				local_model_feature_values
																			)
																		react_value (+
																				(get
																					react_case
																					feature
																				)
																			)
																		local_min (apply
																				"min"
																				local_model_feature_values
																			)
																	)
																)

																;if the feature value from the react case is outside the min/max values of nearby cases,
																;store this feature as an outlier
																(if
																	(or
																		(<
																			react_value
																			local_min
																		)
																		(>
																			react_value
																			local_max
																		)
																	)
																	(if
																		(<
																			react_value
																			local_min
																		)
																		(assoc
																			input_case_value react_value
																			local_min local_min
																		)
																		(assoc
																			input_case_value react_value
																			local_max local_max
																		)
																	)

																	;else store null
																	(null)
																)
															)
														)
														(zip
															context_features
														)
													)
											)
										)

										;filter out any feature values that are null
										(assign
											(assoc
												local_model_outlying_feature_values (filter
														local_model_outlying_feature_values
													)
											)
										)
										(accum
											(assoc
												output (assoc
														locally_outlying_feature_values local_model_outlying_feature_values
													)
											)
										)
									)

									;Helper method to compute and add to output local feature MDA
									##ComputeFeatureMDA
									(let
										(assoc
											local_model_case_ids (if
													(!=
														(null)
														cached_candidate_cases_map
													)
													(indices
														cached_candidate_cases_map
													)
													(contained_entities
														(append
															filtering_queries
															(query_nearest_generalized_distance
																k_parameter
																context_features
																context_values
																feature_weights
																nominalClassCountsMap
																cyclicFeaturesMap
																context_deviations
																p_parameter
																dwe_parameter
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)

																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
															)
														)
													)
												)
										)

										;for robust computation, increase the number of cases to improve accuracy
										(if
											robust_computation
											(let
												(assoc
													num_robust_cases (max
															100
															(*
																k_parameter
																(+
																	1
																	(log
																		(size
																			(zip
																				features
																			)
																		)
																	)
																)
															)
														)
												)

												;pick the needed number of cases randomly with replacament from the set of specified case_ids
												(assign
													(assoc
														local_model_case_ids (rand
																local_model_case_ids
																num_robust_cases
															)
													)
												)
											)
										)
										(accum
											(assoc
												output (assoc
														feature_mda (call
																DecreaseInAccuracy
																(assoc
																	robust robust_computation
																	case_ids local_model_case_ids
																	action_features action_features
																	context_features context_features
																)
															)
													)
											)
										)
									)

									;Helper method to compute and add to output local feature ex-post MDA
									##ComputeFeatureMDAExPost
									(let
										(assoc
											targetless_hyperparam_map (call
													GetHyperparameters
													(assoc
														weight_feature weight_feature
														feature ".targetless"
														mode (if
																(or
																	force_targetless
																	robust_computation
																)
																"robust"
																"full"
															)
													)
												)
										)
										(declare
											(assoc
												targetless_k (get
														targetless_hyperparam_map
														"k"
													)
												local_model_case_ids (contained_entities
														(append
															filtering_queries
															(query_nearest_generalized_distance
																(get
																	targetless_hyperparam_map
																	"k"
																)
																features
																(append
																	context_values
																	action_values
																)
																(get
																	targetless_hyperparam_map
																	"featureWeights"
																)
																nominalClassCountsMap
																cyclicFeaturesMap
																(if
																	(get
																		targetless_hyperparam_map
																		"useDeviations"
																	)
																	(get
																		targetless_hyperparam_map
																		"featureDeviations"
																	)
																)
																(get
																	targetless_hyperparam_map
																	"p"
																)
																(get
																	targetless_hyperparam_map
																	"dwe"
																)
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)

																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
															)
														)
													)
											)
										)

										;for robust computation, increase the number of cases to improve accuracy
										(if
											robust_computation
											(let
												(assoc
													num_robust_cases (max
															100
															(*
																targetless_k
																(+
																	1
																	(size
																		(zip
																			features
																		)
																	)
																)
															)
														)
												)

												;pick the needed number of cases randomly with replacament from the set of specified case_ids
												(assign
													(assoc
														local_model_case_ids (rand
																local_model_case_ids
																num_robust_cases
															)
													)
												)
											)
										)
										(accum
											(assoc
												output (assoc
														feature_mda_ex_post (call
																DecreaseInAccuracy
																(assoc
																	robust robust_computation
																	case_ids local_model_case_ids
																	action_features action_features
																	context_features context_features
																)
															)
													)
											)
										)
									)

									;Helper method to compute and add to output feature convictions
									##ComputeFeatureExplationConvictions
									(let
										(assoc
											feature_familiarity_conviction_ratios (if
													(get
														details
														"feature_familiarity_conviction_ratios"
													)
													(true)
													(false)
												)
											feature_familiarity_conviction (if
													(get
														details
														"feature_familiarity_conviction"
													)
													(true)
													(false)
												)
											regional_model_cases_map (compute_on_contained_entities
													(append
														filtering_queries
														(query_nearest_generalized_distance

															;closest n should have a limit of how small it can be
															(min
																min_regional_model_size_by_percent
																(max
																	k_parameter
																	regionalModelMinSize
																)
															)
															context_features
															context_values
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															context_deviations
															p_parameter
															dwe_parameter
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															(true)
														)
													)
												)
											feature_prediction_conviction (if
													(get
														details
														"feature_prediction_conviction"
													)
													(true)
													(false)
												)
										)

										;calculate the feature explanations for the local model
										(declare
											(assoc
												explanation_of_features (call
														ExplainFeatures
														(assoc
															feature_familiarity_conviction_ratios feature_familiarity_conviction_ratios
															context_values context_values
															feature_familiarity_conviction feature_familiarity_conviction
															case_ids (indices
																	regional_model_cases_map
																)
															action_features action_features
															feature_prediction_conviction feature_prediction_conviction
															context_features context_features
														)
													)
											)
										)
										(if
											feature_familiarity_conviction
											(accum
												(assoc
													output (assoc
															feature_familiarity_conviction (get
																	explanation_of_features
																	"feature_familiarity_conviction"
																)
														)
												)
											)
										)
										(if
											feature_familiarity_conviction_ratios
											(accum
												(assoc
													output (assoc
															feature_familiarity_conviction_ratios (get
																	explanation_of_features
																	"feature_familiarity_conviction_ratios"
																)
														)
												)
											)
										)
										(if
											feature_prediction_conviction
											(accum
												(assoc
													output (assoc
															feature_prediction_contribution (get
																	explanation_of_features
																	"feature_prediction_contribution"
																)
															feature_prediction_conviction (get
																	explanation_of_features
																	"feature_prediction_conviction"
																)
														)
												)
											)
										)
									)

									;Helper method to compute and add to output local feature residuals
									##ComputeReactFeatureResiduals
									(declare
										(assoc
											relevant_features (append
													context_features
													action_features
												)
											regional_model_cases_map (compute_on_contained_entities
													(append
														filtering_queries
														(query_nearest_generalized_distance

															;closest n should have a limit of how small it can be
															(min
																min_regional_model_size_by_percent
																(max
																	k_parameter
																	regionalModelMinSize
																)
															)
															context_features
															context_values
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															context_deviations
															p_parameter
															dwe_parameter
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)
															lpSpaceHeuristicMultiplier
															(true)
														)
													)
												)
										)
										(declare
											(assoc
												user_specified_errors (if
														(>
															(size
																userSpecifiedFeatureErrorsMap
															)
															0
														)
														(unzip
															userSpecifiedFeatureErrorsMap
															relevant_features
														)

														;else
														(null)
													)
												local_feature_residuals (if
														(>=
															model_size
															2
														)
														(call
															CalculateFeatureResiduals
															(assoc
																compute_low_and_high_mae (true)
																robust_residuals robust_computation
																residual_features relevant_features
																features relevant_features
																cases_map regional_model_cases_map
															)
														)

														;can't compute residuals if model is too small
														(zip
															relevant_features
															0
														)
													)
											)
										)

										;append feature deviations to output
										(accum
											(assoc
												output (assoc
														feature_residuals local_feature_residuals
													)
											)
										)

										;append user specified values only if they exist, anly return them for the relevant features
										(if
											(!= user_specified_errors (null))
											(accum
												(assoc
													output (assoc
															user_specified_feature_deviations (zip
																	relevant_features
																	user_specified_errors
																)
														)
												)
											)
										)
									)

									;Helper method to compute and add to output categorical action probabilities
									##ComputeCategoricalActionProbabilities
									(seq

										;since categorical_action_probabilities_map may contain encoded nominal values -> their probability, we want to convert all the
										;keys in that assoc into their decoded (string) values
										;decode any nominal cotegorical values into their readable strings for output
										(assign
											(assoc
												categorical_action_probabilities_map (map
														(lambda

															;if it's a nominal feature, convert the keys of the assoc if needed
															(if
																(contains_index
																	nominalsSet
																	(current_index)
																)
																(let

																	;pull the nominal values from the map in some determined order
																	(assoc
																		nominal_values (indices
																				(current_value
																					1
																				)
																			)
																	)
																	(declare
																		(assoc
																			feature (current_index
																					1
																				)
																			decoded_nominal_values nominal_values
																		)
																	)
																	(if
																		(and
																			hasSubstituteFeatureValues
																			substitute_output
																			(contains_index
																				substitutionValueMap
																				feature
																			)
																		)
																		(assign
																			(assoc
																				decoded_nominal_values
																					;since we have multiple values for one feature, substitute each value for this one feature one-at-a-time
																					(map
																						(lambda
																							(first
																								(call
																									SubstituteFeatureValues
																									(assoc
																										feature_values (list
																												(current_value
																													2
																												)
																											)
																										features (list
																												feature
																											)
																									)
																								)
																							)
																						)
																						decoded_nominal_values
																					)
																			)
																		)
																	)

																	;output an assoc of decoded (string) nominal values -> probability
																	(zip
																		decoded_nominal_values
																		(unzip
																			(current_value)
																			nominal_values
																		)
																	)
																)

																;else just return the assoc as-is
																(current_value)
															)
														)
														categorical_action_probabilities_map
													)
											)
										)
										(accum
											(assoc
												output (assoc
														categorical_action_probabilities categorical_action_probabilities_map
													)
											)
										)
									)

									;Helper method to compute and add to output local cases MDA
									##ComputeCaseMDA
									(let
										(assoc
											local_model_cases_tuple (compute_on_contained_entities
													(append
														filtering_queries
														(query_nearest_generalized_distance
															k_parameter
															context_features
															context_values
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															context_deviations
															p_parameter
															1

															; dwe_parameter return actual distance
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															(true)
															(first
																action_features
															)
														)
													)
												)
											cases_to_expected_values_map (assoc)
											output_categorical_action_probabilities (false)
											action_feature (first action_features)
											action_is_nominal (contains_index
													nominalsSet
													(first
														action_features
													)
												)
											original_cap_map categorical_action_probabilities_map
											cases_mdas (list)
										)

										;can't output mda if no action features specified
										(if
											(= (null) action_feature)
											(conclude
												(accum
													(assoc
														output (assoc
																case_mda (null)
															)
													)
												)
											)
										)
										(assign
											(assoc
												cases_to_expected_values_map (zip
														(first
															local_model_cases_tuple
														)
														(last
															local_model_cases_tuple
														)
													)
												output_categorical_action_probabilities action_is_nominal
											)
										)
										(assign
											(assoc
												cases_mdas
													;iterate over each case in the local model, hold it out and compute acccuracy of local model without it. ie, nested accuracy flow
													(map
														(lambda
															(let
																(assoc
																	remaining_k_cases_map (remove
																			cases_to_expected_values_map
																			(current_value
																				1
																			)
																		)
																	mda_case_id (current_value
																			1
																		)
																	predictions (list)
																	robust_remaining_k_cases_map (null)
																	mda (null)
																)

																;for robust residuals ensure at least 30 cases per case are used by duplicating the remaining cases list enough times
																(if
																	robust_computation
																	(assign
																		(assoc
																			robust_remaining_k_cases_map (if
																					(<
																						(size
																							remaining_k_cases_map
																						)
																						30
																					)
																					(apply
																						"append"
																						(map
																							remaining_k_cases_map
																							(range
																								1
																								(ceil
																									(/
																										30
																										(size
																											remaining_k_cases_map
																										)
																									)
																								)
																							)
																						)
																					)
																					remaining_k_cases_map
																				)
																		)
																	)
																)

																;predict action feature for all the remaining k cases to compute the mda
																(assign
																	(assoc
																		predictions
																			;remove any nulls
																			(filter
																				(values
																					(map
																						(lambda
																							(let
																								(assoc
																									react_case (get_value
																											(current_index
																												1
																											)
																										)
																									reaction (null)
																									expected_value (current_value
																											1
																										)
																									categorical_action_probabilities_map (assoc)
																									abs_error_with_case 0
																									ignore_case_list (null)
																									abs_error_without_case 0
																								)
																								(assign
																									(assoc
																										ignore_case_list
																											;remove a random selection of local cases in addition to the react case
																											(if
																												robust_computation
																												(append
																													(list
																														react_case
																													)
																													(filter
																														(lambda
																															(<
																																(rand)
																																0.5
																															)
																														)
																														(indices
																															(remove
																																remaining_k_cases_map
																																react_case
																															)
																														)
																													)
																												)
																												(list
																													react_case
																												)
																											)
																									)
																								)
																								(assign
																									(assoc
																										reaction_with_case (call
																												GenerateReaction
																												(assoc
																													custom_extra_filtering_queries (query_not_in_entity_list
																															ignore_case_list
																														)
																													context_values (retrieve_from_entity
																															react_case
																															context_features
																														)
																												)
																											)
																									)
																								)

																								;if nominal, return the caterogorical action probability for the expected class
																								(if
																									action_is_nominal
																									(seq
																										(assign
																											(assoc
																												reaction_with_case (get
																														categorical_action_probabilities_map
																														(list
																															action_feature
																															expected_value
																														)
																													)
																											)
																										)

																										;cap needs to be cleared before each reaction so that it can be accumulated correctly
																										(assign
																											(assoc
																												categorical_action_probabilities_map (assoc)
																											)
																										)
																									)
																									(assign
																										(assoc
																											abs_error_with_case (abs
																													(-
																														expected_value
																														reaction_with_case
																													)
																												)
																										)
																									)
																								)
																								(assign
																									(assoc
																										reaction_without_case (call
																												GenerateReaction
																												(assoc
																													custom_extra_filtering_queries (query_not_in_entity_list
																															(append
																																mda_case_id
																																ignore_case_list
																															)
																														)
																													context_values (retrieve_from_entity
																															react_case
																															context_features
																														)
																												)
																											)
																									)
																								)
																								(if
																									action_is_nominal
																									(assign
																										(assoc
																											reaction_without_case (get
																													categorical_action_probabilities_map
																													(list
																														action_feature
																														expected_value
																													)
																												)
																										)
																									)
																									(assign
																										(assoc
																											abs_error_without_case (abs
																													(-
																														expected_value
																														reaction_without_case
																													)
																												)
																										)
																									)
																								)

																								;output delta between with case and without case, if both are null output a 0
																								(if
																									(or
																										(=
																											(null)
																											reaction_with_case
																										)
																										(=
																											(null)
																											reaction_without_case
																										)
																									)
																									0
																									(if
																										action_is_nominal

																										;if removing a case dropped accuracy from .9 to .8, we want a positive value since this case contributed 0.1 to accuracy
																										;but if removing a case improves accuracy, this diff should be negative
																										(-
																											reaction_with_case
																											reaction_without_case
																										)

																										;else take the differences in the absolute errors for continous
																										;if error without case increased, this case contributed positively to accuracy.
																										(-
																											abs_error_without_case
																											abs_error_with_case
																										)
																									)
																								)
																							)
																						)

																						;iterate over the possibly larger list if robust
																						(if
																							robust_computation
																							robust_remaining_k_cases_map
																							remaining_k_cases_map
																						)
																					)
																				)
																			)
																	)
																)
																(assign
																	(assoc
																		mda (/
																				(apply
																					"+"
																					predictions
																				)
																				(size
																					predictions
																				)
																			)
																	)
																)
																(append
																	(retrieve_from_entity
																		mda_case_id
																		(zip
																			(list
																				internalLabelSession
																				internalLabelSessionTrainingIndex
																			)
																		)
																	)
																	(assoc
																		mda mda
																	)
																)
															)
														)
														(first
															local_model_cases_tuple
														)
													)
											)
										)

										;restore categorical action probabilities map to whatever it was for the original react
										(assign
											(assoc categorical_action_probabilities_map original_cap_map)
										)
										(accum
											(assoc
												output (assoc
														case_mda cases_mdas
													)
											)
										)
									)

									;Helper method to compute and add to output local model case contributions
									##ComputeCaseContributions
									(let
										(assoc
											original_local_cases (list)
											extended_local_cases_tuple (compute_on_contained_entities
													(append
														filtering_queries
														(query_nearest_generalized_distance
															(+
																1
																k_parameter
															)
															context_features
															context_values
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															context_deviations
															p_parameter
															1

															; dwe_parameter return actual distance
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															(true)
															(true)
														)
													)
												)
											action_value (first action_values)
											extended_cases_map (assoc)
											action_feature (first action_features)
											nom_action_prob (null)
											original_cap_map categorical_action_probabilities_map
										)

										;can't output contributions if no action features specified
										(if
											(= (null) action_feature)
											(conclude
												(accum
													(assoc
														output (assoc
																case_contributions (null)
															)
													)
												)
											)
										)
										(assign
											(assoc
												original_local_cases (trunc
														(first
															extended_local_cases_tuple
														)
													)
												extended_cases_map (zip
														(first
															extended_local_cases_tuple
														)
														(last
															extended_local_cases_tuple
														)
													)
											)
										)

										;for nominals, the delta is computed off the categorical action probability of this action value
										(if
											(contains_index nominalsSet action_feature)
											(assign
												(assoc
													nom_action_prob (get
															categorical_action_probabilities_map
															(list
																action_feature
																action_value
															)
														)
												)
											)
										)
										(declare
											(assoc
												case_contributions_map (map
														(lambda
															(let
																(assoc
																	total_distance 0
																	filtered_extended_cases_map (remove
																			extended_cases_map
																			(current_index
																				1
																			)
																		)
																	delta_value 0
																	case_action_value (null)
																)
																(assign
																	(assoc
																		total_distance (apply
																				"+"
																				(values
																					filtered_extended_cases_map
																				)
																			)
																	)
																)

																;convert distances to weights
																(assign
																	(assoc
																		categorical_action_probabilities_map (assoc)
																		filtered_extended_cases_map (map
																				(lambda
																					(pow
																						(/
																							(current_value)
																							total_distance
																						)
																						dwe_parameter
																					)
																				)
																				filtered_extended_cases_map
																			)
																	)
																)
																(assign
																	(assoc
																		case_action_value (if
																				(and
																					(not
																						allow_nulls
																					)
																					(=
																						0
																						(size
																							filtered_extended_cases_map
																						)
																					)
																				)
																				(call
																					CalculateFeatureExpectedValue
																					(assoc
																						feature action_feature
																						allow_nulls (false)
																					)
																				)
																				(call
																					InterpolateActionValues
																					(assoc
																						allow_nulls allow_nulls
																						neighbor_weights_map filtered_extended_cases_map
																						action_feature action_feature
																						has_perfect_matches (contains_value
																								filtered_extended_cases_map
																								.infinity
																							)
																					)
																				)
																			)
																	)
																)
																(assign
																	(assoc
																		delta_value
																			;nominal features return delta in probabilities of selecting this action value
																			(if
																				(contains_index
																					nominalsSet
																					action_feature
																				)
																				(let
																					(assoc
																						case_action_prob (get
																								categorical_action_probabilities_map
																								(list
																									action_feature
																									action_value
																								)
																							)
																					)

																					;if this action value wasn't in the local model, that's same as having a 0 case_action_prob
																					(if
																						(=
																							(null)
																							case_action_prob
																						)
																						(-
																							0
																							nom_action_prob
																						)
																						(-
																							case_action_prob
																							nom_action_prob
																						)
																					)
																				)

																				;else continuous, return the delta
																				(-
																					case_action_value
																					action_value
																				)
																			)
																	)
																)

																;output assoc with session, session index and delta value
																(append
																	(retrieve_from_entity
																		(current_index)
																		(zip
																			(list
																				internalLabelSession
																				internalLabelSessionTrainingIndex
																			)
																		)
																	)
																	(assoc
																		action_delta delta_value
																	)
																)
															)
														)
														(zip
															original_local_cases
														)
													)
											)
										)

										;restore categorical action probabilities map to whatever it was for the original react
										(assign
											(assoc categorical_action_probabilities_map original_cap_map)
										)
										(accum
											(assoc
												output (assoc
														case_contributions (unzip
																case_contributions_map
																original_local_cases
															)
													)
											)
										)
									)

									;Helper method to compute and add to output robust local model case contributions
									##ComputeCaseContributionsRobust
									(let
										(assoc
											local_cases_map (assoc)
											original_local_cases (list)
											extended_local_cases_tuple (compute_on_contained_entities
													(append
														filtering_queries
														(query_nearest_generalized_distance
															(*
																2
																k_parameter
															)
															context_features
															context_values
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															context_deviations
															p_parameter
															1

															; dwe_parameter return actual distance
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															(true)
															(true)
														)
													)
												)
											action_value (first action_values)
											non_local_cases_map (assoc)
											non_local_cases (list)
											action_feature (first action_features)
											nom_action_prob (null)
											original_cap_map categorical_action_probabilities_map
										)
										(assign
											(assoc
												original_local_cases (trunc
														(first
															extended_local_cases_tuple
														)
														k_parameter
													)
												non_local_cases (tail
														(first
															extended_local_cases_tuple
														)
														k_parameter
													)
											)
										)
										(assign
											(assoc
												local_cases_map (zip
														original_local_cases
														(trunc
															(last
																extended_local_cases_tuple
															)
															k_parameter
														)
													)
												non_local_cases_map (zip
														non_local_cases
														(tail
															(last
																extended_local_cases_tuple
															)
															k_parameter
														)
													)
											)
										)

										;for nominals, the delta is computed off the categorical action probability of this action value
										(if
											(contains_index nominalsSet action_feature)
											(assign
												(assoc
													nom_action_prob (get
															categorical_action_probabilities_map
															(list
																action_feature
																action_value
															)
														)
												)
											)
										)

										;iterate for every case in the local model:
										;hold it out and then 100x hold out random sample of other local cases, replace the holdouts with nearest non local ones and average out the action value
										(declare
											(assoc
												case_contributions_map (map
														(lambda
															(let
																(assoc
																	total_distance 0
																	filtered_local_cases_map (remove
																			local_cases_map
																			(current_index
																				1
																			)
																		)
																	robust_deltas (list)
																	case_action_value (null)
																)

																;run 100 iterations of holding out random cases, replacing them from the extended model and computing the delta
																;average out the delta at the end
																(assign
																	(assoc
																		robust_deltas (map
																				(lambda
																					(let
																						(assoc
																							robust_cases_map (filter
																									(lambda
																										(<
																											(rand)
																											0.5
																										)
																									)
																									filtered_local_cases_map
																								)
																							num_to_replace 0
																						)
																						(assign
																							(assoc
																								num_to_replace (-
																										k_parameter
																										(size
																											robust_cases_map
																										)
																									)
																							)
																						)

																						;fill up the remaining local cases with non local extended model ones
																						(accum
																							(assoc
																								robust_cases_map (keep
																										non_local_cases_map
																										(trunc
																											non_local_cases
																											num_to_replace
																										)
																									)
																							)
																						)
																						(assign
																							(assoc
																								total_distance (apply
																										"+"
																										(values
																											robust_cases_map
																										)
																									)
																							)
																						)

																						;convert distances to weights
																						(assign
																							(assoc
																								robust_cases_map (map
																										(lambda
																											(pow
																												(/
																													(current_value)
																													total_distance
																												)
																												dwe_parameter
																											)
																										)
																										robust_cases_map
																									)
																								categorical_action_probabilities_map (assoc)
																							)
																						)
																						(assign
																							(assoc
																								case_action_value (if
																										(and
																											(not
																												allow_nulls
																											)
																											(=
																												0
																												(size
																													robust_cases_map
																												)
																											)
																										)
																										(call
																											CalculateFeatureExpectedValue
																											(assoc
																												feature action_feature
																												allow_nulls (false)
																											)
																										)
																										(call
																											InterpolateActionValues
																											(assoc
																												allow_nulls allow_nulls
																												neighbor_weights_map robust_cases_map
																												action_feature action_feature
																												has_perfect_matches (contains_value
																														robust_cases_map
																														.infinity
																													)
																											)
																										)
																									)
																							)
																						)

																						;nominal features return delta in probabilities of selecting this action value
																						(if
																							(contains_index
																								nominalsSet
																								action_feature
																							)
																							(let
																								(assoc
																									case_action_prob (get
																											categorical_action_probabilities_map
																											(list
																												action_feature
																												action_value
																											)
																										)
																								)

																								;if this action value wasn't in the local model, that's same as having a 0 case_action_prob
																								(if
																									(=
																										(null)
																										case_action_prob
																									)
																									(-
																										0
																										nom_action_prob
																									)
																									(-
																										case_action_prob
																										nom_action_prob
																									)
																								)
																							)

																							;else continuous, return the delta
																							(-
																								case_action_value
																								action_value
																							)
																						)
																					)
																				)
																				(range
																					1
																					100
																				)
																			)
																	)
																)

																;output assoc with session, session index and the average delta value
																(append
																	(retrieve_from_entity
																		(current_index)
																		(zip
																			(list
																				internalLabelSession
																				internalLabelSessionTrainingIndex
																			)
																		)
																	)
																	(assoc
																		action_delta (/
																				(apply
																					"+"
																					robust_deltas
																				)
																				100
																			)
																	)
																)
															)
														)
														local_cases_map
													)
											)
										)

										;restore categorical action probabilities map to whatever it was for the original react
										(assign
											(assoc categorical_action_probabilities_map original_cap_map)
										)
										(accum
											(assoc
												output (assoc
														case_contributions (unzip
																case_contributions_map
																original_local_cases
															)
													)
											)
										)
									)

									;Helper method to compute and output local feature contributions
									##ComputeFeatureContributions
									(let
										(assoc
											nom_action_prob (null)
											action_value (first action_values)
											local_model_case_ids (if
													(!=
														(null)
														cached_candidate_cases_map
													)
													(indices
														cached_candidate_cases_map
													)
													(contained_entities
														(append
															filtering_queries
															(query_nearest_generalized_distance
																k_parameter
																context_features
																context_values
																feature_weights
																nominalClassCountsMap
																cyclicFeaturesMap
																context_deviations
																p_parameter
																dwe_parameter
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)

																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
															)
														)
													)
												)
											action_feature (first action_features)
										)

										;for nominals, the delta is computed off the categorical action probability of this action value
										(if
											(contains_index nominalsSet action_feature)
											(assign
												(assoc
													nom_action_prob (get
															categorical_action_probabilities_map
															(list
																action_feature
																action_value
															)
														)
												)
											)
										)

										;for robust residuals ensure at least 100 cases per feature are used by duplicating the local cases list enough times
										(if
											(and
												robust_computation
												(<
													k_parameter
													100
												)
											)
											(assign
												(assoc
													local_model_case_ids (apply
															"append"
															(map
																local_model_case_ids
																(range
																	1
																	(ceil
																		(/
																			100
																			k_parameter
																		)
																	)
																)
															)
														)
												)
											)
										)
										(declare
											(assoc
												context_map (zip
														context_features
														context_values
													)
												feature_contributions_map (assoc)
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature weight_feature
															feature action_feature
															mode "full"
														)
													)
												action_is_nominal (!=
														(null)
														nom_action_prob
													)
											)
										)
										(assign
											(assoc
												feature_contributions_map (map
														(lambda
															(let
																(assoc
																	filtered_features_map (remove
																			context_map
																			(current_index
																				1
																			)
																		)
																	deltas (list)
																)
																(assign
																	(assoc
																		deltas (map
																				(lambda
																					(let
																						(assoc
																							filtered_context_features (if
																									robust_computation
																									(filter
																										(lambda
																											(<
																												(rand)
																												0.5
																											)
																										)
																										(indices
																											filtered_features_map
																										)
																									)
																									(indices
																										filtered_features_map
																									)
																								)
																							reaction (null)
																						)
																						(assign
																							(assoc
																								reaction (call
																										ReactDiscriminative
																										(assoc
																											context_values (if
																													robust_computation
																													(unzip
																														filtered_features_map
																														filtered_context_features
																													)
																													(values
																														filtered_features_map
																													)
																												)
																											skip_decoding 1
																											details (assoc
																													categorical_action_probabilities action_is_nominal
																												)
																											ignore_case ignore_case
																											action_features (list
																													action_feature
																												)
																											hyperparam_map hyperparam_map
																											context_features filtered_context_features
																										)
																									)
																							)
																						)
																						(assign
																							(assoc
																								case_value (get
																										reaction
																										(list
																											"action_values"
																											0
																										)
																									)
																							)
																						)

																						;compute delta
																						(if
																							action_is_nominal
																							(let
																								(assoc
																									case_action_prob (get
																											reaction
																											(list
																												"categorical_action_probabilities"
																												action_feature
																												action_value
																											)
																										)
																								)

																								;if this action value wasn't in the local model, that's same as having a 0 case_action_prob
																								(if
																									(=
																										(null)
																										case_action_prob
																									)
																									(-
																										0
																										nom_action_prob
																									)
																									(-
																										case_action_prob
																										nom_action_prob
																									)
																								)
																							)
																							(-
																								case_value
																								action_value
																							)
																						)
																					)
																				)
																				local_model_case_ids
																			)
																	)
																)
																(/
																	(apply
																		"+"
																		deltas
																	)
																	(size
																		deltas
																	)
																)
															)
														)
														context_map
													)
											)
										)
										(accum
											(assoc
												output (assoc
														feature_contributions feature_contributions_map
													)
											)
										)
									)

									;a) for nominals look for closeslt cases that have a different action value
									;b) for continuous, do one-at-a-time feature elimination (knockout) on local model, collate results with results from (a),
									;c) sort by action distances and by context distances
									;d) calculate distances of cases from C by actions and by contexts and sort by ratio of action distance /(context U action) distance
									;e) if there aren't enough cases that have a ratio > 0 repeat from step (a) with double K value for the local model
									;f) if still no luck after K > 240, give up - no boundary
									;g) return the num exemplar cases with the highest action/(context U action) distance ratios as boundary cases
									;return:
									; boundary_case_ids  : cases with highest ratio of action_distance / context_distance.
									;
									;Parameters:
									; context_features: list of context features
									; context_values: current values of each context feature
									; action_features: list of action features for action inputs
									; action_values: current values of each action feature
									; num_cases_returned: number of cases to return for each type of audit data
									; extra_audit_features: list of additional features to return with audit data
									##GetBoundaryCaseIds
									(declare
										(assoc
											context_values (list)
											num_cases_returned k_parameter
											extra_audit_features (list)
											action_values (list)
											local_model_n regionalModelMinSize
											action_features (list)
											context_features (list)
										)

										;set the value to be the max of these, that way if closest k is large, it'll just use that as the local model n size
										(assign
											(assoc
												local_model_n (max
														k_parameter
														local_model_n
													)
											)
										)

										;(a)get local model, (store num_cases_returned closest)
										(declare
											(assoc
												feature_weights (get
														hyperparam_map
														"featureWeights"
													)
												react_case (zip
														(append
															context_features
															action_features
														)
														(append
															context_values
															action_values
														)
													)
												feature_deviations (if
														(get
															hyperparam_map
															"useDeviations"
														)
														(get
															hyperparam_map
															"featureDeviations"
														)
													)
											)
										)

										;--- calculate boundary cases ---
										; if one nominal, call function to get nominal case ids, return boundary cases
										; else:
										; for each nominal feature:
										;  call function, contexts are contexts+actions with index of action deleted
										;  OR the case ids together
										; continuous actions = actions unzipped by non-nominals
										; do one-by-one feature knockout for continous actions where contexts are contexts+nominal actions with indices of continous actions deleted
										; OR the lists of nominal boundary case ids and continous boundary case ids
										; return top action/case ratio num_cases_returned
										(declare
											(assoc boundary_case_ids (list))
										)

										;if the action is exactly one nominal feature simply create the query and return the boundary cases
										;otherwise do the full flow
										(if
											(and
												(=
													1
													(size
														action_features
													)
												)
												(contains_index
													nominalsSet
													(first
														action_features
													)
												)
											)
											(assign
												(assoc
													boundary_case_ids
														;don't need to specify other parameters because they are passed in implicitly as they are
														(call
															CalculateNominalBoundaryCaseIds
															(assoc
																num_cases_returned num_cases_returned
																action_value (first
																		action_values
																	)
																action_feature (first
																		action_features
																	)
															)
														)
												)
											)

											;full flow, using feature knockout for non-nominals and taking the cases with the highest ratio of action / case
											(let
												(assoc
													nominal_action_feature_indices (list)
													nominal_boundary_case_ids (list)
													non_nominal_action_feature_indices (list)
												)

												;for each nominal feature:
												;  calculate nominal boundary case ids, contexts are contexts + actions with index of action deleted
												;  OR the case ids together
												(map
													(lambda
														(if
															(contains_index
																nominalsSet
																(current_value)
															)
															(let
																(assoc
																	filtered_action_values (remove
																			action_values
																			(current_index
																				1
																			)
																		)
																	filtered_action_features (remove
																			action_features
																			(current_index
																				1
																			)
																		)
																)
																(accum
																	(assoc
																		nominal_boundary_case_ids (call
																				CalculateNominalBoundaryCaseIds
																				(assoc
																					context_values (append
																							context_values
																							filtered_action_values
																						)
																					num_cases_returned num_cases_returned
																					action_value (get
																							action_values
																							(current_index
																								2
																							)
																						)
																					action_feature (get
																							action_features
																							(current_index
																								2
																							)
																						)
																					context_features (append
																							context_features
																							filtered_action_features
																						)
																				)
																			)
																	)
																)
																(accum
																	(assoc
																		nominal_action_feature_indices (current_index
																				1
																			)
																	)
																)
															)

															;else not a nominal action feature, store its index
															(accum
																(assoc
																	non_nominal_action_feature_indices (current_index
																			1
																		)
																)
															)
														)
													)
													action_features
												)
												(declare
													(assoc
														candidate_boundary_case_ids
															;if there are no non-nominals, take the necessary number of unique cases from the boundary_cases
															;otherwise calculate candidate boundary cases for non-nominal actions
															(if
																(=
																	(size
																		non_nominal_action_feature_indices
																	)
																	0
																)

																;remove duplicates from the nominal boundary case ids
																(indices
																	(zip
																		nominal_boundary_case_ids
																	)
																)

																;else create the revelant lists of values to use as contexts by appending contexts to nominal actions
																(call
																	CalculateNonNominalBoundaryCaseIds
																)
															)
													)
												)

												;calculate distances to all the neighbor candidate boundary cases using only the action values
												;an assoc of case_id -> distance to reaction
												(declare
													(assoc
														candidate_boundary_cases_action_distance_map (zip
																candidate_boundary_case_ids
																(map
																	(lambda
																		(generalized_distance
																			feature_weights
																			nominalClassCountsMap
																			cyclicFeaturesMap
																			feature_deviations
																			p_parameter
																			action_values
																			(retrieve_from_entity
																				(current_value)
																				action_features
																			)
																			(null)
																			action_features
																		)
																	)
																	candidate_boundary_case_ids
																)
															)
														candidate_boundary_cases_distance_map (zip
																candidate_boundary_case_ids
																(map
																	(lambda
																		(generalized_distance
																			feature_weights
																			nominalClassCountsMap
																			cyclicFeaturesMap
																			feature_deviations
																			p_parameter
																			(append
																				context_values
																				action_values
																			)
																			(retrieve_from_entity
																				(current_value)
																				(append
																					context_features
																					action_features
																				)
																			)
																			(null)
																			(append
																				context_features
																				action_features
																			)
																		)
																	)
																	candidate_boundary_case_ids
																)
															)
													)
												)

												;calculate the ratios of action distance / full case distance for all the neighboring cases
												(declare
													(assoc
														neighbor_cases_by_ratio_of_action_to_case_distance_map (map
																(lambda
																	(/
																		(get
																			candidate_boundary_cases_action_distance_map
																			(current_index)
																		)
																		(get
																			candidate_boundary_cases_distance_map
																			(current_index)
																		)
																	)
																)
																candidate_boundary_cases_distance_map
															)
													)
												)

												;sort the case ids by their distance ratios, from high to low
												(declare
													(assoc
														sorted_neighbors_by_ratio_of_action_to_context_distance (sort
																(lambda
																	(>
																		(get
																			neighbor_cases_by_ratio_of_action_to_case_distance_map
																			(current_value
																				1
																			)
																		)
																		(get
																			neighbor_cases_by_ratio_of_action_to_case_distance_map
																			(current_value)
																		)
																	)
																)
																(indices
																	neighbor_cases_by_ratio_of_action_to_case_distance_map
																)
															)
													)
												)
												(assign
													(assoc
														boundary_case_ids (trunc
																sorted_neighbors_by_ratio_of_action_to_context_distance
																num_cases_returned
															)
													)
												)

												;if there are boundary cases distance ratios of 0, can't list any, so let later code handle it
												(if
													(contains_value
														(unzip
															neighbor_cases_by_ratio_of_action_to_case_distance_map
															boundary_case_ids
														)
														0
													)
													(assign
														(assoc
															boundary_case_ids (null)
														)
													)
												)
											)
										)

										;if no boundary cases, repeat with double K value and rerun this method until K is at 240
										; this can happen if there are many identical cases
										(if
											(= (null) boundary_case_ids)
											(if
												(<=
													local_model_n
													240
												)
												(call
													GetBoundaryCaseIds
													(assoc
														context_values context_values
														extra_audit_features extra_audit_features
														action_values action_values
														local_model_n (*
																2
																local_model_n
															)
														boundary_cases_only boundary_cases_only
														action_features action_features
														context_features context_features
													)
												)

												;if still no luck after K = 240, return nothing
												(list)
											)
											boundary_case_ids
										)
									)

									;return all the boundary cases for a nominal action
									;helper method called only by #GetBoundaryCaseIds and implicitly uses values from the flow in #GetBoundaryCaseIds
									##CalculateNominalBoundaryCaseIds
									(declare
										(assoc
											context_values context_values
											num_cases_returned num_cases_returned
											action_value (null)
											action_feature ""
											context_features context_features
										)
										(contained_entities
											(list

												;ignore all cases that match this exact action value for this action feature
												(query_not_equals
													action_feature
													action_value
												)

												;query to find the influential cases from the remaining set
												(query_nearest_generalized_distance
													num_cases_returned
													context_features
													context_values
													feature_weights
													nominalClassCountsMap
													cyclicFeaturesMap
													feature_deviations
													p_parameter
													1

													;dwe
													(if
														valid_weight_feature
														weight_feature
														(null)
													)

													;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
													"fixed rand seed"
													(null)

													;radius
													lpSpaceHeuristicMultiplier
												)
											)
										)
									)

									;return all unique boundary case ids for non-nominal features in an explanation
									;helper method called only by #explain_case and implicitly uses values from the flow in #explain_case
									##CalculateNonNominalBoundaryCaseIds
									(let
										(assoc
											context_and_nominal_action_features (append
													context_features
													(unzip
														action_features
														nominal_action_feature_indices
													)
												)
										)

										;create a list of lists of closest cases for each knocked out context feature
										;by knocking out features one by one and getting the local model of neighbors for the remaining context features
										(assign
											(assoc
												candidate_boundary_case_ids (map
														(lambda
															(let
																(assoc
																	feature (current_value
																			1
																		)
																)

																;filter out this feature
																(declare
																	(assoc
																		filtered_context_features (filter
																				(lambda
																					(!=
																						(current_value)
																						feature
																					)
																				)
																				context_and_nominal_action_features
																			)
																	)
																)

																;output the closest cases to the filtered contexts
																(contained_entities
																	(list
																		(query_nearest_generalized_distance
																			local_model_n
																			filtered_context_features

																			;use only the corresponding values
																			(unzip
																				react_case
																				filtered_context_features
																			)
																			feature_weights
																			nominalClassCountsMap
																			cyclicFeaturesMap
																			feature_deviations
																			p_parameter
																			1
																			(if
																				valid_weight_feature
																				weight_feature
																				(null)
																			)

																			;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																			"fixed rand seed"
																			(null)

																			;radius
																			lpSpaceHeuristicMultiplier
																		)
																	)
																)
															)
														)
														context_and_nominal_action_features
													)
											)
										)

										;append all the nominal boundary case ids to the non-nominal boundary_case ids
										(assign
											(assoc
												candidate_boundary_case_ids (append

														;convert the list of lists into a flat 1-d list
														(apply
															"append"
															candidate_boundary_case_ids
														)
														nominal_boundary_case_ids
													)
											)
										)

										;remove duplicate ids and return as output
										(indices
											(zip candidate_boundary_case_ids)
										)
									)

									;explains features for a provided local model of data, compared to the full model
									;
									;Parameters:
									; context_features: list of context features
									; context_values: current values of each context feature
									; case_ids : the list of local case ids to explain the features for
									; action_features: list of action features
									; feature_prediction_conviction: true or false; true by default. returns local feature prediction conviction and contribution
									; feature_familiarity_conviction: true or false; false by default. returns local feature familiarity conviction
									; feature_familiarity_conviction_ratios: true or false; false by default. returns local feature selecting features
									##ExplainFeatures
									(declare
										(assoc
											feature_familiarity_conviction_ratios (false)
											context_values (list)
											feature_familiarity_conviction (false)
											case_ids (list)
											action_features (list)
											feature_prediction_conviction (true)
											context_features (list)
										)

										;an assoc of all the features with their corresponding entropy values
										(declare
											(assoc
												local_feature_prediction_contribution_map (if
														feature_prediction_conviction
														(call
															ComputeFeaturePredictionConviction
															(assoc
																features context_features
																case_ids case_ids
																action_features action_features
															)
														)

														;else
														(null)
													)
												local_feature_convictions_map
													;feature_familiarity_conviction_ratios needs local feature familiarity conviction even if it isn't being requested by user
													(if
														(or
															feature_familiarity_conviction
															feature_familiarity_conviction_ratios
														)
														(get
															(call
																ComputeFeatureFamiliarityConviction
																(assoc
																	features context_features
																	case_ids case_ids
																)
															)
															"familiarity_conviction_addition"
														)

														;else an empty assoc of features as indices
														(zip
															context_features
														)
													)
												full_model_feature_convictions_map (if
														feature_familiarity_conviction_ratios
														(get
															(call
																ComputeFeatureFamiliarityConviction
																(assoc
																	features context_features
																)
															)
															"familiarity_conviction_addition"
														)

														;else
														(null)
													)
											)
										)
										(declare
											(assoc selecting_feature_convictions_map (assoc))
										)

										;generate lists of all the extreme features (region_selecting, locally_selecting, static and noisy)
										;calculating their conviction values and ratio to the full model
										(map
											(lambda
												(let
													(assoc
														familiarity_conviction (current_value
																1
															)
														prediction_contribution (get
																local_feature_prediction_contribution_map
																(list
																	"prediction_contribution"
																	(current_index
																		2
																	)
																)
															)
														prediction_conviction (get
																local_feature_prediction_contribution_map
																(list
																	"prediction_conviction"
																	(current_index
																		2
																	)
																)
															)
														ratio_to_full_model (/
																(current_value
																	1
																)
																(get
																	full_model_feature_convictions_map
																	(current_index
																		1
																	)
																)
															)
													)

													;prevent ratio value of nan
													(if
														(=
															(current_value)
															.infinity
														)
														(assign
															(assoc
																ratio_to_full_model 0
															)
														)
													)

													;selecting features are those whose ratios deviate the most from 1
													(if
														(and
															feature_familiarity_conviction_ratios
															(or
																(>=
																	ratio_to_full_model
																	1.25
																)
																(<=
																	ratio_to_full_model
																	0.8
																)
															)
														)
														(accum
															(assoc
																selecting_feature_convictions_map (associate
																		(get_value
																			(current_index
																				2
																			)
																		)
																		(assoc
																			familiarity_conviction familiarity_conviction
																			ratio (if
																					(>
																						ratio_to_full_model
																						0
																					)
																					ratio_to_full_model
																					(/
																						1
																						ratio_to_full_model
																					)
																				)
																			prediction_conviction prediction_conviction
																			prediction_contribution prediction_contribution
																		)
																	)
															)
														)
													)
												)
											)
											local_feature_convictions_map
										)
										(assoc
											feature_prediction_contribution (get
													local_feature_prediction_contribution_map
													"prediction_contribution"
												)
											feature_familiarity_conviction_ratios selecting_feature_convictions_map
											feature_familiarity_conviction local_feature_convictions_map
											feature_prediction_conviction (get
													local_feature_prediction_contribution_map
													"prediction_conviction"
												)
										)
									)

									;accumulate categorical action feature probabilities from a react into categorical_action_probabilities_map
									; action_feature : the categorical action feature
									; categorical_value_weights_map : an assoc of categorical action feature values -> sum of their weight; if specified will be used for accumulation
									;                                 if not specified, will instead use neighbor_id_to_values_map parameter
									; neighbor_id_to_values_map : optional, an assoc of neighbor case id -> its value; if spceified assumes there are perfect match neighbors
									##AccumulateCategoricalActionProbabilties
									(declare
										(assoc
											categorical_value_weights_map (assoc)
											action_feature (null)
											neighbor_id_to_values_map (assoc)
										)

										;accumulate only if they haven't been accumulated yet
										(if
											(= (assoc) categorical_action_probabilities_map)

											;if the probabilities have already been calculated and provided, which happens when neighbors are not perfect matches, accumulate them
											(if
												(>
													(size
														categorical_value_weights_map
													)
													0
												)
												(let
													(assoc
														total_categorical_weight (apply
																"+"
																(values
																	categorical_value_weights_map
																)
															)
													)
													(accum
														(assoc
															categorical_action_probabilities_map (associate

																	;convert the distance (weight) for each value into a probabilities
																	action_feature
																	(map
																		(lambda
																			(/
																				(current_value)
																				total_categorical_weight
																			)
																		)
																		categorical_value_weights_map
																	)
																)
														)
													)
												)

												;else calculate them for perfect matches with even weights for each neighbor
												(let

													;since these are perfect matches, they all have equal weight
													(assoc
														value_weight (/
																1
																(size
																	neighbor_id_to_values_map
																)
															)
													)

													;iterate over all the nearby cases, to create the mapping between each categorical action value and its summed
													;weight for this categorical feature.  for each unique categorical value in all the neighbors, sum up its weight
													(assign
														(assoc
															categorical_value_weights_map (zip
																	(lambda
																		(+
																			(current_value
																				1
																			)
																			(current_value)
																		)
																	)
																	(values
																		(get
																			neighbor_id_to_values_map
																		)
																	)
																	value_weight
																)
														)
													)
													(accum
														(assoc
															categorical_action_probabilities_map (associate
																	action_feature
																	categorical_value_weights_map
																)
														)
													)
												)
											)
										)
									)

									;accumulate influence weight for a given case in a prediction, updates influence_weights_map variable resulting in a map of case_id -> weight
									;parameters:
									; case_ids: list of case ids to accumulate weights for
									; weight: the weight value for the case, if specified will use this weight for all the cases
									; weights: list of weight values corresponding to each id, will be used if the single weight is not specified
									##AccumulateInfluenceWeights
									(seq

										;if a single weight is specified, use that for all the cases
										(if
											(!= (null) weight)
											(assign
												(assoc
													weights (map
															(lambda
																weight
															)
															(range
																1
																(size
																	case_ids
																)
															)
														)
												)
											)
										)

										;increase the accumulated weight for each of the specified cases, appending to the existing list that may have cases that aren't
										;being accumulated here
										(accum
											(assoc
												influence_weights_map (map
														(lambda

															;or the existing value to make it null-safe cast to 0
															(+
																(or
																	(get
																		influence_weights_map
																		(current_index)
																	)
																)
																(current_value)
															)
														)
														(zip
															case_ids
															weights
														)
													)
											)
										)
									)

									;calculate residuals for a given case, assuming the case is already not in the model
									;outputs an assoc of features -> residual value (mean absolute error for continuous, difference in categorical action probability for categorical)
									;parameters:
									; features: features for which to calculate residuals
									; case_values : corresponding values for the features for the case, i.e. the expected values
									; ignore_case: case_id, if set will query for K+1 cases and ignore the perfect matching case during the reaction
									##CalculateResidualsForCase
									(declare
										(assoc
											case_values (list)
											ignore_case (null)
											features (list)
										)

										;if model is too small to compute residuals, output fixed values
										(if
											(<= model_size 2)
											(conclude
												(seq
													(if
														(get
															details
															"case_feature_residuals"
														)
														(accum
															(assoc
																output (assoc
																		case_feature_residuals (zip
																				features
																				0
																			)
																	)
															)
														)
													)
													(if
														(get
															details
															"global_case_feature_residual_convictions"
														)
														(accum
															(assoc
																output (assoc
																		global_case_feature_residual_convictions (zip
																				features
																				1
																			)
																	)
															)
														)
													)
													(if
														(get
															details
															"local_case_feature_residual_convictions"
														)
														(accum
															(assoc
																output (assoc
																		local_case_feature_residual_convictions (zip
																				features
																				1
																			)
																	)
															)
														)
													)
												)
											)
										)
										(declare
											(assoc
												case_residuals (if
														robust_computation
														(let
															(assoc
																context_map (zip
																		features
																		case_values
																	)
															)

															;for each feature, do 30 reacts with randomly selected contexts
															(map
																(lambda
																	(let
																		(assoc
																			robust_predictions (list)
																			contexts_only_map (remove
																					context_map
																					(current_value
																						1
																					)
																				)
																			action_feature (current_value
																					1
																				)
																			action_is_nominal (contains_index
																					nominalsSet
																					(current_value
																						1
																					)
																				)
																			expected_case_value (get
																					case_values
																					(current_index
																						1
																					)
																				)
																		)

																		;if the case value is null, but nulls aren't allowed, return null as residual so it can be computed below
																		(if
																			(and
																				(=
																					(null)
																					expected_case_value
																				)
																				(not
																					allow_nulls
																				)
																			)
																			(null)
																			(seq
																				(assign
																					(assoc
																						robust_predictions (map
																								(lambda
																									(let
																										(assoc
																											filtered_context_map (filter
																													(lambda
																														(<
																															(rand)
																															0.5
																														)
																													)
																													contexts_only_map
																												)
																										)
																										(declare
																											(assoc
																												reaction (call
																														ReactDiscriminative
																														(assoc
																															context_values (values
																																	filtered_context_map
																																)
																															return_action_values_only (true)
																															ignore_case ignore_case
																															details (if
																																	action_is_nominal
																																	(assoc
																																		categorical_action_probabilities (true)
																																	)
																																)
																															skip_decoding 1
																															force_targetless force_targetless
																															substitute_output (false)
																															action_features (list
																																	action_feature
																																)
																															skip_encoding 1
																															context_features (indices
																																	filtered_context_map
																																)
																														)
																													)
																											)
																										)

																										;if feature is nominal get the categorical action probability for expected value, if it's null then set it to 0
																										;else it's: 1 - probability
																										(if
																											action_is_nominal
																											(let
																												(assoc
																													predicted_probability (or
																															(get
																																reaction
																																(list
																																	"categorical_action_probabilities"
																																	action_feature
																																	expected_case_value
																																)
																															)
																															0
																														)
																												)
																												(-
																													1
																													predicted_probability
																												)
																											)

																											;else this is a continuous feature, return the absolute difference between the expected and the actual
																											(abs
																												(-
																													expected_case_value
																													(get
																														reaction
																														0
																													)
																												)
																											)
																										)
																									)
																								)
																								(range
																									1
																									30
																								)
																							)
																					)
																				)

																				;return average of all the probust predictions for each feature
																				(/
																					(apply
																						"+"
																						robust_predictions
																					)
																					30
																				)
																			)
																		)
																	)
																)
																features
															)
														)

														;else standard computation, do leave-one-out for each feature and predict it once
														(map
															(lambda
																(let
																	(assoc
																		filtered_context_features (remove
																				features
																				(current_index
																					1
																				)
																			)
																		filtered_case_values (remove
																				case_values
																				(current_index
																					1
																				)
																			)
																		action_feature (current_value
																				1
																			)
																		action_is_nominal (contains_index
																				nominalsSet
																				(current_value
																					1
																				)
																			)
																		expected_case_value (get
																				case_values
																				(current_index
																					1
																				)
																			)
																	)

																	;if the case value is null, but nulls aren't allowed, return null as residual so it can be computed below
																	(if
																		(and
																			(=
																				(null)
																				expected_case_value
																			)
																			(not
																				allow_nulls
																			)
																		)
																		(null)
																		(let
																			(assoc
																				reaction (call
																						ReactDiscriminative
																						(assoc
																							context_values filtered_case_values
																							return_action_values_only (true)
																							ignore_case ignore_case
																							details (if
																									action_is_nominal
																									(assoc
																										categorical_action_probabilities (true)
																									)
																								)
																							skip_decoding 1
																							force_targetless force_targetless
																							substitute_output (false)
																							action_features (list
																									action_feature
																								)
																							skip_encoding 1
																							context_features filtered_context_features
																						)
																					)
																			)

																			;if feature is nominal get the categorical action probability for expected value, if it's null then set it to 0
																			;else it's: 1 - probability
																			(if
																				action_is_nominal
																				(let
																					(assoc
																						predicted_probability (or
																								(get
																									reaction
																									(list
																										"categorical_action_probabilities"
																										action_feature
																										expected_case_value
																									)
																								)
																								0
																							)
																					)
																					(-
																						1
																						predicted_probability
																					)
																				)

																				;else this is a continuous feature, return the absolute difference between the expected and the actual
																				(abs
																					(-
																						expected_case_value
																						(get
																							reaction
																							0
																						)
																					)
																				)
																			)
																		)
																	)
																)
															)
															features
														)
													)
											)
										)
										(declare
											(assoc
												case_residuals_map (zip
														features
														case_residuals
													)
												local_model_null_features_convictions (assoc)
												local_null_conviction_ratios_map (null)
												global_null_conviction_ratios_map (null)
											)
										)

										;replace case residual nulls with computed values if nulls aren't allowed
										(if
											(and
												(contains_value
													case_residuals
													(null)
												)
												(not allow_nulls)
											)
											(let
												(assoc
													computing_local_case_feature_residual_convictions (get
															details
															"local_case_feature_residual_convictions"
														)
													regional_model_cases (contained_entities
															(append
																filtering_queries
																(query_nearest_generalized_distance

																	;closest n should have a limit of how small it can be
																	(min
																		min_regional_model_size_by_percent
																		(max
																			k_parameter
																			regionalModelMinSize
																		)
																	)
																	context_features
																	context_values
																	feature_weights
																	nominalClassCountsMap
																	cyclicFeaturesMap
																	context_deviations
																	p_parameter
																	dwe_parameter
																	(if
																		valid_weight_feature
																		weight_feature
																		(null)
																	)

																	;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																	"fixed rand seed"
																	(null)
																	lpSpaceHeuristicMultiplier
																	(true)
																)
															)
														)
													null_residual_and_ratio_tuple_map (assoc)
													null_features (indices
															(filter
																(lambda
																	(=
																		(null)
																		(current_value)
																	)
																)
																case_residuals_map
															)
														)
												)

												;iterate ovel all the null features and populate a map of feature -> [ residual value, local_non_null_ratio, global_non_null_ratio ]
												(assign
													(assoc
														null_residual_and_ratio_tuple_map (map
																(lambda
																	(let
																		(assoc
																			non_null_local_values (list)
																			num_local_cases (size
																					regional_model_cases
																				)
																			null_feature (current_index
																					1
																				)
																		)

																		;pull all values for this feature and filter out nulls
																		(assign
																			(assoc
																				non_null_local_values (filter
																						(map
																							(lambda
																								(retrieve_from_entity
																									(current_value)
																									null_feature
																								)
																							)
																							regional_model_cases
																						)
																					)
																			)
																		)

																		;if all cases in local model have nulls for this feature as well, and we will be computing local
																		;feature residual convictions, set that conviction to be 1 for this case
																		(if
																			(and
																				computing_local_case_feature_residual_convictions
																				(=
																					0
																					(size
																						non_null_local_values
																					)
																				)
																			)
																			(accum
																				(assoc
																					local_model_null_features_convictions (assoc
																							null_feature 1
																						)
																				)
																			)
																		)

																		;if nominal, output residual of 1 and the appropriate ratio
																		(if
																			(contains_index
																				nominalsSet
																				null_feature
																			)
																			(list
																				1

																				;output global ratio if there are no local values
																				(if
																					(=
																						0
																						(size
																							non_null_local_values
																						)
																					)
																					(get
																						featureNullRatiosMap
																						(list
																							null_feature
																							"non_null_ratio"
																						)
																					)
																					(/
																						num_local_cases
																						(size
																							non_null_local_values
																						)
																					)
																				)
																				(get
																					featureNullRatiosMap
																					(list
																						null_feature
																						"non_null_ratio"
																					)
																				)
																			)

																			;else continuous
																			(let
																				(assoc
																					local_feature_min (apply
																							"min"
																							non_null_local_values
																						)
																					num_uinque_local_values (size
																							(zip
																								non_null_local_values
																							)
																						)
																					local_feature_max (apply
																							"max"
																							non_null_local_values
																						)
																				)

																				;if entire local model is null or only has 1 non-null value, use the global null residual
																				(if
																					(<=
																						num_uinque_local_values
																						1
																					)
																					(list
																						(get
																							featureNullRatiosMap
																							(list
																								null_feature
																								"null_residual"
																							)
																						)
																						(get
																							featureNullRatiosMap
																							(list
																								null_feature
																								"non_null_ratio"
																							)
																						)
																						(get
																							featureNullRatiosMap
																							(list
																								null_feature
																								"non_null_ratio"
																							)
																						)
																					)

																					;else there are enough local values to compute local null residual
																					(list
																						(-
																							local_feature_max
																							local_feature_min
																						)
																						(/
																							num_local_cases
																							(size
																								non_null_local_values
																							)
																						)
																						(get
																							featureNullRatiosMap
																							(list
																								null_feature
																								"non_null_ratio"
																							)
																						)
																					)
																				)
																			)
																		)
																	)
																)
																(zip
																	null_features
																)
															)
													)
												)
												(accum
													(assoc
														case_residuals_map (map
																(lambda
																	(first
																		(current_value)
																	)
																)
																null_residual_and_ratio_tuple_map
															)
													)
												)
												(assign
													(assoc
														local_null_conviction_ratios_map (map
																(lambda
																	(get
																		(current_value)
																		1
																	)
																)
																null_residual_and_ratio_tuple_map
															)
														global_null_conviction_ratios_map (map
																(lambda
																	(last
																		(current_value)
																	)
																)
																null_residual_and_ratio_tuple_map
															)
													)
												)
											)
										)

										;add case_feature_residuals to output if requested
										(if
											(get details "case_feature_residuals")
											(accum
												(assoc
													output (assoc
															case_feature_residuals case_residuals_map
														)
												)
											)
										)

										;include global feature residual convictions
										(if
											(get details "global_case_feature_residual_convictions")
											(let
												(assoc
													global_feature_residuals (null)
													global_convictions_map (assoc)
													param_path (if
															robust_computation

															;concatenate the appropriate key for the cached residuals set
															(apply
																"concat"
																(append
																	"robust"
																	(get
																		hyperparam_map
																		"paramPath"
																	)
																)
															)
															(apply
																"concat"
																(append
																	"full"
																	(get
																		hyperparam_map
																		"paramPath"
																	)
																)
															)
														)
												)

												;pull the appropriate robust or standard residuals
												(assign
													(assoc
														global_feature_residuals (get
																residualsMap
																param_path
															)
													)
												)
												(if
													(=
														0
														(size
															global_feature_residuals
														)
													)
													(assign
														(assoc
															global_convictions_map (null)
														)
													)

													;else compute the global conviction
													(assign
														(assoc
															global_convictions_map (map
																	(lambda

																		;current_index is the feature
																		;current_value is a list of residuals [global, case]
																		;conviction is: model / case residual, prevent divide by 0 by using the minimum residual instead if necesssary
																		(if
																			(=
																				0
																				(last
																					(current_value)
																				)
																			)
																			(/
																				(first
																					(current_value)
																				)
																				(get
																					cachedFeatureMinResidualMap
																					(current_index)
																				)
																			)

																			;prevent nan from divide by null, output null as-is when nulls are allowed
																			(=
																				(null)
																				(last
																					(current_value)
																				)
																			)
																			(null)
																			(/
																				(first
																					(current_value)
																				)
																				(last
																					(current_value)
																				)
																			)
																		)
																	)

																	;remove built-in keys from residuals map, leaving only feature-residual values
																	(remove
																		global_feature_residuals
																		(list
																			".robust"
																			".hyperparam_path"
																		)
																	)
																	case_residuals_map
																)
														)
													)
												)
												(if
													global_null_conviction_ratios_map
													(assign
														(assoc
															global_convictions_map (map
																	(lambda

																		;current_value is a list of [conviction, ratio], if ratio is null use 1 instead
																		(*
																			(first
																				(current_value)
																			)
																			(or
																				(last
																					(current_value)
																				)
																				1
																			)
																		)
																	)
																	global_convictions_map
																	global_null_conviction_ratios_map
																)
														)
													)
												)
												(accum
													(assoc
														output (assoc
																global_case_feature_residual_convictions global_convictions_map
															)
													)
												)
											)
										)
										(if
											(get details "local_case_feature_residual_convictions")
											(let
												(assoc
													local_convictions_map (assoc)
													local_residuals_map (assoc)
													regional_model_cases_map (compute_on_contained_entities
															(append
																filtering_queries
																(query_nearest_generalized_distance

																	;closest n should have a limit of how small it can be
																	(min
																		min_regional_model_size_by_percent
																		(max
																			k_parameter
																			regionalModelMinSize
																		)
																	)
																	context_features
																	context_values
																	feature_weights
																	nominalClassCountsMap
																	cyclicFeaturesMap
																	context_deviations
																	p_parameter
																	dwe_parameter
																	(if
																		valid_weight_feature
																		weight_feature
																		(null)
																	)

																	;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																	"fixed rand seed"
																	(null)
																	lpSpaceHeuristicMultiplier
																	(true)
																)
															)
														)
												)
												(assign
													(assoc
														local_residuals_map (call
																CalculateFeatureResiduals
																(assoc
																	robust_residuals robust_computation
																	focal_case ignore_case
																	residual_features features
																	features features
																	cases_map regional_model_cases_map
																)
															)
													)
												)

												;if there were pre-computed null feature convictions, overwrite them here
												(if
													(size
														local_model_null_features_convictions
													)
													(accum
														(assoc
															local_residuals_map local_model_null_features_convictions
														)
													)
												)
												(assign
													(assoc
														local_convictions_map (map
																(lambda

																	;current_index is the feature
																	;current_value is a list of residuals [local, case]
																	;conviction is: local / case residual, prevent divide by 0 by using the minimum residual instead if necesssary
																	(if
																		(=
																			0
																			(last
																				(current_value)
																			)
																		)
																		(/
																			(first
																				(current_value)
																			)
																			(get
																				cachedFeatureMinResidualMap
																				(current_index)
																			)
																		)

																		;prevent nan from divide by null, output null as-is when nulls are allowed
																		(=
																			(null)
																			(last
																				(current_value)
																			)
																		)
																		(null)
																		(/
																			(first
																				(current_value)
																			)
																			(last
																				(current_value)
																			)
																		)
																	)
																)
																local_residuals_map
																case_residuals_map
															)
													)
												)
												(if
													local_null_conviction_ratios_map
													(assign
														(assoc
															local_convictions_map (map
																	(lambda

																		;current_value is a list of [conviction, ratio], if ratio is null use 1 instead
																		(*
																			(first
																				(current_value)
																			)
																			(or
																				(last
																					(current_value)
																				)
																				1
																			)
																		)
																	)
																	local_convictions_map
																	local_null_conviction_ratios_map
																)
														)
													)
												)
												(accum
													(assoc
														output (assoc
																local_case_feature_residual_convictions local_convictions_map
															)
													)
												)
											)
										)
									)

									;Returns a list of computed distances between respective cases specified in either from_values or from_case_indices to to_values or to_case_indices.
									; If one case is specified in any of the lists, all respective distances are computed to/from that one case.
									;
									;parameters:
									; from_values: optional list of cases (lists of values), i.e., a 2d-list of values. Either from_values or from_case_indices must be specified, not both.
									;			if specified must be either length of 1 or match length of to_values or to_case_indices.
									; to_values: optional list of cases (lists of values), i.e., a 2d-list of values. Either to_values or to_case_indices must be specified, not both.
									;			if specified must be either length of 1 or match length of from_values or from_case_indices.
									; from_case_indices: optional, list of pair (list) of session id and index, where index is the original 0-based session_training_index of the case as it was trained.
									;			if specified must be either length of 1 or match length of to_values or to_case_indices.
									; to_case_indices: optional list of pair (list) of session id and index, where index is the original 0-based session_training_index of the case as it was trained.
									;			if specified must be either length of 1 or match length of from_values or from_case_indices.
									; features: optional, which features to use when computing pairwise distances. If unspecified uses all features.
									; action_feature: optional, if specified, uses targeted hyperparameters used to predict this action_feature, otherwise uses targetless hyperparameters.
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; use_case_weights: optional flag, if set to true will scale influence weights by each case's weight_feature weight
									##PairwiseDistances
									(declare
										(assoc
											from_case_indices (list)
											weight_feature ".case_weight"
											to_values (list)
											action_feature (null)
											features (null)
											use_case_weights (false)
											from_values (list)
											to_case_indices (list)
										)
										(if
											(= (null) features)
											(assign
												(assoc
													features defaultFeatures
												)
											)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)
										)
										(declare
											(assoc
												repeat_from_index (or
														(=
															1
															(size
																from_values
															)
														)
														(=
															1
															(size
																from_case_indices
															)
														)
													)
												repeat_to_index (or
														(=
															1
															(size
																to_values
															)
														)
														(=
															1
															(size
																to_case_indices
															)
														)
													)
												has_to_values (>
														(size
															to_values
														)
														0
													)
												last_index (-
														(max
															(size
																from_values
															)
															(size
																to_values
															)
															(size
																from_case_indices
															)
															(size
																to_case_indices
															)
														)
														1
													)
												session_indices_map (append
														(zip

															;pull all the session ids from from_case_indices
															(map
																(lambda
																	(first
																		(current_value)
																	)
																)
																from_case_indices
															)
														)
														(zip

															;pull all the session ids from to_case_indices
															(map
																(lambda
																	(first
																		(current_value)
																	)
																)
																to_case_indices
															)
														)
													)
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature weight_feature
															feature (if
																	action_feature
																	action_feature
																	".targetless"
																)
															mode (if
																	action_feature
																	"full"
																	"robust"
																)
														)
													)
												has_from_values (>
														(size
															from_values
														)
														0
													)
											)
										)
										(declare
											(assoc
												feature_weights (get
														hyperparam_map
														"featureWeights"
													)
												p_value (get
														hyperparam_map
														"p"
													)
												feature_deviations (if
														(get
															hyperparam_map
															"useDeviations"
														)
														(get
															hyperparam_map
															"featureDeviations"
														)
													)
											)
										)

										;iterate over all the unique session ids and create a map of session id -> session indices map
										(assign
											(assoc
												session_indices_map (map
														(lambda
															(retrieve_from_entity
																(current_index)
																".indices_map"
															)
														)
														session_indices_map
													)
											)
										)

										;if there is a single from or to value and it needs encoding, go ahead and do that encoding here once ahead of time
										;but keep from_values and to_values as 2-d lists
										(if
											(and
												has_from_values
												repeat_from_index
												hasFeaturesNeedEncodingFromInput
											)
											(assign
												(assoc
													from_values (list
															(call
																ConvertFromInput
																(assoc
																	feature_values (first
																			from_values
																		)
																	features features
																)
															)
														)
												)
											)
										)
										(if
											(and
												has_to_values
												repeat_to_index
												hasFeaturesNeedEncodingFromInput
											)
											(assign
												(assoc
													to_values (list
															(call
																ConvertFromInput
																(assoc
																	feature_values (first
																			to_values
																		)
																	features features
																)
															)
														)
												)
											)
										)
										||(map
											(lambda
												(let
													(assoc
														from_case_values (if
																has_from_values
																(if
																	repeat_from_index

																	;reuse the same already-encoded values
																	(first
																		from_values
																	)
																	(if
																		hasFeaturesNeedEncodingFromInput
																		(call
																			ConvertFromInput
																			(assoc
																				feature_values (get
																						from_values
																						(current_index
																							2
																						)
																					)
																				features features
																			)
																		)

																		;else use values as-is
																		(get
																			from_values
																			(current_index
																				1
																			)
																		)
																	)
																)

																;else has from_case_indices
																(if
																	repeat_from_index
																	(retrieve_from_entity
																		(get
																			session_indices_map
																			(first
																				from_case_indices
																			)
																		)
																		features
																	)
																	(retrieve_from_entity
																		(get
																			session_indices_map
																			(get
																				from_case_indices
																				(current_index
																					1
																				)
																			)
																		)
																		features
																	)
																)
															)
														to_case_values (if
																has_to_values
																(if
																	repeat_to_index

																	;reuse the same already-encoded values
																	(first
																		to_values
																	)
																	(if
																		hasFeaturesNeedEncodingFromInput
																		(call
																			ConvertFromInput
																			(assoc
																				feature_values (get
																						to_values
																						(current_index
																							2
																						)
																					)
																				features features
																			)
																		)

																		;else use values as-is
																		(get
																			to_values
																			(current_index
																				1
																			)
																		)
																	)
																)

																;else has to_case_indices
																(if
																	repeat_to_index
																	(retrieve_from_entity
																		(get
																			session_indices_map
																			(first
																				to_case_indices
																			)
																		)
																		features
																	)
																	(retrieve_from_entity
																		(get
																			session_indices_map
																			(get
																				to_case_indices
																				(current_index
																					1
																				)
																			)
																		)
																		features
																	)
																)
															)
													)

													;TODO: 12943, faster way to compute distance from_case_id to to_case_id, QUERY?
													(generalized_distance
														feature_weights
														nominalClassCountsMap
														cyclicFeaturesMap
														feature_deviations
														p_value
														from_case_values
														to_case_values
														(null)
														features
													)
												)
											)
											(range 0 last_index)
										)
									)

									;Returns an assoc with case distances, containing a list of case session indices and a list of lists (matrix) of the computed distances.
									; in the following format:
									; {
									;   'column_case_indices' : [ session-indices ],
									;	'row_case_indices' : [ session-indices ],
									;	'distances': [ [ pairwise distances ] ]
									; }
									;
									;parameters:
									; features: optional, which features to use when computing case distances. If unspecified uses all features.
									; feature_values: optional, if specified, returns case distances of the local model relative to these values, ignores case_indices parameter.
									; action_feature: optional, if specified, uses targeted hyperparameters used to predict this action_feature, otherwise uses targetless hyperparameters.
									; case_indices: optional, list of pair (list) of session id and index, where index is the original 0-based session_training_index of the case as it was
									;       trained. If specified, returns pairwise distances for all of these cases. Ignored if feature_values is provided. If neither feature_values nor
									;		case_indices is specified, runs on the full dataset.
									; column_offset: optional, starting column index of the full matrix of cases for which to compute distances. default value is 0
									; column_count: optional, number of columns to compute in the matrix.  If unspecified, is set to the same number as all the cases.
									; row_offset: optional, starting row index of the full matrix of cases for which to compute distances. default value is 0
									; row_count: optional, number of rows to compute in the matrix.  If unspecified, is set to the same number as all the cases.
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; use_case_weights: optional flag, if set to true will scale influence weights by each case's weight_feature weight
									##Distances
									(declare
										(assoc
											feature_values (null)
											valid_weight_feature (false)
											column_count (null)
											weight_feature ".case_weight"
											column_offset 0
											features (null)
											row_offset 0
											use_case_weights (false)
											action_feature (null)
											row_count (null)
											case_indices (null)
										)
										(if
											(= (null) features)
											(assign
												(assoc
													features defaultFeatures
												)
											)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)

											;else using case weights, weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
											(assign
												(assoc
													valid_weight_feature (or
															hasPopulatedCaseWeight
															(!=
																weight_feature
																".case_weight"
															)
														)
												)
											)
										)
										(declare
											(assoc
												row_case_indices (null)
												session_indices_map (assoc)
												case_ids (list)
												column_case_indices (null)
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature weight_feature
															feature (if
																	action_feature
																	action_feature
																	".targetless"
																)
															mode (if
																	action_feature
																	"full"
																	"robust"
																)
														)
													)
												row_case_ids (list)
												column_case_ids (list)
											)
										)
										(declare
											(assoc
												k_value (get
														hyperparam_map
														"k"
													)
												dwe_value (get
														hyperparam_map
														"dwe"
													)
												feature_weights (get
														hyperparam_map
														"featureWeights"
													)
												p_value (get
														hyperparam_map
														"p"
													)
												feature_deviations (if
														(get
															hyperparam_map
															"useDeviations"
														)
														(get
															hyperparam_map
															"featureDeviations"
														)
													)
											)
										)
										(if
											feature_values

											;local model of case_ids
											(assign
												(assoc
													case_ids (contained_entities
															(list
																(query_nearest_generalized_distance
																	k_value
																	features
																	(if
																		hasFeaturesNeedEncodingFromInput
																		(call
																			ConvertFromInput
																			(assoc
																				feature_values feature_values
																				features features
																			)
																		)

																		;else use values as-is
																		feature_values
																	)
																	feature_weights
																	nominalClassCountsMap
																	cyclicFeaturesMap
																	feature_deviations
																	p_value
																	dwe_value
																	(if
																		valid_weight_feature
																		weight_feature
																		(null)
																	)
																	(rand)
																	(null)

																	;radius
																	lpSpaceHeuristicMultiplier
																	(true)
																)
															)
														)
												)
											)

											;else user specified case_indices
											(>
												(size case_indices)
												1
											)
											(assign
												(assoc
													row_case_indices case_indices
													column_case_indices case_indices
													case_ids (map
															(lambda
																(let
																	(assoc
																		session_id (first
																				(current_value
																					1
																				)
																			)
																		case_index (last
																				(current_value
																					1
																				)
																			)
																	)

																	;if session_indices_map doesn't have this session, add it
																	(if
																		(not
																			(contains_index
																				session_indices_map
																				session_id
																			)
																		)
																		(accum
																			(assoc
																				session_indices_map (associate
																						session_id
																						(retrieve_from_entity
																							session_id
																							".indices_map"
																						)
																					)
																			)
																		)
																	)
																	(get
																		session_indices_map
																		(list
																			session_id
																			case_index
																		)
																	)
																)
															)
															case_indices
														)
												)
											)

											;else use full dataset
											(=
												(size case_indices)
												0
											)
											(assign
												(assoc
													case_ids (call
															AllCases
														)
												)
											)
										)
										(declare
											(assoc
												num_cases (size
														case_ids
													)
												column_row_are_same (true)
											)
										)
										(if
											(= (null) column_count)
											(assign
												(assoc
													column_count num_cases
												)
											)
										)
										(if
											(= (null) row_count)
											(assign
												(assoc
													row_count num_cases
												)
											)
										)

										;if user custom-specified offsets or sizes:
										(if
											(or
												(>
													column_offset
													0
												)
												(>
													row_offset
													0
												)
												(!=
													column_count
													num_cases
												)
												(!=
													row_count
													num_cases
												)
											)
											(seq

												;size can't exceed dimension of matrix
												(assign
													(assoc
														column_count (min
																column_count
																(-
																	num_cases
																	column_offset
																)
															)
														row_count (min
																row_count
																(-
																	num_cases
																	row_offset
																)
															)
													)
												)
												(assign
													(assoc
														column_row_are_same (false)
														column_case_ids (unzip
																case_ids
																(range
																	column_offset
																	(+
																		column_offset
																		(-
																			column_count
																			1
																		)
																	)
																)
															)
														row_case_ids (unzip
																case_ids
																(range
																	row_offset
																	(+
																		row_offset
																		(-
																			row_count
																			1
																		)
																	)
																)
															)
													)
												)
											)

											;else iterate over the whole dataset, both x and y cases are the same list
											(assign
												(assoc
													column_case_ids case_ids
													row_case_ids case_ids
												)
											)
										)
										(declare
											(assoc
												distances_matrix ||(map
														(lambda
															(unzip
																(compute_on_contained_entities
																	(list
																		(query_in_entity_list
																			column_case_ids
																		)
																		(query_within_generalized_distance
																			.infinity

																			;distance
																			features
																			(retrieve_from_entity
																				(current_value
																					1
																				)
																				features
																			)
																			feature_weights
																			nominalClassCountsMap
																			cyclicFeaturesMap
																			feature_deviations
																			p_value
																			1

																			;dwe
																			(if
																				valid_weight_feature
																				weight_feature
																				(null)
																			)
																			"fixed rand seed"
																			(null)

																			;radius
																			lpSpaceHeuristicMultiplier
																			(true)
																		)
																	)
																)
																column_case_ids
															)
														)
														row_case_ids
													)
											)
										)

										;populate x and y case_indices for all the cases if necessary
										(if
											(= (null) column_case_indices)
											(assign
												(assoc
													column_case_indices (map
															(lambda

																;pair of: session_id, session training index
																(retrieve_from_entity
																	(current_value)
																	(list
																		internalLabelSession
																		internalLabelSessionTrainingIndex
																	)
																)
															)
															column_case_ids
														)
												)
											)
										)
										(if
											(= (null) row_case_indices)
											(assign
												(assoc
													row_case_indices (if
															column_row_are_same
															column_case_indices
															(map
																(lambda

																	;pair of: session_id, session training index
																	(retrieve_from_entity
																		(current_value)
																		(list
																			internalLabelSession
																			internalLabelSessionTrainingIndex
																		)
																	)
																)
																row_case_ids
															)
														)
												)
											)
										)
										(assoc
											row_case_indices row_case_indices
											column_case_indices column_case_indices
											distances distances_matrix
										)
									)
								)

								;module for trainee_template
								;contains methods for adding, editing and removal of cases and session data
								(null

									;removes all contained entities that are cases except those that are complete contexts and actions
									; as those containing all of context_features or action_features
									;any additional cases to keep should be passed in as keys to the optional parameter cases_to_keep (values don't matter)
									##RemoveIncompleteCases
									(declare
										(assoc
											cases_to_keep_map (assoc)
											action_features (list)
											context_features (list)
										)
										(let
											(assoc
												features (append
														context_features
														action_features
													)
											)

											;populate cases_to_keep_map
											(assign
												(assoc
													cases_to_keep_map (zip

															;cases
															(contained_entities
																(map
																	(lambda
																		(query_exists
																			(current_value)
																		)
																	)
																	features
																)
															)
														)
												)
											)
										)
										(if
											(!=
												(size cases_to_keep_map)
												(call GetNumTrainingCases)
											)

											;model has changed so clear out these cached value
											(call ClearCachedCountsAndEntropies)
										)

										;destroy any cases that aren't in cases_to_keep_map
										(map

											;destroy any entities
											(lambda
												(destroy_entities (current_value))
											)

											;that have empty lists of empty replay references
											(filter
												(lambda
													(not
														(contains_index
															cases_to_keep_map
															(current_value)
														)
													)
												)
												(call AllCases)
											)
										)
									)

									;goes through every session and removes any cases within the replay that are invalid
									##RemoveInvalidReplaySteps
									(map
										(lambda
											(assign_to_entities
												(current_value)
												(assoc
													".replay_steps" (filter
															(lambda
																(and

																	;case should not be null
																	(!=
																		(null)
																		(current_value)
																	)

																	;case should exist
																	(contains_entity
																		(current_value)
																	)
																)
															)
															(retrieve_from_entity
																(current_value
																	1
																)
																".replay_steps"
															)
														)
												)
											)
										)
										(call GetSessionIds)
									)

									;removes any entities that are not a fully valid case, or replay (e.g., partially merged / broken entities)
									##RemoveIrrelevantEntities
									(let
										(assoc entities_to_keep_map (null))

										;populate entities_to_keep with a list of all contained session and case entities
										(assign
											(assoc
												entities_to_keep_map (zip
														(append
															(call
																GetSessionIds
															)
															(call
																AllCases
															)
														)
													)
											)
										)

										;destroy any cases that aren't in entities_to_keep_map
										(map

											;destroy any entities
											(lambda
												(destroy_entities (current_value))
											)

											;that have empty lists of empty replay references
											(filter
												(lambda
													(not
														(contains_index
															entities_to_keep_map
															(current_value)
														)
													)
												)
												(contained_entities)
											)
										)
										(true)
									)

									;removes any unused cases from trainee
									##RemoveCasesWithoutSessionReferences
									(let
										(assoc
											sessions_map (zip
													(call
														GetSessionIds
													)
												)
										)
										(map

											;destroy any entities
											(lambda
												(destroy_entities (current_value))
											)

											;keep only those cases that don't have a session or non-existent sessions
											(filter
												(lambda
													(or
														(=
															(retrieve_from_entity
																(current_value)
																internalLabelSession
															)
															(null)
														)
														(not
															(contains_index
																sessions_map
																(retrieve_from_entity
																	(current_value)
																	internalLabelSession
																)
															)
														)
													)
												)
												(call AllCases)
											)
										)

										;model has changed so clear out these cached value
										(call ClearCachedCountsAndEntropies)
										(true)
									)

									;merges cases specified by cases_to_merge
									;returns the number of duplicates merged
									;parameter:
									; cases_to_merge : list of case ids to merge into one
									##^MergeSpecifiedDuplicateCases
									(let
										(assoc
											all_replay_references (map
													(lambda
														(retrieve_from_entity
															(current_value)
															internalLabelSession
														)
													)
													cases_to_merge
												)
											case_to_keep (first cases_to_merge)
											unique_replays_referenced (null)
											duplicate_cases_map (zip
													(tail
														cases_to_merge
													)
												)
										)

										;model has changed so clear out these cached value
										(call ClearCachedCountsAndEntropies)

										;destroy duplicate cases
										(map
											(lambda
												(destroy_entities (current_index))
											)
											duplicate_cases_map
										)

										;get unique sessions referenced
										(assign
											(assoc
												unique_replays_referenced (indices
														(zip
															all_replay_references
														)
													)
											)
										)

										;replace all references to cases that use any of the cases merged
										; with the first element of all_replay_references (the newly merged case)
										(map
											(lambda
												(assign_to_entities
													(current_value)
													(assoc
														".replay_steps" (map
																(lambda

																	;keep the current case only if it isn't in the duplicate list
																	(if
																		(contains_index
																			duplicate_cases_map
																			(current_value)
																		)
																		(get_value
																			case_to_keep
																		)
																		(current_value)
																	)
																)
																(retrieve_from_entity
																	(current_value
																		1
																	)
																	".replay_steps"
																)
															)
													)
												)
											)
											unique_replays_referenced
										)

										;ouput the number of merged dupes
										(size duplicate_cases_map)
									)

									;finds any cases that have zero distance and merges the cases: combines their lists and updates any references in associated replays
									; parameters:
									; features: list of features
									##MergeDuplicateCases
									(declare
										(assoc
											features (list)
											hyperparam_map (call
													GetHyperparameters
													(assoc
														weight_feature ".none"
														feature ".targetless"
														mode "robust"
													)
												)
											feature_deviations (if
													(get
														hyperparam_map
														"useDeviations"
													)
													(get
														hyperparam_map
														"featureDeviations"
													)
												)
										)

										;for all cases, combine duplicates
										(map
											(lambda
												(let
													(assoc
														cases_same_position
															;if the case entity still exists (might have already been deleted by another iteration)
															(if
																(contains_entity
																	(current_value
																		1
																	)
																)

																;find those identical to it
																(contained_entities
																	(list
																		(query_within_generalized_distance
																			0
																			features
																			(retrieve_from_entity
																				(current_value
																					2
																				)
																				features
																			)

																			;weights can always be null since only looking for distances of 0
																			(null)
																			nominalClassCountsMap
																			cyclicFeaturesMap
																			feature_deviations
																			(get
																				hyperparam_map
																				"p"
																			)
																			1

																			;dwe
																			(null)

																			;don't need a case weight
																			;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																			"fixed rand seed"
																			(null)

																			; radius
																			lpSpaceHeuristicMultiplier
																		)
																	)
																)

																;otherwise empty list
																(list)
															)
													)

													;if there's more than one like it (itself is included)
													(if
														(<
															1
															(size
																cases_same_position
															)
														)
														(call
															^MergeSpecifiedDuplicateCases
															(assoc
																cases_to_merge cases_same_position
															)
														)
													)
												)
											)
											(call AllCases)
										)
									)

									;removes any replay sessions that are empty or have no cases pointing to them
									##RemoveUnreferencedSessions
									(map
										(lambda
											(let
												(assoc
													session (current_value
															1
														)
												)

												;if no references, then destroy
												(if
													(or

														;if the session replay is empty
														(=
															0
															(size
																(retrieve_from_entity
																	(current_value)
																	".replay_steps"
																)
															)
														)

														;or there are no cases that have this session
														(=
															0
															(size
																(contained_entities
																	(list
																		(query_exists
																			internalLabelSession
																		)
																		(query_equals
																			internalLabelSession
																			session
																		)
																	)
																)
															)
														)
													)
													(destroy_entities
														(current_value)
													)
												)
											)
										)
										(call GetSessionIds)
									)

									;removes replay specified by session and any references within cases
									;parameters:
									; session: session to remove
									##RemoveReplaySession
									(seq
										(destroy_entities session)

										;if any case references this session, remove the session id
										(map
											(lambda
												(if
													(=
														session
														(retrieve_from_entity
															(current_value)
															internalLabelSession
														)
													)
													(assign_to_entities
														(current_value)
														(assoc
															0 (null)
														)
													)
												)
											)
											(call AllCases)
										)

										;call the method to remove all cases without session references
										(call RemoveCasesWithoutSessionReferences)
										(accum_to_entities
											(assoc revision 1)
										)
										(null)
									)

									;Remove cases and cleanup session entities replay steps and update all the remaining cases' session indices
									;parameters:
									; cases: list of case ids to remove
									; distribute_weight_feature: name of feature into which to distribute the removed cases' weights to their neighbors.
									##RemoveCases
									(declare
										(assoc
											distribute_weight_feature (null)
											cases (list)
										)
										(if
											(=
												0
												(size cases)
											)
											(conclude)
										)

										;list of session ids, one per case
										(declare
											(assoc
												sessions (map
														(lambda
															(retrieve_from_entity
																(current_value)
																internalLabelSession
															)
														)
														cases
													)
												train_indices (map
														(lambda
															(retrieve_from_entity
																(current_value)
																internalLabelSessionTrainingIndex
															)
														)
														cases
													)
											)
										)
										(declare
											(assoc
												sessions_map (zip
														(lambda
															(append
																(current_value
																	1
																)
																(current_value)
															)
														)

														;indices are sessions, which when clobbered will append the case id to the growing list of ids for each session
														sessions
														cases
													)
												session_train_indices_map (zip
														(lambda
															(append
																(current_value
																	1
																)
																(current_value)
															)
														)

														;indices are sessions, which when clobbered will append the train_index to the growing list of train_indices for each session
														sessions
														train_indices
													)
											)
										)

										;need to distribute the weight feature values from these removed cases to neighbors
										(if
											distribute_weight_feature
											(call
												DistributeCaseInfluenceWeights
												(assoc
													distribute_weight_feature distribute_weight_feature
													features defaultFeatures
													case_ids cases
												)
											)
										)

										;remove all the cases
										(apply "destroy_entities" cases)

										;iterate over every session, cleaning up its replay steps and uptating its cases' training indices
										(map
											(lambda
												(let
													(assoc
														session (current_index
																1
															)
														removed_cases_map
															;if there's only one case for this session, its size will be 0, wrap it in a list prior to zipping
															(if
																(=
																	0
																	(size
																		(current_value
																			1
																		)
																	)
																)
																(zip
																	(list
																		(current_value
																			2
																		)
																	)
																)
																(zip
																	(current_value
																		1
																	)
																)
															)
														replay_steps (retrieve_from_entity
																(current_index
																	1
																)
																".replay_steps"
															)
													)

													;filter cases from replay steps, leave only those cases that have not been removed
													(assign
														(assoc
															replay_steps (filter
																	(lambda
																		(not
																			(contains_index
																				removed_cases_map
																				(current_value)
																			)
																		)
																	)
																	replay_steps
																)
														)
													)
													(assign_to_entities
														session
														(assoc
															".indices_map"
																;.indices_map is an assoc of train_index->case_id, so we can just simply delete all the removed training_indices with one delete call
																(remove
																	(retrieve_from_entity
																		session
																		".indices_map"
																	)
																	(get
																		session_train_indices_map
																		session
																	)
																)
															".replay_steps" replay_steps
														)
													)
												)
											)
											sessions_map
										)

										;model has changed so clear out these cached value
										(call ClearCachedCountsAndEntropies)
										(null)
									)

									;performs data reduction: removes training cases that have the highest conviction
									;returns true
									;parameters:
									; features: list of the features to search
									; num_cases_to_remove: the total number of training cases to remove
									; distribute_weight_feature: name of feature into which to distribute the removed cases' weights to their neighbors.
									##RemoveLeastInformativeTrainingCases
									(declare
										(assoc
											distribute_weight_feature (null)
											num_cases_to_remove 3
											features (list)
											hyperparam_map (call
													GetHyperparameters
													(assoc
														weight_feature ".none"
														feature ".targetless"
														mode "robust"
													)
												)
										)
										(declare
											(assoc
												entropies_map (compute_on_contained_entities
														(list
															(compute_entity_kl_divergences
																(get
																	hyperparam_map
																	"k"
																)
																features
																(null)
																(get
																	hyperparam_map
																	"featureWeights"
																)
																nominalClassCountsMap
																cyclicFeaturesMap
																(if
																	(get
																		hyperparam_map
																		"useDeviations"
																	)
																	(get
																		hyperparam_map
																		"featureDeviations"
																	)
																)
																(get
																	hyperparam_map
																	"p"
																)
																(get
																	hyperparam_map
																	"dwe"
																)
																(null)

																;don't want to weight cases even if they're weighted
																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
															)
														)
													)
											)
										)

										;sort by increasing entropy the lowest entropy at the end of the list
										(declare
											(assoc
												cases_by_entropy (sort
														(lambda
															(>
																(get
																	entropies_map
																	(current_value
																		1
																	)
																)
																(get
																	entropies_map
																	(current_value)
																)
															)
														)
														(indices
															entropies_map
														)
													)
											)
										)

										;delete the lowest entropy cases
										(call
											RemoveCases
											(assoc
												distribute_weight_feature distribute_weight_feature
												cases (tail
														cases_by_entropy
														num_cases_to_remove
													)
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)
										(true)
									)

									;performs data reduction: removes training cases that have been accessed the least
									;parameters:
									; num_cases_to_remove: the total number of training cases to remove
									; case_access_count_label: label on which accumulated the number of times each context has been accessed
									; distribute_weight_feature: name of feature into which to distribute the removed cases' weights to their neighbors.
									##RemoveLeastUsedTrainingCases
									(declare
										(assoc
											entities (call AllCases)
											distribute_weight_feature (null)
											case_access_count_label ""
											num_cases_to_remove 3
										)

										;get access count for each entity
										(declare
											(assoc
												access_count (map
														(lambda
															(retrieve_from_entity
																(current_index)
																case_access_count_label
															)
														)
														(zip
															entities
														)
													)
											)
										)

										;sort by access count
										(assign
											(assoc
												entities (sort
														(lambda
															(<
																(get
																	access_count
																	(current_value
																		1
																	)
																)
																(get
																	access_count
																	(current_value)
																)
															)
														)
														entities
													)
											)
										)

										;delete those with the lowest access count
										(call
											RemoveCases
											(assoc
												distribute_weight_feature distribute_weight_feature
												cases (trunc
														entities
														num_cases_to_remove
													)
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)
									)

									;removes the specified feature on all cases for a trainee that match the specified condition
									;if conditions are not specified, removes feature for all cases and from the model, if condition is an empty assoc, leaves the feature metadata in the model.
									;
									;parameters:
									; feature: the feature name to remove
									; condition: assoc of feature->value(s).
									;	  no value = must have feature
									;	- for continuous or numeric ordinal features:
									;	  one value = must equal exactly the value or be close to it for fuzzy match
									;	  values = inclusive between
									;	- for nominal or string ordinal features:
									;	  n values = must match any of these values exactly
									; session: the session id when this call is being made
									; condition_session_id: optional, if specified ignores condition and operates on cases for the specified session id
									##RemoveFeature
									(declare
										(assoc
											condition (null)
											condition_session_id (null)
											feature ""
											session "none"
										)

										;model has changed so clear out these cached value
										(assign_to_entities
											(assoc
												averageModelCaseEntropyAddition (null)
												averageModelCaseEntropyRemoval (null)
												averageModelCaseDistanceContribution (null)
												nominalClassProbabilitiesMap (if
														(contains_index
															nominalClassProbabilitiesMap
															feature
														)
														(assoc)
														nominalClassProbabilitiesMap
													)
												storedCaseConvictionsFeatureAddition (null)
											)
										)

										;remove feature from model if no conditions are specified
										(declare
											(assoc
												remove_feature_from_model (and
														(=
															(null)
															condition
														)
														(=
															(null)
															condition_session_id
														)
													)
											)
										)

										;get the list of cases to operate on, if condition isn't specified, operate on all cases
										(declare
											(assoc
												entities (if
														(not
															remove_feature_from_model
														)

														;specify no limit for how many to match as long as they match the condition
														(call
															GetCasesByCondition
															(assoc
																condition condition
																num_cases 0
																condition_session_id condition_session_id
																precision "exact"
															)
														)
														(call
															AllCases
														)
													)
												feature_with_label (concat
														"#"
														feature
													)
											)
										)

										;record edit history for each case
										(map
											(lambda
												(call
													AddCaseEditHistory
													(assoc
														feature feature
														session session
														case (current_value
																1
															)
														edit_type "remove"
													)
												)
											)
											entities
										)

										;remove the feature
										(map
											(lambda
												(assign_entity_roots
													(current_value)
													(filter
														(lambda
															(and
																(!=
																	(current_index)
																	feature_with_label
																)
																(not
																	(contains_value
																		(get_labels
																			(current_value)
																		)
																		feature_with_label
																	)
																)
															)
														)
														(retrieve_entity_root
															(current_value)
														)
													)
												)
											)
											entities
										)
										(if
											remove_feature_from_model
											(seq
												(if
													(contains_index
														nominalsSet
														feature
													)
													(assign_to_entities
														(assoc
															uniqueNominalsMap (remove
																	uniqueNominalsMap
																	feature
																)
															stringNominalFeaturesSet (remove
																	stringNominalFeaturesSet
																	feature
																)
															nonStringNominalFeaturesMap (remove
																	nonStringNominalFeaturesMap
																	feature
																)
															nominalsSet (remove
																	nominalsSet
																	feature
																)
															nominalClassCountsMap (remove
																	nominalClassCountsMap
																	feature
																)
														)
													)
												)
												(if
													(contains_value
														ordinalFeatures
														feature
													)
													(seq
														(assign_to_entities
															(assoc
																ordinalFeatures (filter
																		(lambda
																			(!=
																				feature
																				(current_value)
																			)
																		)
																		ordinalFeatures
																	)
																ordinalFeaturesValuesMap (remove
																		ordinalFeaturesValuesMap
																		feature
																	)
																ordinalStringToOrdinalMap (remove
																		ordinalStringToOrdinalMap
																		feature
																	)
																ordinalFeaturesRangesMap (remove
																		ordinalFeaturesRangesMap
																		feature
																	)
																ordinalOrdinalToStringMap (remove
																		ordinalOrdinalToStringMap
																		feature
																	)
															)
														)
														(if
															(=
																0
																(size
																	ordinalStringToOrdinalMap
																)
															)
															(assign_to_entities
																(assoc
																	hasStringOrdinals (false)
																)
															)
														)
													)
												)
												(if
													(contains_index
														cyclicFeaturesMap
														feature
													)
													(seq
														(assign_to_entities
															(assoc
																cyclicFeaturesMap (remove
																		cyclicFeaturesMap
																		feature
																	)
															)
														)
														(if
															(=
																0
																(size
																	cyclicFeaturesMap
																)
															)
															(assign_to_entities
																(assoc
																	hasCyclicFeatures (false)
																)
															)
														)
													)
												)
												(if
													(contains_index
														featureRoundingMap
														feature
													)
													(seq
														(assign_to_entities
															(assoc
																featureRoundingMap (remove
																		featureRoundingMap
																		feature
																	)
															)
														)
														(if
															(=
																0
																(size
																	featureRoundingMap
																)
															)
															(assign_to_entities
																(assoc
																	hasRoundedFeatures (false)
																)
															)
														)
													)
												)
												(if
													(contains_index
														featureDateTimeMap
														feature
													)
													(seq
														(assign_to_entities
															(assoc
																featureDateTimeMap (remove
																		featureDateTimeMap
																		feature
																	)
															)
														)
														(if
															(=
																0
																(size
																	featureDateTimeMap
																)
															)
															(assign_to_entities
																(assoc
																	hasDateTimeFeatures (false)
																)
															)
														)
													)
												)
												(if
													(contains_index
														inactiveFeaturesMap
														feature
													)
													(if
														(>
															(size
																inactiveFeaturesMap
															)
															1
														)
														(assign_to_entities
															(assoc
																inactiveFeaturesMap (remove
																		inactiveFeaturesMap
																		feature
																	)
															)
														)

														;else removing the only inactive feature, clear out the properties
														(assign_to_entities
															(assoc
																hasInactiveFeatures (false)
																inactiveFeaturesMap (null)
															)
														)
													)
												)
												(assign_to_entities
													(assoc
														defaultFeatures (filter
																(lambda
																	(!=
																		feature
																		(current_value)
																	)
																)
																defaultFeatures
															)
														substitutionValueMap (remove
																substitutionValueMap
																feature
															)
														categoricalFeaturesSet (remove
																categoricalFeaturesSet
																feature
															)
														featureAttributes (remove
																featureAttributes
																feature
															)
														expectedValuesMap (rewrite
																(lambda
																	(if
																		(contains_index
																			(current_value)
																			feature
																		)
																		(remove
																			(current_value)
																			feature
																		)
																		(current_value)
																	)
																)
																expectedValuesMap
															)
														hyperparameterMetadataMap (rewrite
																(lambda
																	(if
																		(contains_index
																			(current_value)
																			feature
																		)
																		(remove
																			(current_value)
																			feature
																		)
																		(current_value)
																	)
																)
																hyperparameterMetadataMap
															)
														featureCustomDerivedMethods (remove
																featureCustomDerivedMethods
																feature
															)
														cachedFeatureMinResidualMap (remove
																cachedFeatureMinResidualMap
																feature
															)
														cachedFeatureMinGapMap (remove
																cachedFeatureMinGapMap
																feature
															)
														sourceToDerivedFeatureMap (remove
																sourceToDerivedFeatureMap
																feature
															)
														featureBoundsMap (remove
																featureBoundsMap
																feature
															)
														derivedFeaturesMap (remove
																derivedFeaturesMap
																feature
															)
														featureNullRatiosMap (remove
																featureNullRatiosMap
																feature
															)
														unSubstituteValueMap (remove
																unSubstituteValueMap
																feature
															)
													)
												)
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)

										;return completion
										(true)
									)

									;creates a new case given a list of features and their values in feature_values
									; assigning its session and session_training_index
									;returns the id of the case created
									;parameters:
									; feature_values: list of feature values
									; features: list of feature names
									; session: session ID string
									; session_training_index: 0-based index of the case, ordered by training during the session;  is not changed
									##CreateCase
									(first
										(create_entities
											(set_type
												(append

													;bring in context
													(zip_labels
														features
														feature_values
													)

													;add session info
													(zip_labels
														(list
															internalLabelSession
															internalLabelSessionTrainingIndex
														)
														(list
															session
															session_training_index
														)
													)
												)
												(null)
											)
										)
									)

									;Adds the specified feature on all cases for a trainee that match the specified condition. overwrites features that
									;If condition are not specified, adds feature for all cases and to the model.  If condition is an empty assoc, will not modify feature metadata in the model.
									;If feature attributes are passed in, will also set the model's featurue attributes.
									;
									;parameters:
									; feature: name of feature to odd
									; feature_value: optional value for the feature
									; ovewrite: flag, whether to overwrite values for features that already exist
									; condition: assoc of feature->value(s) (no value = must have feature, one value = must equal exactly the value, two values = inclusive between)
									; session: the session id when this call is being made
									; condition: assoc of feature->value(s).
									;	  no value = must have feature
									;	- for continuous or numeric ordinal features:
									;	  one value = must equal exactly the value or be close to it for fuzzy match
									;	  values = inclusive between
									;	- for nominal or string ordinal features:
									;	  n values = must match any of these values exactly
									; entities: list of case ids to operate on. if specified, conditions will be ignored
									; internal_feature: flag, if set to true, will not update hyperparameter metadata map
									; feature_attributes: optional, dict of feature specific attributes for this feature. If unspecified and conditions are not specified, will assume feature type as 'continuous'.
									##AddFeature
									(declare
										(assoc
											entities (null)
											condition (null)
											condition_session_id (null)
											internal_feature (false)
											session "none"
											feature_attributes (null)
											feature ""
											overwrite (true)
											feature_value (null)
										)
										(if
											(contains_index
												untrainableFeatureCharacterSet
												(first feature)
											)
											(conclude "Failed to add feature: ensure it does not start with an invalid character.")
										)
										(if
											(and
												feature_attributes
												(contains_index
													featureAttributes
													feature
												)
											)
											(conclude "Feature already defined, either call add_feature without specifying feature_attributes or call set_feature_attributes to update existing feature attributes.")
										)

										;add feature to model if no conditions are specified
										(declare
											(assoc
												add_feature_to_model (and
														(=
															(null)
															condition
														)
														(=
															(null)
															condition_session_id
														)
													)
											)
										)

										;get all cases that need to be updated
										(if
											(= (null) entities)
											(assign
												(assoc
													entities (if
															(not
																add_feature_to_model
															)

															;specify no limit for how many to match as long as they match the condition
															(call
																GetCasesByCondition
																(assoc
																	condition condition
																	num_cases 0
																	condition_session_id condition_session_id
																	precision "exact"
																)
															)
															(call
																AllCases
															)
														)
												)
											)
										)

										;only add feature to model if it is not an internal feature (e.g., .imputed) or if feature_attributes were provided or feature isn't defined
										(assign
											(assoc
												add_feature_to_model (and
														(not
															internal_feature
														)
														(not
															(contains_index
																featureAttributes
																feature
															)
														)
														(or
															feature_attributes
															add_feature_to_model
															(not
																(contains_index
																	featureAttributes
																	feature
																)
															)
														)
													)
											)
										)
										(if
											add_feature_to_model
											(let
												(assoc
													null_feature (=
															(null)
															feature_value
														)
													min_deviation_value (/
															1
															(call
																GetNumTrainingCases
															)
														)
												)
												(if
													null_feature
													(if
														hasInactiveFeatures
														(accum_to_entities
															(assoc
																inactiveFeaturesMap (associate
																		feature
																		0
																	)
															)
														)
														(assign_to_entities
															(assoc
																hasInactiveFeatures (true)
																inactiveFeaturesMap (associate
																		feature
																		0
																	)
															)
														)
													)
												)

												;upadte hyperparameters and clear the cached residuals flags
												(assign_to_entities
													(assoc
														defaultFeatures (if
																(not
																	(contains_value
																		defaultFeatures
																		feature
																	)
																)
																(append
																	defaultFeatures
																	feature
																)
																defaultFeatures
															)
														hyperparameterMetadataMap (map
																(lambda
																	(let
																		(assoc
																			hp_map (current_value
																					1
																				)
																		)
																		(map
																			(lambda
																				(let
																					(assoc
																						mode (current_index
																								1
																							)
																						mode_map (current_value
																								1
																							)
																					)
																					(map
																						(lambda
																							(let
																								(assoc
																									weight_feature (current_index
																											1
																										)
																									feature_map (current_value
																											1
																										)
																								)

																								;clear cached flag
																								(accum
																									(assoc
																										feature_map (assoc
																												allFeatureResidualsCached (false)
																											)
																									)
																								)

																								;set weight to 1 if value being added is not null, else set to 0
																								(if
																									(!=
																										(get
																											feature_map
																											"featureWeights"
																										)
																										(null)
																									)
																									(assign
																										"feature_map"
																										(list
																											"featureWeights"
																											feature
																										)
																										(if
																											null_feature
																											0
																											1
																										)
																									)

																									;else there are no featureWeights, set all active features to 1 and inactive features to 0
																									(assign
																										"feature_map"
																										(list
																											"featureWeights"
																										)
																										(append
																											(zip
																												defaultFeatures
																												1
																											)
																											inactiveFeaturesMap
																										)
																									)
																								)

																								;set residual to min value
																								(if
																									(!=
																										(get
																											feature_map
																											"featureDeviations"
																										)
																										(null)
																									)
																									(assign
																										"feature_map"
																										(list
																											"featureDeviations"
																											feature
																										)
																										min_deviation_value
																									)
																								)
																								feature_map
																							)
																						)
																						mode_map
																					)
																				)
																			)
																			hp_map
																		)
																	)
																)
																hyperparameterMetadataMap
															)
													)
												)

												;if attributes were not provided, default to continous
												(if
													(=
														(null)
														feature_attributes
													)
													(assign
														(assoc
															feature_attributes (assoc
																	type "continuous"
																	bounds (assoc
																			allow_null (true)
																		)
																)
														)
													)
												)

												;append attributes to the existing ones and re-set attributes
												(assign
													(assoc
														feature_attributes (append
																(call
																	GetFeatureAttributes
																)
																(associate
																	feature
																	feature_attributes
																)
															)
													)
												)
												(call
													SetFeatureAttributes
													(assoc
														features feature_attributes
													)
												)
											)
										)

										;store the originally passed in value as-is for history tracking
										(declare
											(assoc
												unencoded_feature_value (get_value
														feature_value
													)
											)
										)

										;encode feature values if necessary
										(if
											hasFeaturesNeedEncodingFromInput
											(assign
												(assoc
													feature_value (first
															(call
																ConvertFromInput
																(assoc
																	feature_values (list
																			feature_value
																		)
																	features (list
																			feature
																		)
																)
															)
														)
												)
											)
										)

										;create at assoc of case id -> value
										(declare
											(assoc
												case_values_map (if
														(=
															(null)
															feature_value
														)
														(zip
															entities
														)
														(zip
															entities
															(map
																feature_value
																entities
															)
														)
													)
											)
										)

										;record edit history for each case
										(map
											(lambda
												(let
													(assoc
														case_id (current_value
																1
															)
													)
													(call
														AddCaseEditHistory
														(assoc
															feature feature
															session session
															case case_id
															feature_value unencoded_feature_value
															edit_type "set"
														)
													)

													;make a map of all the imputed features (if there are any) for fast lookup and deletion
													(declare
														(assoc
															imputed_map (zip
																	(retrieve_from_entity
																		case_id
																		internalLabelImputed
																	)
																)
														)
													)

													;check if this case has this feature on its imputed list, and if so remove it from there since its value was just overwritten
													(if
														(contains_index
															imputed_map
															feature
														)

														;remove this feature from the imputed_map and overwrite the stored imputed features using the resulting list
														(call
															StoreCaseValues
															(assoc
																case_values_map (associate
																		case_id
																		(indices
																			(remove
																				imputed_map
																				feature
																			)
																		)
																	)
																overwrite 1
																label_name internalLabelImputed
															)
														)
													)
												)
											)
											entities
										)
										(call
											StoreCaseValues
											(assoc
												case_values_map case_values_map
												overwrite overwrite
												label_name feature
											)
										)
										(if
											(and
												add_feature_to_model
												(size nominalsSet)
											)
											(call
												UpdateNominalClassCountsForFeature
												(assoc
													feature feature
												)
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)

										;return completion
										(true)
									)

									;Edit feature values for the specified cases.
									;Cases are specified by either case_indices or by the condition. If neither is provided, edits all cases.
									;returns null if ivalid features specified or an assoc with "count"
									;
									;parameters:
									; features: list of names of feature to edit
									; feature_values: list of values corresponding to features
									; case_indices: optional, list of pair (list) of session id and index, where index is the original 0-based session_training_index of the case as
									; 		it was trained. If specified, ignores condition and condition_session_id
									; condition_session_id: optional, if specified ignores condition and operates on cases for the specified session id
									; condition: assoc of feature->value(s)
									;		no value = must have feature
									;   	- for continuous or numeric ordinal features:
									;			one value = must equal exactly the value or be close to it for fuzzy match
									;			two values = inclusive between
									;   	- for nominal or string ordinal features:
									;			n values = must match any of these values exactly
									; precision: optional string,  default is 'exact', used only with 'condition' parameter, will find exact matches if 'exact' and similar cases if 'similar'.
									; session: the session id when this call is being made
									##EditCases
									(declare
										(assoc
											feature_values (list)
											condition (assoc)
											condition_session_id (null)
											session "none"
											features (list)
											precision "exact"
											case_indices (list)
										)

										;can't edit invalid or internal features
										(declare
											(assoc
												unencoded_feature_values (get_value
														feature_values
													)
												session_indices_map (assoc)
												has_invalid_features (size
														(filter

															;leave only invalid features
															(lambda
																(contains_index
																	untrainableFeatureCharacterSet
																	(first
																		(current_value)
																	)
																)
															)
															features
														)
													)
											)
										)
										(if
											has_invalid_features
											(conclude (null))
										)

										;encode feature values if necessary
										(if
											hasFeaturesNeedEncodingFromInput
											(assign
												(assoc
													feature_values (call
															ConvertFromInput
															(assoc
																feature_values feature_values
																features features
															)
														)
												)
											)
										)
										(declare
											(assoc
												case_ids
													;if case_indices are provided, pull cases by those
													(if
														(size
															case_indices
														)
														(map
															(lambda
																(let
																	(assoc
																		session_id (first
																				(current_value
																					1
																				)
																			)
																		case_index (last
																				(current_value
																					1
																				)
																			)
																	)

																	;if session_indices_map doesn't have this session, add it
																	(if
																		(not
																			(contains_index
																				session_indices_map
																				session_id
																			)
																		)
																		(accum
																			(assoc
																				session_indices_map (associate
																						session_id
																						(retrieve_from_entity
																							session_id
																							".indices_map"
																						)
																					)
																			)
																		)
																	)
																	(get
																		session_indices_map
																		(list
																			session_id
																			case_index
																		)
																	)
																)
															)
															case_indices
														)

														;otherwise pull cases by condition
														(size
															condition
														)

														;specify no limit for how many to match as long as they match the condition
														(call
															GetCasesByCondition
															(assoc
																condition condition
																num_cases 0
																condition_session_id condition_session_id
																precision precision
															)
														)

														;else pull all cases
														(call
															AllCases
														)
													)
											)
										)
										(if
											case_ids
											(map
												(lambda
													(call
														UpdateCaseWithHistory
														(assoc
															feature_values feature_values
															unencoded_feature_values unencoded_feature_values
															session session
															features features
															case_id (current_value
																	1
																)
														)
													)
												)
												case_ids
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)

										;return number of case ids edited
										(assoc
											count (size case_ids)
										)
									)

									;update a cases's history with specified values
									;
									;parameters:
									; case_id: case id of case whose history is being updated
									; features: list of feature names that are being edited
									; feature_vaues: list of encoded values for storing into the case
									; unencoded_feature_values: list of original values the featurse are being set to for history
									; session: the session id when this call is being made
									##UpdateCaseWithHistory
									(declare
										(assoc
											feature_values (list)
											unencoded_feature_values (list)
											session "none"
											features (list)
											case_id (null)
										)

										;pull previous case values pre-edit
										(declare
											(assoc
												previous_values (retrieve_from_entity
														case_id
														features
													)
											)
										)
										(if
											hasEncodedFeatures
											(assign
												(assoc
													previous_values (call
															ConvertToOutput
															(assoc
																feature_values previous_values
																features features
															)
														)
												)
											)
										)
										(declare
											(assoc
												edit_events (map
														(lambda
															(assoc
																feature (current_value
																		1
																	)
																value (get
																		unencoded_feature_values
																		(current_index
																			1
																		)
																	)
																type "edit"
																previous_value (get
																		previous_values
																		(current_index
																			1
																		)
																	)
															)
														)
														features
													)
											)
										)
										(declare
											(assoc
												case_edit_history
													;if the case has no edit history, create the label for it with an empty assoc as the value
													(if
														(not
															(contains_label
																case_id
																internalLabelCaseEditHistory
															)
														)
														(seq

															;need to explicitly add the internalLabelCaseEditHistory label to the case
															(call
																StoreCaseValues
																(assoc
																	case_values_map (associate
																			case_id
																			(assoc)
																		)
																	label_name internalLabelCaseEditHistory
																)
															)
															(assoc)
														)

														;else retrieve the existing edit history
														(retrieve_from_entity
															case_id
															internalLabelCaseEditHistory
														)
													)
											)
										)

										;update the history record for this case
										(assign
											(assoc
												case_edit_history
													;if making updates to a session already in the history, append to that session history
													(if
														(contains_index
															case_edit_history
															session
														)
														(let

															;get the list of edits for this session
															(assoc
																session_history_list (get
																		case_edit_history
																		session
																	)
															)

															;add to the list of edits the current edit event
															(accum
																(assoc
																	session_history_list edit_events
																)
															)

															;output the appended new list of edits to the edit history
															(append
																case_edit_history
																(associate
																	session
																	session_history_list
																)
															)
														)

														;output the created history entry for this session
														(append
															case_edit_history
															(associate
																session
																edit_events
															)
														)
													)
											)
										)

										;write the updated values along with the history to the case
										(assign_to_entities
											case_id
											(append
												(zip
													features
													feature_values
												)
												(associate
													internalLabelCaseEditHistory
													case_edit_history
												)
											)
										)
									)

									;adds edit history to an individual case
									;example format of case_edit_history label as stored in each case entity:
									;	(assoc
									;		"sessionId_A"
									;			(list
									;				(assoc "feature" "A"  "type" "set" "value" 5)
									;				(assoc "feature" "B"  "type" "remove")
									;			)
									;		"sessionId_B"
									;			(list (assoc "feature" "C" "type" "set" "value" (null)))
									;	)
									;parameters:
									; edit_type : set, impute or remove
									; case : entity id of case to edit
									; feature : feature that was edited
									; feature_value : optional value feature was set to
									; session : session id of edit
									##AddCaseEditHistory
									(declare
										(assoc
											feature ""
											session "none"
											case (null)
											feature_value (null)
											edit_type "edit"
										)
										(if
											(!= (null) case)
											(let
												(assoc
													edit_event (if
															(=
																edit_type
																"remove"
															)
															(assoc
																feature feature
																type edit_type
															)
															(assoc
																feature feature
																value feature_value
																type edit_type
															)
														)
													previous_value (retrieve_from_entity
															case
															feature
														)
												)
												(if
													hasEncodedFeatures
													(assign
														(assoc
															previous_value (first
																	(call
																		ConvertToOutput
																		(assoc
																			feature_values (list
																					previous_value
																				)
																			features (list
																					feature
																				)
																		)
																	)
																)
														)
													)
												)
												(accum
													(assoc
														edit_event (assoc
																previous_value previous_value
															)
													)
												)

												;if the case has no edit history, create the label for it with an empty assoc as the value
												(if
													(not
														(contains_label
															case
															internalLabelCaseEditHistory
														)
													)
													(call
														StoreCaseValues
														(assoc
															case_values_map (associate
																	case
																	(assoc)
																)
															label_name internalLabelCaseEditHistory
														)
													)
												)
												(declare
													(assoc
														case_edit_history (retrieve_from_entity
																case
																internalLabelCaseEditHistory
															)
													)
												)

												;if making updates to a session already in the history, append to that session history
												(if
													(contains_index
														case_edit_history
														session
													)
													(let

														;get the list of edits for this session
														(assoc
															session_history_list (get
																	case_edit_history
																	session
																)
														)

														;add to the list of edits the current edit event
														(accum
															(assoc
																session_history_list (list
																		edit_event
																	)
															)
														)

														;append the new list of edits to the edit history
														(accum
															(assoc
																case_edit_history (associate
																		session
																		session_history_list
																	)
															)
														)
													)

													;else create the history entry for this session
													(accum
														(assoc
															case_edit_history (associate
																	session
																	(list
																		edit_event
																	)
																)
														)
													)
												)

												;store the updated value into case_edit_history label
												(assign_to_entities
													case
													(associate
														internalLabelCaseEditHistory
														case_edit_history
													)
												)
											)
										)
									)

									;stores the associated value with each entity id (the keys of case_values_map) to the respective entity
									; using the label_name specified
									;if the entity does not have the label, but its root node is a null, then it will add the label and store the data
									; parameters:
									; ovewrite: flag, whether to overwrite values for features that already exist
									; case_values_map : assoc of case id -> value
									; label_name : name of label for the feature to be stored
									##StoreCaseValues
									(declare
										(assoc
											case_values_map (assoc)
											overwrite 1
											label_name ""
										)
										(map
											(lambda
												(if

													;see whether the entity has the label
													(contains_label
														(current_index)
														label_name
													)

													;entity has label, overwite if overwrite flag is set, otherwise do nothing
													(if
														overwrite
														(assign_to_entities
															(current_index)
															(associate
																label_name
																(get
																	case_values_map
																	(current_index
																		1
																	)
																)
															)
														)
													)

													;else need to append the label to the entity
													(accum_entity_roots
														(current_index)
														(list
															(set_labels
																(get
																	case_values_map
																	(current_index
																		1
																	)
																)
																(list
																	label_name
																)
															)
														)
													)
												)
											)
											case_values_map
										)
									)
								)

								;module for trainee_template
								;contains methods for imputation of trainee and clearing of imputation data
								(null

									;imputes the model, filling in all the (null) feature values
									; parameters:
									; features : optional, list of features to use for imputation. if unspecified will use all the features in the dataset
									; features_to_impute : optional, list of features to impute. if unspecified will use features
									; session: the session id for this impute
									; batch_size : a positive integer, specifying how many rows to fill before recomputing entropy. default is 1 which should return the
									;				best accuracy since it'll recompute it everytime.  Higher values should improve performance but may decrease accuracy of results
									##Impute
									(declare
										(assoc
											features_to_impute (list)
											session "none"
											features (list)
											batch_size 1
										)

										;if session or batch_size being passed in as null from st, overwrite them with defaults
										(if
											(= (null) session)
											(assign
												(assoc
													session "none"
												)
											)
										)
										(if
											(= (null) batch_size)
											(assign
												(assoc
													batch_size 1
												)
											)
										)
										(if
											(= (list) features)
											(assign
												(assoc
													features defaultFeatures
												)
											)
										)
										(if
											(= (list) features_to_impute)
											(assign
												(assoc
													features_to_impute features
												)
											)
										)

										;reset any cached feature or case entropies
										(assign_to_entities
											(assoc
												averageModelCaseEntropyAddition (null)
												averageModelCaseEntropyRemoval (null)
												averageModelCaseDistanceContribution (null)
												storedCaseConvictionsFeatureAddition (null)
											)
										)

										;pull all the cases that have nulls
										(declare
											(assoc
												react_entity_ids (list)
												react_cases (list)
												has_value_filled 0
												case_entity_id (null)
												has_remaining_null 0
											)
										)

										;filter out any features where all cases are null (empty feature), they cannot be imputed
										(assign
											(assoc
												features_to_impute (filter
														(lambda

															;keep features if they have any non-null cases for this feature
															(>
																(compute_on_contained_entities
																	(list
																		(query_not_equals
																			(current_value
																				1
																			)
																			(null)
																		)
																		(query_count)
																	)
																)
																0
															)
														)
														features_to_impute
													)
											)
										)
										(while
											(true)

											;get the list of entity ids that have null values
											(assign
												(assoc
													react_entity_ids (indices
															(zip
																(apply
																	(lambda
																		(append)
																	)

																	;make a list of lists of entity ids that have any features set to (null)
																	;find the entities that have a reference to replay sessions, only cases have this reference
																	(map
																		(lambda
																			(contained_entities
																				(list
																					(query_equals
																						(current_value
																							1
																						)
																						(null)
																					)
																					(query_exists
																						internalLabelSession
																					)
																				)
																			)
																		)
																		features_to_impute
																	)
																)
															)
														)
													has_value_filled 0
													has_remaining_null 0
												)
											)

											;pull the all the cases that have missing values by their entity id, and append the entity id to the end
											(assign
												(assoc
													react_cases (map
															(lambda
																(append
																	(retrieve_from_entity
																		(current_value)
																		features
																	)
																	(current_value)
																)
															)
															react_entity_ids
														)
												)
											)

											;prevent infinite loop if there are no react cases
											(if
												(=
													0
													(size
														react_cases
													)
												)
												(conclude (false))
											)

											;process all the cases that need to be filled
											(while
												(>
													(size
														react_cases
													)
													0
												)

												;clear cached conviction values for cases
												(assign_to_entities
													(assoc
														storedConvictionsFeatureSet (null)
													)
												)

												;compute entropy of each row, append it to the end of each row, and overwrite react_cases with these updated rows
												(assign
													(assoc
														react_cases (map
																(lambda
																	(let

																		;pull the entity from the end of the row to compute the entropy of the case
																		(assoc
																			entropy_of_row
																				;taking the inverse of conviction to provide value proportional to entropy
																				(/
																					1
																					(call
																						ComputeCaseAdditionFamiliarityConviction
																						(assoc
																							case_id (last
																									(current_value
																										2
																									)
																								)
																							features features
																						)
																					)
																				)
																		)

																		;if entropy is ever nan, set the value to 1 so that only the number of nulls matters
																		;TODO: remove this statement after implementing 2992
																		(if
																			(=
																				.nan
																				entropy_of_row
																			)
																			(assign
																				(assoc
																					entropy_of_row 1
																				)
																			)
																		)

																		;scale entropy for case by the number of nulls in the case
																		(declare
																			(assoc
																				num_of_nulls (size
																						(filter
																							(lambda
																								(=
																									(current_value)
																									(null)
																								)
																							)
																							(current_value
																								1
																							)
																						)
																					)
																			)
																		)

																		;append the entropy of the row as the last feature value
																		(append
																			(current_value)
																			(*
																				entropy_of_row
																				num_of_nulls
																			)
																		)
																	)
																)
																react_cases
															)
													)
												)

												;sort react_cases by the entropies (low to high), which are the last values in each row
												(assign
													(assoc
														react_cases (sort
																(lambda
																	(-
																		(last
																			(current_value)
																		)
																		(last
																			(current_value
																				1
																			)
																		)
																	)
																)
																react_cases
															)
													)
												)

												;truncate all the entropy values now that they've been calculated
												(assign
													(assoc
														react_cases (map
																(lambda
																	(trunc
																		(current_value)
																	)
																)
																react_cases
															)
													)
												)

												;react to the sorted react_cases and update the model with the filled in results (if any feature was filled)
												;fills in the the number of cases specified by batch_size, and removes those cases from the react_cases list
												;then repeats the outer loop until the the react_cases list is empty (every case was attempted to be filled)
												(let
													(assoc
														counter 0
														context_values (list)
														action_values (null)
														fill_features (list)
													)

													;loop batch_size times and while the react_cases is not empty
													(while
														(and
															(<
																counter
																batch_size
															)
															(>
																(size
																	react_cases
																)
																0
															)
														)
														(assign
															(assoc
																case_values (retrieve_from_entity
																		(last
																			(first
																				react_cases
																			)
																		)
																		features_to_impute
																	)
																context_values (trunc
																		(first
																			react_cases
																		)
																	)
																case_entity_id (last
																		(first
																			react_cases
																		)
																	)
																fill_features (list)
															)
														)

														;set fill features to match only those that have nulls as their values
														(assign
															(assoc
																fill_features (filter
																		(lambda
																			(=
																				(null)
																				(get
																					case_values
																					(current_index)
																				)
																			)
																		)
																		features_to_impute
																	)
															)
														)

														;react to row
														(assign
															(assoc
																action_values (call
																		ReactDiscriminative
																		(assoc
																			return_action_values_only (true)
																			skip_decoding 1
																			ignore_case case_entity_id
																			context_values context_values
																			substitute_output (false)
																			action_features fill_features
																			match_on_context_features (true)
																			skip_encoding 1
																			context_features features
																		)
																	)
															)
														)

														;.nan value could possibly happen if either tiny or extremely sparse dataset can't find matching cases with valid distances to cases with filled
														;feature value due to not having matching filled features, thus replace any .nan with the feature expected value
														(if
															(contains_value
																action_values
																.nan
															)
															(assign
																(assoc
																	action_values (map
																			(lambda
																				(if
																					(=
																						.nan
																						(current_value)
																					)
																					(get
																						(call
																							CalculateFeatureExpectedValue
																							(assoc
																								feature (get
																										fill_features
																										(current_index
																											1
																										)
																									)
																								output_instead_of_store (true)
																							)
																						)
																						"expected_value"
																					)

																					;leave it as-is
																					(current_value)
																				)
																			)
																			action_values
																		)
																)
															)
														)
														(if
															(contains_value
																action_values
																(null)
															)
															(assign
																(assoc
																	has_remaining_null 1
																)
															)
															(assign
																(assoc
																	has_value_filled 1
																)
															)
														)

														;set to 1 if there are any values in the action_values that aren't null
														(if
															(not
																has_value_filled
															)
															(assign
																(assoc
																	has_value_filled
																		;check if size of array with null filtered is more than 0
																		(>
																			(size
																				(filter
																					action_values
																				)
																			)
																			0
																		)
																)
															)
														)

														;overwrite this case features' with the updated values
														(assign_to_entities
															case_entity_id
															(zip
																fill_features
																action_values
															)
														)

														;add imputed label to case if it already doesn't exist
														(if
															(not
																(contains_label
																	case_entity_id
																	internalLabelImputed
																)
															)
															(call
																StoreCaseValues
																(assoc
																	case_values_map (associate
																			case_entity_id
																			fill_features
																		)
																	label_name internalLabelImputed
																)
															)

															;else append to existing list
															(let
																(assoc
																	current_imputed_features (retrieve_from_entity
																			case_entity_id
																			internalLabelImputed
																		)
																)

																;append fill_features to the current list, then get rid of duplicates by converting to an assoc
																;and returning just the indices
																(assign
																	(assoc
																		current_imputed_features (indices
																				(zip
																					(append
																						current_imputed_features
																						fill_features
																					)
																				)
																			)
																	)
																)

																;overwrite the stored imputed features with this new list
																(call
																	StoreCaseValues
																	(assoc
																		case_values_map (associate
																				case_entity_id
																				current_imputed_features
																			)
																		overwrite 1
																		label_name internalLabelImputed
																	)
																)
															)
														)

														;store the case edit history for this case
														(map
															(lambda
																(call
																	AddCaseEditHistory
																	(assoc
																		feature (current_value
																				1
																			)
																		session session
																		case case_entity_id
																		feature_value (get
																				action_values
																				(current_index
																					1
																				)
																			)
																		edit_type "impute"
																	)
																)
															)
															fill_features
														)

														;pop the the first row off react_cases, looping will stop when react_cases is empty
														(assign
															(assoc
																react_cases (tail
																		react_cases
																	)
																counter (+
																		counter
																		1
																	)
															)
														)
													)
												)

												;stop iterating if none of the filled cases have nulls left, or none of the cases had anything filled
												(if
													(or
														(not
															has_remaining_null
														)
														(not
															has_value_filled
														)
													)
													(seq
														(accum_to_entities
															(assoc
																revision 1
															)
														)
														(conclude
															(true)
														)
													)
												)
											)
										)

										;while (not stop_iterating)
										(accum_to_entities
											(assoc revision 1)
										)
										(true)
									)

									;clear values that were imputed during a specified session, but won't clear values that were manually set by user after the impute
									;parameters:
									; session: session id of this action
									; impute_session_id: session id of the impute for which to clear the data. if null, will clear all imputed
									##ClearImputedSession
									(declare
										(assoc
											impute_session_id (null)
											session "clear_impute_none"
										)

										;get all cases that were imputed at some point
										(declare
											(assoc
												imputed_cases (contained_entities
														(list
															(query_exists
																internalLabelImputed
															)
														)
													)
											)
										)

										;create a map of case -> all currently imputed features
										(declare
											(assoc
												imputed_cases_features_map (map
														(lambda
															(retrieve_from_entity
																(current_index)
																internalLabelImputed
															)
														)
														(zip
															imputed_cases
														)
													)
											)
										)

										;if imputed session id is specified, generate a map of case_id -> remaining imputed features from the specified session
										;otherwise just clear all currently imputed
										(if
											(!= (null) impute_session_id)
											(assign
												(assoc
													imputed_cases_features_map (map
															(lambda
																(let
																	(assoc
																		case_history_map (retrieve_from_entity
																				(current_index
																					1
																				)
																				internalLabelCaseEditHistory
																			)
																		all_imputed_features (current_value
																				1
																			)
																	)

																	;only clear imputed cases that have not been manually overwritten and are still marked as imputed
																	(if
																		(>
																			(size
																				all_imputed_features
																			)
																			0
																		)

																		;retrieve the list of edits for the specified impute session
																		(declare
																			(assoc
																				session_edits (get
																						case_history_map
																						impute_session_id
																					)
																			)

																			;if there were edits for the specified session, pull out the features that were imputed, else return empty list
																			(if
																				(>
																					(size
																						session_edits
																					)
																					0
																				)
																				(seq

																					;keep only those edits that were impute
																					(assign
																						(assoc
																							session_edits (filter
																									(lambda
																										(=
																											"impute"
																											(get
																												(current_value)
																												"type"
																											)
																										)
																									)
																									session_edits
																								)
																						)
																					)

																					;iterate over all the features that were imputed during this session
																					;keeping and returning  only those features that are still marked as imputed
																					(weave
																						(lambda
																							(let
																								(assoc
																									session_imputed_feature (get
																											(first
																												(current_value
																													1
																												)
																											)
																											"feature"
																										)
																								)

																								;only output the features that are still marked as imputed
																								(if
																									(contains_value
																										all_imputed_features
																										session_imputed_feature
																									)

																									;weave value outputs are in a list format
																									(list
																										session_imputed_feature
																									)

																									;empty list means no output / filtered out
																									(list)
																								)
																							)
																						)
																						session_edits

																						;use weave as a map-filter by specifying null as the second list
																						(null)
																					)
																				)

																				;else there were no imputed values in this session, output empty list
																				(list)
																			)
																		)

																		;else there are no imputed values remaining, output empty list
																		(list)
																	)
																)
															)
															imputed_cases_features_map
														)
												)
											)
										)

										;iterate over the cases and clear out the imputed features from the specified session
										(map
											(lambda
												(let
													(assoc
														case_id (current_index
																1
															)
													)
													(if
														(>
															(size
																(current_value)
															)
															0
														)

														;iterate over the list of imputed features for this case and set each one to null
														(map
															(lambda

																;set the value of this feature to (null) for this specific case
																(call
																	AddFeature
																	(assoc
																		entities (list
																				case_id
																			)
																		internal_feature (true)
																		feature (current_value
																				1
																			)
																		session session
																		overwrite 1
																		feature_value (null)
																	)
																)
															)
															(current_value)
														)
													)
												)
											)
											imputed_cases_features_map
										)
										(accum_to_entities
											(assoc revision 1)
										)
										(true)
									)
								)

								;module for trainee_template
								;contains methods for calculating conviction for cases and features
								(null

									;computes various data, such as familiarity convictions and distance contribution for each case in the model and stores them into specified features.
									;
									;parameters:
									; familiarity_conviction_addition : true or string, if true will use default value of "familiarity_conviction_addition" for feature name
									; familiarity_conviction_removal : true or string, if true will use default value of "familiarity_conviction_removal" for feature name
									; p_value_of_addition: true or string, default is false. if true will use default value of 'p_value_of_addition' for feature name
									; p_value_of_removal: true or string, default is false. if true will use default value of 'p_value_of_removal' for feature name
									; distance_contribution : true or string, if true will use default value of "distance_contribution" for feature name
									; features: list of features for which to calculate conviction, will default to trainee's default features if unspecified
									; case_ids: the list of case ids for the model to calculate conviction for
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; high_distance_accuracy: optional, flag, defaults to true. if set to false, will use low accuracy when computing distances.
									##ReactIntoFeatures
									(declare
										(assoc
											p_value_of_addition (null)
											p_value_of_removal (null)
											distance_contribution (null)
											weight_feature ".case_weight"
											familiarity_conviction_removal (null)
											features (null)
											case_ids (null)
											use_case_weights (false)
											high_distance_accuracy (true)
											familiarity_conviction_addition (null)
										)

										;if no parameters specified, do nothing
										(if
											(=
												(null)
												familiarity_conviction_addition
												familiarity_conviction_removal
												distance_contribution
												p_value_of_addition
												p_value_of_removal
											)
											(conclude (true))
										)

										;if any of the compute options are true, overtrite with their corresponding default feature names
										(if
											(= (true) familiarity_conviction_addition)
											(assign
												(assoc
													familiarity_conviction_addition "familiarity_conviction_addition"
												)
											)
										)
										(if
											(= (true) familiarity_conviction_removal)
											(assign
												(assoc
													familiarity_conviction_removal "familiarity_conviction_removal"
												)
											)
										)
										(if
											(= (true) p_value_of_addition)
											(assign
												(assoc
													p_value_of_addition "p_value_of_addition"
												)
											)
										)
										(if
											(= (true) p_value_of_removal)
											(assign
												(assoc
													p_value_of_removal "p_value_of_removal"
												)
											)
										)
										(if
											(= (true) distance_contribution)
											(assign
												(assoc
													distance_contribution "distance_contribution"
												)
											)
										)
										(if
											(= (null) features)
											(assign
												(assoc
													features defaultFeatures
												)
											)
										)
										(declare
											(assoc
												model_size (call
														GetNumTrainingCases
													)
												valid_weight_feature (false)
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature ".none"
															feature ".targetless"
															mode "robust"
														)
													)
											)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)

											;else using case weights, weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
											(assign
												(assoc
													valid_weight_feature (or
															hasPopulatedCaseWeight
															(!=
																weight_feature
																".case_weight"
															)
														)
												)
											)
										)
										(declare
											(assoc
												feature_weights (get
														hyperparam_map
														"featureWeights"
													)
												closest_k (get
														hyperparam_map
														"k"
													)
												feature_deviations (if
														(get
															hyperparam_map
															"useDeviations"
														)
														(get
															hyperparam_map
															"featureDeviations"
														)
													)
											)
										)

										;closest k must be at least 2 smaller than model size, i.e., a model of 5 needs a K of 3 or less:
										;when knocking out a case during conviction calculations, each remaining case searches for K cases around itself
										;meaning that the K must be at least 2 less than the model size
										(if
											(<
												model_size
												(+
													closest_k
													2
												)
											)
											(assign
												(assoc
													closest_k (-
															model_size
															2
														)
												)
											)
										)
										(if
											(or familiarity_conviction_addition p_value_of_addition)

											;calculates the conviction for each case, making a map of case id -> conviction
											(let
												(assoc
													entropies_map (compute_on_contained_entities
															(list
																||(compute_entity_kl_divergences
																	closest_k
																	features
																	case_ids
																	feature_weights
																	nominalClassCountsMap
																	cyclicFeaturesMap
																	feature_deviations
																	(get
																		hyperparam_map
																		"p"
																	)
																	(get
																		hyperparam_map
																		"dwe"
																	)
																	(if
																		valid_weight_feature
																		weight_feature
																		(null)
																	)

																	;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																	"fixed rand seed"
																	(null)

																	;radius
																	lpSpaceHeuristicMultiplier
																	high_distance_accuracy
																)
															)
														)
												)
												(if
													p_value_of_addition
													(call
														StoreCaseValues
														(assoc
															case_values_map (map
																	(lambda
																		(exp
																			(-
																				(current_value)
																			)
																		)
																	)
																	entropies_map
																)
															label_name p_value_of_addition
														)
													)
												)
												(if
													familiarity_conviction_addition
													(let
														(assoc
															avg_entropy (/
																	(apply
																		"+"
																		(values
																			entropies_map
																		)
																	)
																	(size
																		entropies_map
																	)
																)
														)
														(assign_to_entities
															(assoc
																storedConvictionsFeatureSet (sort
																		features
																	)
																storedCaseConvictionsFeatureAddition familiarity_conviction_addition
															)
														)

														;store the conviction for the cases into the specified label name
														(call
															StoreCaseValues
															(assoc
																case_values_map
																	;store convictions into entropies_map by dividing avg_entropy by each individual entropy
																	(if
																		(=
																			0
																			avg_entropy
																		)
																		(map
																			(lambda
																				1
																			)
																			entropies_map
																		)
																		(map
																			(lambda
																				(/
																					avg_entropy
																					(current_value)
																				)
																			)
																			entropies_map
																		)
																	)
																label_name familiarity_conviction_addition
															)
														)
													)
												)
											)
										)
										(if
											(or familiarity_conviction_removal p_value_of_removal)

											;calculates the conviction for each case, making a map of case id -> conviction
											(let
												(assoc
													entropies_map (compute_on_contained_entities
															(list
																||(compute_entity_kl_divergences
																	closest_k
																	features
																	case_ids
																	feature_weights
																	nominalClassCountsMap
																	cyclicFeaturesMap
																	feature_deviations
																	(get
																		hyperparam_map
																		"p"
																	)
																	(get
																		hyperparam_map
																		"dwe"
																	)
																	(if
																		valid_weight_feature
																		weight_feature
																		(null)
																	)

																	;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																	"fixed rand seed"
																	(null)

																	;radius
																	lpSpaceHeuristicMultiplier
																	high_distance_accuracy
																	(true)
																)
															)
														)
												)
												(if
													p_value_of_removal
													(call
														StoreCaseValues
														(assoc
															case_values_map (map
																	(lambda
																		(exp
																			(-
																				(current_value)
																			)
																		)
																	)
																	entropies_map
																)
															label_name p_value_of_removal
														)
													)
												)
												(if
													familiarity_conviction_removal
													(let
														(assoc
															avg_entropy (/
																	(apply
																		"+"
																		(values
																			entropies_map
																		)
																	)
																	(size
																		entropies_map
																	)
																)
														)
														(call
															StoreCaseValues
															(assoc
																case_values_map
																	;store convictions into entropies_map by dividing avg_entropy by each individual entropy
																	(if
																		(=
																			0
																			avg_entropy
																		)
																		(map
																			(lambda
																				1
																			)
																			entropies_map
																		)
																		(map
																			(lambda
																				(/
																					avg_entropy
																					(current_value)
																				)
																			)
																			entropies_map
																		)
																	)
																label_name familiarity_conviction_removal
															)
														)
													)
												)
											)
										)
										(if
											distance_contribution
											(let
												(assoc
													case_to_dc_map (compute_on_contained_entities
															(list
																||(compute_entity_distance_contributions
																	closest_k
																	features
																	case_ids
																	feature_weights
																	nominalClassCountsMap
																	cyclicFeaturesMap
																	feature_deviations
																	(get
																		hyperparam_map
																		"p"
																	)
																	(get
																		hyperparam_map
																		"dwe"
																	)
																	(if
																		valid_weight_feature
																		weight_feature
																		(null)
																	)

																	;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																	"fixed rand seed"
																	(null)

																	;radius
																	lpSpaceHeuristicMultiplier
																	high_distance_accuracy
																)
															)
														)
												)
												(call
													StoreCaseValues
													(assoc
														case_values_map case_to_dc_map
														label_name distance_contribution
													)
												)
											)
										)
										(accum_to_entities
											(assoc revision 1)
										)
										(true)
									)

									;Used by Impute to compute the familiarity conviction of addition for a given case in the model
									; features: list of features
									; case_id : the entity id of the case we want conviction for
									##ComputeCaseAdditionFamiliarityConviction
									(declare
										(assoc
											case_id (null)
											features (list)
										)

										;if the model is too small, just return 0, otherwise compute conviction
										(if
											(<=
												(call GetNumTrainingCases)
												2
											)
											(conclude 0)
										)

										;if convictions have already been calculated and stored for this feature set, just retrieve them
										(if
											(and
												(!=
													(null)
													storedCaseConvictionsFeatureAddition
												)
												(=
													storedConvictionsFeatureSet
													(sort
														features
													)
												)
											)
											(conclude
												(retrieve_from_entity
													case_id
													storedCaseConvictionsFeatureAddition
												)
											)
										)

										;calculate and store them and then retrieve the value for this case
										(call
											ReactIntoFeatures
											(assoc
												features features
												familiarity_conviction_addition (true)
											)
										)
										(retrieve_from_entity case_id storedCaseConvictionsFeatureAddition)
									)

									;Helper method to compute and cache average case entropy of addition for the model
									##CacheAverageModelCaseEntropyAddition
									(let
										(assoc
											entropies_map (compute_on_contained_entities
													(list
														||(compute_entity_kl_divergences
															closest_k
															features
															(null)
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															feature_deviations
															(get
																hyperparam_map
																"p"
															)
															(get
																hyperparam_map
																"dwe"
															)
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															high_distance_accuracy
														)
													)
												)
										)
										(assign_to_entities
											(assoc
												averageModelCaseEntropyAddition (/
														(apply
															"+"
															(values
																entropies_map
															)
														)
														(size
															entropies_map
														)
													)
											)
										)
									)

									;Helper method to compute and cache average case entropy of removal for the model
									##CacheAverageModelCaseEntropyRemoval
									(let
										(assoc
											entropies_map (compute_on_contained_entities
													(list
														||(compute_entity_kl_divergences
															closest_k
															features
															(null)
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															feature_deviations
															(get
																hyperparam_map
																"p"
															)
															(get
																hyperparam_map
																"dwe"
															)
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															high_distance_accuracy
															(true)
														)
													)
												)
										)
										(assign_to_entities
											(assoc
												averageModelCaseEntropyRemoval (/
														(apply
															"+"
															(values
																entropies_map
															)
														)
														(size
															entropies_map
														)
													)
											)
										)
									)

									;Helper method to compute and cache average case distance contribution for the model
									##CacheAverageModelCaseDistanceContribution
									(let
										(assoc
											base_model_distance_contributions_map (compute_on_contained_entities
													(list
														||(compute_entity_distance_contributions
															closest_k
															features
															(null)
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															feature_deviations
															(get
																hyperparam_map
																"p"
															)
															(get
																hyperparam_map
																"dwe"
															)
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															high_distance_accuracy
														)
													)
												)
										)
										(assign_to_entities
											(assoc
												averageModelCaseDistanceContribution (/
														(apply
															"+"
															(values
																base_model_distance_contributions_map
															)
														)
														(size
															base_model_distance_contributions_map
														)
													)
											)
										)
									)

									;Helper method to compute model avg distance contribution and new cases' avg distance contribution
									##ComputeNewCasesDistanceContributions
									(let
										(assoc
											combined_model_distance_contributions_map (compute_on_contained_entities
													(list
														||(compute_entity_distance_contributions
															closest_k
															features
															(null)
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															feature_deviations
															(get
																hyperparam_map
																"p"
															)
															(get
																hyperparam_map
																"dwe"
															)
															(if
																valid_weight_feature
																weight_feature
																(null)
															)

															;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
															"fixed rand seed"
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															high_distance_accuracy
														)
													)
												)
										)
										(assign
											(assoc
												avg_new_cases_distance_contribution (/
														(apply
															"+"
															(unzip
																combined_model_distance_contributions_map
																new_case_ids
															)
														)
														(size
															new_case_ids
														)
													)
												combined_model_average_distance_contributions (/
														(apply
															"+"
															(values
																combined_model_distance_contributions_map
															)
														)
														(size
															combined_model_distance_contributions_map
														)
													)
											)
										)
									)

									;Helper method to compute model avg new cases familarity convction of addition and p value of addition
									##ComputeNewCasesFamiliarityConvictionAddition
									(seq

										;compute entropies of the new cases
										(assign
											(assoc
												new_case_entropies_value (compute_on_contained_entities
														(list
															||(compute_entity_group_kl_divergence
																closest_k
																features
																new_case_ids
																feature_weights
																nominalClassCountsMap
																cyclicFeaturesMap
																feature_deviations
																(get
																	hyperparam_map
																	"p"
																)
																(get
																	hyperparam_map
																	"dwe"
																)
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)

																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																high_distance_accuracy
															)
														)
													)
											)
										)
										(assign
											(assoc
												average_new_cases_conviction_addition (if
														familiarity_conviction_addition

														;if the average entropy is 0, that means all cases have entropy of 0, thus return 1 for conviction
														(if
															(=
																0
																averageModelCaseEntropyAddition
															)
															1

															;return conviction by taking the average case entropy dividing be the average new case entropy
															(/
																averageModelCaseEntropyAddition
																(/
																	new_case_entropies_value
																	(size
																		new_case_ids
																	)
																)
															)
														)
													)
												p_value_of_addition_value (if
														p_value_of_addition
														(exp
															(-
																(/
																	new_case_entropies_value
																	(size
																		new_case_ids
																	)
																)
															)
														)
													)
											)
										)
									)

									;Helper method to compute model avg new cases familarity convction of removal and p value of removal
									##ComputeNewCasesFamiliarityConvictionRemoval
									(seq

										;compute entropies of the new cases
										(assign
											(assoc
												new_case_entropies_value (compute_on_contained_entities
														(list
															||(compute_entity_group_kl_divergence
																closest_k
																features
																new_case_ids
																feature_weights
																nominalClassCountsMap
																cyclicFeaturesMap
																feature_deviations
																(get
																	hyperparam_map
																	"p"
																)
																(get
																	hyperparam_map
																	"dwe"
																)
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)

																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																high_distance_accuracy
																(true)
															)
														)
													)
											)
										)
										(assign
											(assoc
												p_value_of_removal_value (if
														p_value_of_removal
														(exp
															(-
																(/
																	new_case_entropies_value
																	(size
																		new_case_ids
																	)
																)
															)
														)
													)
												average_new_cases_conviction_removal (if
														familiarity_conviction_removal

														;if the average entropy is 0, that means all cases have entropy of 0, thus return 1 for conviction
														(if
															(=
																0
																averageModelCaseEntropyRemoval
															)
															1

															;return conviction by taking the average case entropy dividing be the average new case entropy
															(/
																averageModelCaseEntropyRemoval
																(/
																	new_case_entropies_value
																	(size
																		new_case_ids
																	)
																)
															)
														)
													)
											)
										)
									)

									;computes and returns an assoc where each key is an entity and each value is the expected probability that
									; a randomly chosen new point affects expected distances in a multi-spanning tree would affect each point's distance contribution
									;parameters:
									; features: list of features
									; entities: list of entity ids
									##CalculateAllClosestCaseProbabilities
									(let
										(assoc
											entity_dist_contribution_map (assoc)
											total_distances 0
											nearest_entity_probabilities (assoc)
										)

										;calculate distance contribution from every neighbor
										(assign
											(assoc
												entity_dist_contribution_map (compute_on_contained_entities
														(list
															||(compute_entity_distance_contributions
																(get
																	hyperparam_map
																	"k"
																)
																features
																entities

																;if null, will compute on full model
																(get
																	hyperparam_map
																	"featureWeights"
																)
																nominalClassCountsMap
																cyclicFeaturesMap
																(if
																	(get
																		hyperparam_map
																		"useDeviations"
																	)
																	(get
																		hyperparam_map
																		"featureDeviations"
																	)
																)
																(get
																	hyperparam_map
																	"p"
																)
																(get
																	hyperparam_map
																	"dwe"
																)
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)

																;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																"fixed rand seed"
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																high_distance_accuracy
															)
														)
													)
											)
										)

										;compute total distance
										(assign
											(assoc
												total_distance (apply
														"+"
														(values
															entity_dist_contribution_map
														)
													)
											)
										)

										;convert the distance contributions to probabilities by dividing each one by the total distance
										(map
											(lambda
												(/
													(current_value)
													total_distance
												)
											)
											entity_dist_contribution_map
										)
									)

									;computes the conviction for each feature and returns an assoc of feature -> conviction value
									;parameters:
									; features: list of label names
									; action_features: optional, list of action features to use as the baseline for conviction instead of the full model
									; case_ids: optional list of cases for which to use as the model to compute feature conviction
									; familiarity_conviction_addition: deafult to true, calculate and output familiarity conviction of adding the specified features
									; familiarity_conviction_removal: default to false, calculate and output familiarity conviction of removing the specified features
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; high_distance_accuracy: optional, flag, defaults to true. if set to false, will use low accuracy when computing distances.
									##ComputeFeatureFamiliarityConviction
									(declare
										(assoc
											weight_feature ".case_weight"
											features (list)
											familiarity_conviction_removal (false)
											case_ids (list)
											use_case_weights (false)
											action_features (list)
											high_distance_accuracy (true)
											familiarity_conviction_addition (true)
										)

										;if features aren't specified, assume all defaultFeatures will need to have their mae calculated
										(if
											(=
												0
												(size features)
											)
											(assign
												(assoc
													features defaultFeatures
												)
											)
										)
										(declare
											(assoc
												valid_weight_feature (false)
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature ".none"
															feature ".targetless"
															mode "robust"
														)
													)
											)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)

											;else using case weights, weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
											(assign
												(assoc
													valid_weight_feature (or
															hasPopulatedCaseWeight
															(!=
																weight_feature
																".case_weight"
															)
														)
												)
											)
										)

										;can't compute feature conviction on 1 feature, return 0 if one or no features are specified
										(if
											(<
												(size features)
												2
											)

											;output a map of feature -> value where the value is 0 for all features
											(map
												(lambda 0)
												(zip features)
											)
											(let
												(assoc
													feature_entropies (unzip
															(call
																ComputeEntropyOfFeatures
																(assoc
																	features features
																	case_ids case_ids
																	action_features action_features
																)
															)
															features
														)
												)

												;output assoc with 'familiarity_conviction_addition' and/or 'familiarity_conviction_removal'
												(append
													(if
														familiarity_conviction_addition
														(assoc
															familiarity_conviction_addition (let
																	(assoc
																		avg_feature_entropy 0
																		addition_entropies (map
																				(lambda
																					(first
																						(current_value)
																					)
																				)
																				feature_entropies
																			)
																	)
																	(assign
																		(assoc
																			avg_feature_entropy (/
																					(apply
																						"+"
																						addition_entropies
																					)
																					(size
																						feature_entropies
																					)
																				)
																		)
																	)

																	;output assoc of conviction of each feature as : average feature entropy / feature entropy
																	(map
																		(lambda

																			;if the average entropy is 0, that means all entropies are 0, thus return 1 for conviction
																			(if
																				(=
																					0
																					avg_feature_entropy
																				)
																				1
																				(/
																					avg_feature_entropy
																					(current_value)
																				)
																			)
																		)
																		(zip
																			features
																			addition_entropies
																		)
																	)
																)
														)
														(assoc)
													)
													(if
														familiarity_conviction_removal
														(assoc
															familiarity_conviction_removal (let
																	(assoc
																		avg_feature_entropy 0
																		removal_entropies (map
																				(lambda
																					(last
																						(current_value)
																					)
																				)
																				feature_entropies
																			)
																	)
																	(assign
																		(assoc
																			avg_feature_entropy (/
																					(apply
																						"+"
																						removal_entropies
																					)
																					(size
																						feature_entropies
																					)
																				)
																		)
																	)

																	;output assoc of conviction of each feature as : average feature entropy / feature entropy
																	(map
																		(lambda

																			;if the average entropy is 0, that means all entropies are 0, thus return 1 for conviction
																			(if
																				(=
																					0
																					avg_feature_entropy
																				)
																				1
																				(/
																					avg_feature_entropy
																					(current_value)
																				)
																			)
																		)
																		(zip
																			features
																			removal_entropies
																		)
																	)
																)
														)
														(assoc)
													)
												)
											)
										)
									)

									;computes the entropy of each feature given a list of features and their weights for the current model
									;returns an assoc of feature -> entropy
									; features: list of all features
									; action_features: optional, list of action features to use as the baseline for conviction instead of the full model
									; cases: optional list of cases for which to use as the model to compute feature conviction
									##ComputeEntropyOfFeatures
									(declare
										(assoc
											features (list)
											case_ids (list)
											action_features (list)
										)
										(if
											(>
												(call GetNumTrainingCases)
												2
											)
											(let
												(assoc
													entities (if
															(>
																(size
																	case_ids
																)
																0
															)
															case_ids

															;else compute on all the existing cases
															(null)
														)
													full_model_entity_probabilities (assoc)
													prior_nearest_entity_probabilities (assoc)
												)

												;compute probabilities for trainee with all contexts
												(assign
													(assoc
														full_model_entity_probabilities (call
																CalculateAllClosestCaseProbabilities
																(assoc
																	entities entities
																	features (if
																			(=
																				0
																				(size
																					action_features
																				)
																			)
																			features
																			action_features
																		)
																)
															)
													)
												)

												;use knockout one feature at a time, unless action features then compute it between each feature and the action features
												;return an assoc of features -> entropy using one by one knockout/filtering of features
												(zip
													features

													;for every feature, store the index and filter out the features by that index
													;then calculate the probabilities for all the entities given the filtered list of features
													(map
														(lambda
															(let
																(assoc
																	ct_index (get_value
																			(current_index
																				1
																			)
																		)
																)
																(if
																	(>
																		(size
																			action_features
																		)
																		0
																	)
																	(assign
																		(assoc
																			filtered_features (list
																					(current_value
																						2
																					)
																				)
																		)
																	)

																	;else filter out the one feature from the list and its corresponding weight
																	(assign
																		(assoc
																			filtered_features (filter
																					(lambda
																						(!=
																							(current_index)
																							ct_index
																						)
																					)
																					features
																				)
																		)
																	)
																)

																;probabilities of entities for the filtered list
																(assign
																	(assoc
																		prior_nearest_entity_probabilities (call
																				CalculateAllClosestCaseProbabilities
																				(assoc
																					entities entities
																					features filtered_features
																				)
																			)
																	)
																)
																(list

																	;output the kl divergence for each feature as addition
																	(entropy

																		;prior data with model with specific feature subset
																		prior_nearest_entity_probabilities

																		;full model
																		full_model_entity_probabilities
																	)

																	;output the kl divergence for each feature as removal
																	(entropy

																		;prior data of full model
																		full_model_entity_probabilities

																		;posterior data with model with specific feature subset
																		prior_nearest_entity_probabilities
																	)
																)
															)
														)
														features
													)
												)
											)

											;else model is too small, return 0 for each feature
											(zip
												features
												(map
													(lambda
														(list
															0
															0
														)
													)
													(range
														1
														(size
															features
														)
													)
												)
											)
										)
									)

									;compute and output an assoc of feature -> contribution value based on accuracy conviction, where 0 means the feature does not contribute
									;anything to accuracy, positive values means feature improves/contributes to accuracy, and negative values means feature hinders accuracy
									##ComputeFeaturePredictionConviction
									(declare
										(assoc
											weight_feature ".case_weight"
											features (list)
											case_ids (list)
											use_case_weights (false)
											action_features (list)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)
										)

										;if features aren't specified, assume all defaultFeatures will need to have their mae calculated
										(if
											(=
												0
												(size features)
											)
											(assign
												(assoc
													features defaultFeatures
												)
											)
										)

										;can only do feature prediction conviction if there are at least 3 unique features: 1 is knocked out, and you need both a context and
										;an action feature to compare
										(declare
											(assoc
												total_unique_features (size
														(indices
															(zip
																(append
																	features
																	action_features
																)
															)
														)
													)
											)
										)
										(if
											(< total_unique_features 3)
											(assoc
												prediction_contribution (null)
												prediction_conviction (null)
											)
											(seq
												(if
													(=
														0
														(size
															action_features
														)
													)
													(assign
														(assoc
															action_features (null)
														)
													)
												)

												;get the smallest theoretical residual vector magnitude for the model in case this is for on a regional model that has a 0 RVM from
												;perfect accuracy, this will be used instead of that 0
												(declare
													(assoc
														smallest_theoretical_residual_vector_magnitude (if
																(!=
																	(null)
																	action_features
																)
																(get
																	minTargetedResidualMagnitudeMap
																	(apply
																		"concat"
																		(sort
																			(append
																				features
																				action_features
																				action_features
																			)
																		)
																	)
																)
																(get
																	minTargetedResidualMagnitudeMap
																	(apply
																		"concat"
																		(sort
																			features
																		)
																	)
																)
															)
													)
												)
												(assign
													(assoc
														smallest_theoretical_residual_vector_magnitude (if
																(!=
																	(null)
																	smallest_theoretical_residual_vector_magnitude
																)
																smallest_theoretical_residual_vector_magnitude
																0
															)
													)
												)
												(declare
													(assoc
														has_infinity_values (false)
														model_accuracy_entropy (call
																ComputeModelPredictionEntropy
																(assoc
																	smallest_theoretical_residual_vector_magnitude smallest_theoretical_residual_vector_magnitude
																	weight_feature weight_feature
																	features features
																	case_ids case_ids
																	use_case_weights use_case_weights
																	action_features action_features
																)
															)
													)
												)

												;use knockout one feature at a time, unless action features then compute it between each feature and the action features
												;return an assoc of features -> contribution value using one by one knockout/filtering of features
												(declare
													(assoc
														feature_entropies_map (zip
																features

																;for every feature, store the index and filter out the feature by that index
																;then calculate the probabilities for all the entities given the filtered list of features
																(map
																	(lambda
																		(let
																			(assoc
																				ct_index (get_value
																						(current_index
																							1
																						)
																					)
																			)

																			;else filter out the one feature from the list and its corresponding weight
																			(declare
																				(assoc
																					filtered_features (filter
																							(lambda
																								(!=
																									(current_index)
																									ct_index
																								)
																							)
																							features
																						)
																				)
																			)
																			(declare
																				(assoc
																					feature_accuracy_entropy (call
																							ComputeModelPredictionEntropy
																							(assoc
																								smallest_theoretical_residual_vector_magnitude smallest_theoretical_residual_vector_magnitude
																								weight_feature weight_feature
																								features filtered_features
																								case_ids case_ids
																								use_case_weights use_case_weights
																								action_features action_features
																							)
																						)
																				)
																			)
																			(if
																				(=
																					.infinity
																					feature_accuracy_entropy
																				)
																				(assign
																					(assoc
																						has_infinity_values (true)
																					)
																				)
																			)
																			feature_accuracy_entropy
																		)
																	)
																	features
																)
															)
													)
												)

												;compute average feature accuracy entropy: note: can't use this if one of the features has infinity as a value
												(declare
													(assoc
														avg_feature_accuracy_entropy (/
																(apply
																	"+"
																	(map

																		;entropy value is the sum of distance contribution entropy and residual value entropy
																		(lambda
																			(+
																				(first
																					(current_value)
																				)
																				(last
																					(current_value)
																				)
																			)
																		)
																		(values
																			feature_entropies_map
																		)
																	)
																)
																(size
																	feature_entropies_map
																)
															)
													)
												)

												;output assoc
												(assoc
													prediction_contribution
														;feature accuracy contribution:
														;a feature contribution value is between 1 and -infinity, 0 means the feature most likely does not affect accuracy
														;negative means the feature hinders accuracy ( because dropping the feature reduced the entropy)
														;if a feature is bad (hinders accuracy), its accuracy entropy increases, making this ratio approach 0 and then go into negatives
														;if a feature is good (improves accuracy), its accuracy entropy decreases, making this ratio approach 1
														(map
															(lambda
																(let
																	(assoc
																		model_entropy (/
																				2
																				(+
																					(/
																						(first
																							(current_value
																								1
																							)
																						)
																						(first
																							model_accuracy_entropy
																						)
																					)
																					(/
																						(last
																							(current_value
																								1
																							)
																						)
																						(last
																							model_accuracy_entropy
																						)
																					)
																				)
																			)
																	)
																	(if

																		;prevent system from outputting nan
																		(=
																			.nan
																			model_entropy
																		)
																		(null)

																		;the info value of the dropped out feature will approach 0 the more accuracy it provides
																		;therefore its contribution can max out at 1
																		(-
																			1
																			model_entropy
																		)
																	)
																)
															)
															feature_entropies_map
														)
													prediction_conviction (map
															(lambda

																;prevent system from outputting nan ( 0/0 or nan/anything causes nan)
																(if
																	(and
																		(=
																			avg_feature_accuracy_entropy
																			0
																		)
																		(=
																			(last
																				(current_value)
																			)
																			0
																		)
																	)
																	(null)
																	(=
																		avg_feature_accuracy_entropy
																		.nan
																	)
																	(null)

																	;since we're doing feature dropout, it's the inverse of E/I because lower I means the feature was bad
																	(/
																		(+
																			(first
																				(current_value)
																			)
																			(last
																				(current_value)
																			)
																		)
																		avg_feature_accuracy_entropy
																	)
																)
															)
															feature_entropies_map
														)
												)
											)
										)
									)

									;computes prediction conviction for a case, outputs both similarity conviction and residual conviction values for a case as a tuple
									;tuple of [ average_distance_contribution, model_residual_similarity_entropy, average_residual_vector_magnitude ]
									;parameters:
									; features: list of features to compute for
									; case_id: optional case entity id for which to compute accuracy conviction, if not specified will use feature_values for the case.
									; feature_values optional case values for which to compute accuracy conviction, if not specified will use the case_id to pull feature values.
									;                if case_id is also specified, these values will be ignored.
									; action_features: optional list of action features for which the residual calculation is based off of
									; return_case_residual_only; optional flag, if set to true will return the case residual vector magnitude
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									##ComputeCasePredictionConviction
									(declare
										(assoc
											feature_values (null)
											weight_feature ".case_weight"
											case_id (null)
											features (list)
											use_case_weights (false)
											action_features (null)
											return_case_residual_only (false)
										)
										(declare
											(assoc
												model_size (call
														GetNumTrainingCases
													)
											)
										)

										;if the model is too small, just return 0, otherwise compute conviction
										(if
											(<= model_size 2)
											0
											(let
												(assoc
													hyperparam_map (if
															(>
																(size
																	action_features
																)
																0
															)
															(call
																GetHyperparameters
																(assoc
																	weight_feature weight_feature
																	feature (last
																			action_features
																		)
																	mode "full"
																)
															)
															(call
																GetHyperparameters
																(assoc
																	weight_feature weight_feature
																	feature ".targetless"
																	mode "robust"
																)
															)
														)
												)
												(declare
													(assoc
														valid_weight_feature (false)
														feature_weights (get
																hyperparam_map
																"featureWeights"
															)
														targeted_accuracy (>
																(size
																	action_features
																)
																0
															)
														accurate_pow (if
																(=
																	2
																	accurateConvictionLevel
																)
																(true)
																(false)
															)
														feature_deviations (if
																(get
																	hyperparam_map
																	"useDeviations"
																)
																(get
																	hyperparam_map
																	"featureDeviations"
																)
															)
													)
												)

												;if user doesn't want to use case weights, change weight_feature to '.none'
												(if
													(not
														use_case_weights
													)
													(assign
														(assoc
															weight_feature ".none"
														)
													)

													;else using case weights, weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
													(assign
														(assoc
															valid_weight_feature (or
																	hasPopulatedCaseWeight
																	(!=
																		weight_feature
																		".case_weight"
																	)
																)
														)
													)
												)
												(if
													(!=
														(null)
														case_id
													)
													(assign
														(assoc
															feature_values (retrieve_from_entity
																	case_id
																	features
																)
														)
													)
												)
												(declare
													(assoc
														case_distance_contribution (if
																(not
																	return_case_residual_only
																)
																(if
																	(!=
																		(null)
																		case_id
																	)
																	(get
																		(compute_on_contained_entities
																			(list
																				(compute_entity_distance_contributions
																					(get
																						hyperparam_map
																						"k"
																					)
																					features
																					(list
																						case_id
																					)
																					feature_weights
																					nominalClassCountsMap
																					cyclicFeaturesMap
																					feature_deviations
																					(get
																						hyperparam_map
																						"p"
																					)
																					(get
																						hyperparam_map
																						"dwe"
																					)
																					(if
																						valid_weight_feature
																						weight_feature
																						(null)
																					)

																					;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																					"fixed rand seed"
																					(null)

																					;radius label
																					lpSpaceHeuristicMultiplier
																					accurate_pow
																				)
																			)
																		)
																		case_id
																	)

																	;else compute distance contribution of feature values only
																	(call
																		ComputeCandidateCaseDistanceContribution
																		(assoc
																			model_size model_size
																			feature_values feature_values
																			p_parameter (get
																					hyperparam_map
																					"p"
																				)
																			feature_weights feature_weights
																			weight_feature weight_feature
																			accurate_pow accurate_pow
																			features features
																			use_case_weights valid_weight_feature
																			query_closest_k (get
																					hyperparam_map
																					"k"
																				)
																			dwe_parameter (get
																					hyperparam_map
																					"dwe"
																				)
																			feature_deviations featureDeviations
																		)
																	)
																)
															)
													)
												)
												(declare
													(assoc
														local_model_cases_map (compute_on_contained_entities
																(list
																	(query_nearest_generalized_distance

																		;if case_id is specified, add one to closest k so that match can be ignored from the result
																		(if
																			(=
																				(null)
																				case_id
																			)
																			(get
																				hyperparam_map
																				"k"
																			)
																			(+
																				1
																				(get
																					hyperparam_map
																					"k"
																				)
																			)
																		)
																		features
																		feature_values
																		feature_weights
																		nominalClassCountsMap
																		cyclicFeaturesMap
																		feature_deviations
																		(get
																			hyperparam_map
																			"p"
																		)
																		(get
																			hyperparam_map
																			"dwe"
																		)
																		(if
																			valid_weight_feature
																			weight_feature
																			(null)
																		)
																		(rand)
																		(null)

																		;radius
																		lpSpaceHeuristicMultiplier
																		(true)
																	)
																)
															)
													)
												)
												(declare
													(assoc
														case_residual_vector_map (call
																CalculateFeatureResiduals
																(assoc
																	focal_case case_id
																	residual_features action_features
																	weight_feature weight_feature
																	features features
																	use_case_weights use_case_weights
																	cases_map local_model_cases_map
																)
															)
													)
												)
												(declare
													(assoc
														case_residual_values (unzip
																case_residual_vector_map
																features
															)
													)
												)
												(if
													targeted_accuracy
													(assign
														(assoc
															case_residual_values (unzip
																	case_residual_vector_map
																	action_features
																)
															feature_deviations (if
																	(get
																		hyperparam_map
																		"useDeviations"
																	)
																	(unzip
																		(get
																			hyperparam_map
																			"featureDeviations"
																		)
																		action_features
																	)

																	;else
																	(null)
																)
														)
													)
												)
												(declare
													(assoc
														case_residual_vector_magnitude (generalized_distance

																;weights are null for all action features
																(null)

																;feature_nominal_counts are null because the magnitude may be a fraction due to
																;utilization of categorical action probabilities instead of a 1 or 0 for nominals
																(null)
																cyclicFeaturesMap
																feature_deviations
																(get
																	hyperparam_map
																	"p"
																)
																case_residual_values
																(null)

																;null point
																(null)
																(if
																	targeted_accuracy
																	action_features
																	features
																)
															)
														smallest_residual_magnitude
															;if we're using targeted predictions, those are cached by keys of concatenation of sorted features and action features
															(if
																targeted_accuracy
																(get
																	minTargetedResidualMagnitudeMap
																	(apply
																		"concat"
																		(sort
																			(append
																				features
																				action_features
																			)
																		)
																	)
																)

																;else
																(get
																	minResidualMagnitudeMap
																	(apply
																		"concat"
																		(sort
																			features
																		)
																	)
																)
															)
														prediction_conviction_tuple (null)
													)
												)

												;if there is no smallest residual magnitude, compute the model prediction entropy to calculate the smallest possible residual
												(if
													(=
														(null)
														smallest_residual_magnitude
													)
													(seq
														(assign
															(assoc
																prediction_conviction_tuple (call
																		ComputeModelPredictionEntropy
																		(assoc
																			weight_feature weight_feature
																			features features
																			compute_smallest_residual_only return_case_residual_only
																			use_case_weights use_case_weights
																			action_features action_features
																		)
																	)
															)
														)
														(assign
															(assoc
																smallest_residual_magnitude (if
																		targeted_accuracy
																		(get
																			minTargetedResidualMagnitudeMap
																			(apply
																				"concat"
																				(sort
																					(append
																						features
																						action_features
																					)
																				)
																			)
																		)

																		;else
																		(get
																			minResidualMagnitudeMap
																			(apply
																				"concat"
																				(sort
																					features
																				)
																			)
																		)
																	)
															)
														)
													)
												)

												;if the residual vector magnitude for this case is smaller than the smallest possible,
												;replace it with the stored smallest residual magnitude from the model
												(if
													(<
														case_residual_vector_magnitude
														smallest_residual_magnitude
													)
													(assign
														(assoc
															case_residual_vector_magnitude smallest_residual_magnitude
														)
													)
												)
												(if
													return_case_residual_only

													;output just the case accuracy entropy value
													case_residual_vector_magnitude

													;else return the case accuracy conviction
													(seq
														(if
															(=
																(null)
																prediction_conviction_tuple
															)
															(assign
																(assoc
																	prediction_conviction_tuple (call
																			ComputeModelPredictionEntropy
																			(assoc
																				weight_feature weight_feature
																				use_case_weights use_case_weights
																				features features
																				action_features action_features
																			)
																		)
																)
															)
														)
														(declare
															(assoc
																expected_residual_value (last
																		prediction_conviction_tuple
																	)
																case_dissimilarity_info_value (/
																		case_distance_contribution
																		case_residual_vector_magnitude
																	)
																expected_dissimilarity_info_value (get
																		prediction_conviction_tuple
																		1
																	)
															)
														)

														;convictions are a ratio of: specific case info / average case info (whether it's residuals or distance contributions)
														(declare
															(assoc
																similarity_conviction (/
																		case_distance_contribution
																		(first
																			prediction_conviction_tuple
																		)
																	)
																residual_dissimilarity_conviction (if
																		(=
																			expected_dissimilarity_info_value
																			case_dissimilarity_info_value
																		)

																		;Defining limits of 0 and infinity to be the same value, leaving a conviction of 1, the expected value.
																		1
																		(/
																			(get
																				prediction_conviction_tuple
																				1
																			)
																			(/
																				case_distance_contribution
																				case_residual_vector_magnitude
																			)
																		)
																	)
																residual_conviction (if
																		(=
																			expected_residual_value
																			case_residual_vector_magnitude
																		)

																		;Defining limits of 0 and infinity to be the same value, leaving a conviction of 1, the expected value.
																		1
																		(/
																			case_residual_vector_magnitude
																			(last
																				prediction_conviction_tuple
																			)
																		)
																	)
															)
														)

														;output a tuple
														(list
															similarity_conviction
															residual_dissimilarity_conviction
															residual_conviction
														)
													)
												)
											)
										)
									)

									;compute the model accuracy entropy value for a specific feature set. returns the value and caches it so it can be used to compute case
									;accuracy conviction and feature contributions
									;parameters:
									; features: list of features to compute for
									; action_features: optional list of action features for which the residual calculation is based off of
									; force_recompute: optional flag, if set to true will recompute the entropy value and store the recomputed value
									; case_ids: optional list of cases for which to use as the model to compute feature conviction
									; smallest_theoretical_residual_vector_magnitude : if specified, will be used if the model calculated residual vector magnitude is 0
									; compute_smallest_residual_only : optional flag, if set to true, will only compute and cache the smallest residual for the specified features
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									##ComputeModelPredictionEntropy
									(declare
										(assoc
											force_recompute (false)
											smallest_theoretical_residual_vector_magnitude 0
											weight_feature ".case_weight"
											features (list)
											case_ids (list)
											compute_smallest_residual_only (false)
											use_case_weights (false)
											action_features (null)
										)
										(declare
											(assoc
												model_size (call
														GetNumTrainingCases
													)
												targeted_accuracy (>
														(size
															action_features
														)
														0
													)
											)
										)

										;if the model is too small, just return 0, otherwise compute conviction
										(if
											(<= model_size 2)
											0
											(let

												;if case ids are specified, do not cache and do retrieve entropies from cache, just compute it for the specified cases
												(assoc
													model_accuracy_entropy (if
															(>
																(size
																	case_ids
																)
																0
															)
															(null)

															;else attempt to pull the model accuracy entropy value from cache if it has already been calculated
															;values are stored using the full feature list (appended features and action_features if applicable) as the key
															;in the assoc, allowing caching of individual values per unique feature set
															(if
																targeted_accuracy
																(get
																	modelTargetedAccuracyEntropyMap
																	(apply
																		"concat"
																		(sort
																			(append
																				features
																				action_features
																			)
																		)
																	)
																)
																(get
																	modelAccuracyEntropyMap
																	(apply
																		"concat"
																		(sort
																			features
																		)
																	)
																)
															)
														)
												)

												;if user doesn't want to use case weights, change weight_feature to '.none'
												(if
													(not
														use_case_weights
													)
													(assign
														(assoc
															weight_feature ".none"
														)
													)
												)

												;if the value is already stored, and we don't need to recompute it, return it, otherwise recompute
												(if
													(and
														(!=
															(null)
															model_accuracy_entropy
														)
														(not
															force_recompute
														)
													)
													model_accuracy_entropy

													;recalculate the model info value if it isn't stored yet for this feature set
													(let
														(assoc
															hyperparam_map (if
																	(>
																		(size
																			action_features
																		)
																		0
																	)
																	(call
																		GetHyperparameters
																		(assoc
																			weight_feature weight_feature
																			feature (last
																					action_features
																				)
																			mode "full"
																		)
																	)
																	(call
																		GetHyperparameters
																		(assoc
																			weight_feature weight_feature
																			feature ".targetless"
																			mode "robust"
																		)
																	)
																)
														)
														(declare
															(assoc
																valid_weight_feature (false)
																accurate_pow (if
																		(=
																			2
																			accurateConvictionLevel
																		)
																		(true)
																		(false)
																	)
																cases (if
																		(>
																			(size
																				case_ids
																			)
																			0
																		)
																		case_ids

																		;TODO: story 2798 to improve how sample is acquired
																		(call
																			AllCases
																			(assoc
																				num (max
																						1000
																						(*
																							0.25
																							model_size
																						)
																					)
																				rand_seed (rand)
																			)
																		)
																	)
																feature_deviations (if
																		(get
																			hyperparam_map
																			"useDeviations"
																		)
																		(get
																			hyperparam_map
																			"featureDeviations"
																		)
																	)
															)
														)

														;if using case weights, weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
														(if
															use_case_weights
															(assign
																(assoc
																	valid_weight_feature (or
																			hasPopulatedCaseWeight
																			(!=
																				weight_feature
																				".case_weight"
																			)
																		)
																)
															)
														)
														(declare
															(assoc
																smallest_vector_magnitude_found .infinity
																smallest_residual_magnitude 0
																has_zero_residual (false)
																model_distance_contributions_map (if
																		(not
																			compute_smallest_residual_only
																		)
																		(compute_on_contained_entities
																			(list
																				||(compute_entity_distance_contributions
																					(get
																						hyperparam_map
																						"k"
																					)
																					features
																					cases
																					(get
																						hyperparam_map
																						"featureWeights"
																					)
																					nominalClassCountsMap
																					cyclicFeaturesMap
																					feature_deviations
																					(get
																						hyperparam_map
																						"p"
																					)
																					(get
																						hyperparam_map
																						"dwe"
																					)
																					(if
																						valid_weight_feature
																						weight_feature
																						(null)
																					)

																					;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
																					"fixed rand seed"
																					(null)

																					;radius label
																					lpSpaceHeuristicMultiplier
																					accurate_pow
																				)
																			)
																		)
																	)
															)
														)

														;prevent infinite recursion when only computing smallest residual by computing the smallest theoretical one below
														(if
															(not
																compute_smallest_residual_only
															)
															(declare
																(assoc
																	model_residual_vectors (map
																			(lambda
																				(let
																					(assoc
																						residual (call
																								ComputeCasePredictionConviction
																								(assoc
																									feature_values (null)
																									weight_feature weight_feature
																									case_id (current_value
																											2
																										)
																									features features
																									use_case_weights use_case_weights
																									action_features action_features
																									return_case_residual_only (true)
																								)
																							)
																					)
																					(associate
																						(first
																							action_features
																						)
																						residual
																					)
																				)
																			)
																			cases
																		)
																)
															)
														)
														(if
															targeted_accuracy
															(assign
																(assoc
																	feature_deviations (if
																			(get
																				hyperparam_map
																				"useDeviations"
																			)
																			(unzip
																				(get
																					hyperparam_map
																					"featureDeviations"
																				)
																				action_features
																			)
																		)
																)
															)

															;else set the actions to be the same as all the features for calculating the residual
															(assign
																(assoc
																	action_features features
																)
															)
														)

														;if the smallest_theoretical_residual_vector_magnitude hasn't been specified, calculate it for this whole model
														(if
															(=
																0
																smallest_theoretical_residual_vector_magnitude
															)
															(let
																(assoc
																	action_feature_smallest_residuals
																		;iterate over all the action features and create a list of the smallest theoretical RVM for each feature
																		;by calculating the smallest non-zero gap between feature values, and doing gap * 0.5 * 1 / (num_cases+1)
																		;the +1 is to represent what's the chance of a new unseen case having a smallest gap
																		(map
																			(lambda
																				(let
																					(assoc
																						smallest_gap
																							;gap is always 1 for nominals
																							(if
																								(contains_index
																									nominalsSet
																									(get_value
																										(current_index
																											1
																										)
																									)
																								)
																								1

																								;else compute the gap
																								(compute_on_contained_entities
																									(list
																										(query_min_difference
																											(current_index
																												2
																											)
																											(get
																												cyclicFeaturesMap
																												(current_index
																													2
																												)
																											)
																										)
																									)
																								)
																							)
																					)

																					;if no gap is found, this means all of the values were the same, thus the smallest_gap must be 0
																					(if
																						(=
																							.infinity
																							smallest_gap
																						)
																						(assign
																							(assoc
																								smallest_gap 0
																							)
																						)
																					)

																					;gap * 1/2 * 1 / (num_cases + 1)
																					(/
																						(/
																							smallest_gap
																							2
																						)
																						(+
																							1
																							(size
																								cases
																							)
																						)
																					)
																				)
																			)
																			action_features
																		)
																)

																;if there are several action features, take the generilized norm to calculate the magnitude otherwise
																;just use the value since it's a 1-d vector
																(assign
																	(assoc
																		smallest_theoretical_residual_vector_magnitude (if
																				(>
																					(size
																						action_feature_smallest_residuals
																					)
																					1
																				)
																				(generalized_distance

																					;weights are null for all action features
																					(null)

																					;feature_nominal_counts are null because the magnitude may be a fraction even for nominals
																					(null)
																					cyclicFeaturesMap
																					feature_deviations
																					(get
																						hyperparam_map
																						"p"
																					)
																					action_feature_smallest_residuals
																					(null)
																					(null)
																					action_features
																				)
																				(first
																					action_feature_smallest_residuals
																				)
																			)
																	)
																)
															)
														)
														(declare
															(assoc
																model_residual_vector_magnitudes (map
																		(lambda
																			(let
																				(assoc
																					magnitude (generalized_distance

																							;weights are null for all action features
																							(null)

																							;feature_nominal_counts are null because the magnitude may be a fraction due to
																							;utilization of categorical action probabilities instead of a 1 or 0 for nominals
																							(null)
																							cyclicFeaturesMap
																							feature_deviations
																							(get
																								hyperparam_map
																								"p"
																							)
																							(unzip
																								(current_value
																									1
																								)
																								action_features
																							)
																							(null)
																							(null)
																							action_features
																						)
																					small_magnitude (generalized_distance

																							;weights are null for all action features
																							(null)

																							;feature_nominal_counts are null because the magnitude may be a fraction even for nominals
																							(null)
																							cyclicFeaturesMap
																							feature_deviations
																							(get
																								hyperparam_map
																								"p"
																							)
																							(map
																								(lambda
																									(/
																										(current_value)
																										2
																									)
																								)
																								(unzip
																									(current_value
																										1
																									)
																									action_features
																								)
																							)
																							(null)
																							(null)
																							action_features
																						)
																				)

																				;store the smallest non-zero magnitude
																				(if
																					(and
																						(<
																							small_magnitude
																							smallest_vector_magnitude_found
																						)
																						(>
																							small_magnitude
																							0
																						)
																					)
																					(assign
																						(assoc
																							smallest_vector_magnitude_found small_magnitude
																						)
																					)
																				)
																				(if
																					(<
																						magnitude
																						smallest_theoretical_residual_vector_magnitude
																					)
																					(assign
																						(assoc
																							has_zero_residual (true)
																						)
																					)
																				)
																				magnitude
																			)
																		)
																		model_residual_vectors
																	)
															)
														)

														;use the max of theoretical and actual smallest magnitude vector found, since the actual smallest may be too tiny due to
														;floating point percision, if there isn't an actual one, use just the theoretical smallest instead
														(assign
															(assoc
																smallest_residual_magnitude (if
																		(!=
																			.infinity
																			smallest_vector_magnitude_found
																		)
																		(max
																			smallest_vector_magnitude_found
																			smallest_theoretical_residual_vector_magnitude
																		)

																		;else
																		smallest_theoretical_residual_vector_magnitude
																	)
															)
														)

														;replace all the residual vectors of 0 magnitude with the smallest residual magnitude
														(if
															has_zero_residual
															(assign
																(assoc
																	model_residual_vector_magnitudes (map
																			(lambda
																				(if
																					(<
																						(current_value)
																						smallest_residual_magnitude
																					)
																					smallest_residual_magnitude
																					(current_value)
																				)
																			)
																			model_residual_vector_magnitudes
																		)
																)
															)
														)
														(if
															(not
																compute_smallest_residual_only
															)

															;the model info value is the average of all all the case info values for the model
															(declare
																(assoc
																	average_residual_vector_magnitude (/
																			(apply
																				"+"
																				model_residual_vector_magnitudes
																			)
																			(size
																				model_residual_vector_magnitudes
																			)
																		)
																	model_residual_similarity_entropy (/
																			(apply
																				"+"
																				(map
																					(lambda

																						;case info value: DC / vector_magnitude
																						(/
																							(get
																								model_distance_contributions_map
																								(current_value)
																							)
																							(get
																								model_residual_vector_magnitudes
																								(current_index)
																							)
																						)
																					)
																					cases
																				)
																			)
																			(size
																				cases
																			)
																		)
																	average_distance_contribution (/
																			(apply
																				"+"
																				(values
																					model_distance_contributions_map
																				)
																			)
																			(size
																				cases
																			)
																		)
																)
															)
														)

														;only cache calculated values if calculating for the entire model and not a specified set of cases
														;values are stored using the full feature list (appended features and action_features if applicable) as the key
														;in the assoc, allowing caching of individual values per unique feature set
														(if
															(=
																(size
																	case_ids
																)
																0
															)
															(if
																targeted_accuracy
																(assign_to_entities
																	(assoc
																		modelTargetedAccuracyEntropyMap (if
																				compute_smallest_residual_only

																				;don't overwrite the existing map
																				modelTargetedAccuracyEntropyMap

																				;else append the newly calculated values to it
																				(append
																					modelTargetedAccuracyEntropyMap
																					(associate
																						(apply
																							"concat"
																							(sort
																								(append
																									features
																									action_features
																								)
																							)
																						)
																						(list
																							average_distance_contribution
																							model_residual_similarity_entropy
																							average_residual_vector_magnitude
																						)
																					)
																				)
																			)
																		minTargetedResidualMagnitudeMap (append
																				minTargetedResidualMagnitudeMap
																				(associate
																					(apply
																						"concat"
																						(sort
																							(append
																								features
																								action_features
																							)
																						)
																					)
																					smallest_residual_magnitude
																				)
																			)
																	)
																)
																(assign_to_entities
																	(assoc
																		minResidualMagnitudeMap (append
																				minResidualMagnitudeMap
																				(associate
																					(apply
																						"concat"
																						(sort
																							features
																						)
																					)
																					smallest_residual_magnitude
																				)
																			)
																		modelAccuracyEntropyMap (if
																				compute_smallest_residual_only

																				;don't overwrite the existing map
																				modelAccuracyEntropyMap

																				;else append the newly calculated values to it
																				(append
																					modelAccuracyEntropyMap
																					(associate
																						(apply
																							"concat"
																							(sort
																								features
																							)
																						)
																						(list
																							average_distance_contribution
																							model_residual_similarity_entropy
																							average_residual_vector_magnitude
																						)
																					)
																				)
																			)
																	)
																)
															)
														)

														;output the values
														(list
															average_distance_contribution
															model_residual_similarity_entropy
															average_residual_vector_magnitude
														)
													)
												)
											)
										)
									)

									;compute distance contribution for the specified feature values of a hypothetical candidate case
									;returns the distance contribution value
									;parameters:
									; features: list of features
									; feature_values: list of corresponding feature values
									;   optional hyperparameters for the query may also be passed in and are explicitly listed below in the declare block
									##ComputeCandidateCaseDistanceContribution
									(declare
										(assoc
											model_size (null)
											feature_values (list)
											p_parameter (null)
											feature_weights (null)
											weight_feature ".case_weight"
											accurate_pow (null)
											features (list)
											use_case_weights (false)
											query_closest_k (null)
											dwe_parameter (null)
											feature_deviations (null)
										)

										;if parameters aren't passed in, set them here
										(if
											(= (null) p_parameter)
											(let
												(assoc
													hyperparam_map (call
															GetHyperparameters
															(assoc
																weight_feature weight_feature
																feature ".targetless"
																mode "robust"
															)
														)
												)
												(assign
													(assoc
														model_size (call
																GetNumTrainingCases
															)
														p_parameter (get
																hyperparam_map
																"p"
															)
														feature_weights (get
																hyperparam_map
																"featureWeights"
															)
														accurate_pow (if
																(=
																	2
																	accurateConvictionLevel
																)
																(true)
																(false)
															)
														dwe_parameter (get
																hyperparam_map
																"dwe"
															)
														query_closest_k (get
																hyperparam_map
																"k"
															)
														feature_deviations (if
																(get
																	hyperparam_map
																	"useDeviations"
																)
																(get
																	hyperparam_map
																	"featureDeviations"
																)
															)
													)
												)
											)
										)
										(declare
											(assoc
												done (false)
												harmonic_mean_of_non_zero_neighbors 0
												number_of_closest_k_neighbors query_closest_k
												non_zero_distances 0
												closest_cases_distances_map (assoc)
											)
										)
										(while
											(not done)
											(assign
												(assoc
													closest_cases_distances_map (compute_on_contained_entities
															(list
																(query_nearest_generalized_distance
																	query_closest_k
																	features
																	feature_values
																	feature_weights
																	nominalClassCountsMap
																	cyclicFeaturesMap
																	feature_deviations
																	p_parameter
																	1

																	;DWE is since we just want actual distances
																	(if
																		use_case_weights
																		weight_feature
																		(null)
																	)
																	(rand)
																	(null)

																	;radius
																	lpSpaceHeuristicMultiplier
																	accurate_pow
																)
															)
														)
												)
											)
											(assign
												(assoc
													non_zero_distances (filter
															(lambda
																(!=
																	(current_value)
																	0
																)
															)
															(values
																closest_cases_distances_map
															)
														)
												)
											)
											(if
												(or
													(>
														(size
															non_zero_distances
														)
														0
													)
													(=
														query_closest_k
														model_size
													)
												)
												(assign
													(assoc
														done (true)
													)
												)

												;else double the k and try again, don't go past the model size
												(assign
													(assoc
														query_closest_k (min
																(*
																	2
																	query_closest_k
																)
																model_size
															)
													)
												)
											)
										)

										;query_closest_k is larger than it started if had to expand search, grab only the smallest of the distances
										(if
											(> query_closest_k number_of_closest_k_neighbors)
											(assign
												(assoc
													non_zero_distances (list
															(apply
																"min"
																non_zero_distances
															)
														)
													number_of_closest_k_neighbors (+
															1
															(-
																query_closest_k
																(size
																	non_zero_distances
																)
															)
														)
												)
											)
										)

										;if the distance weight exponent is not the default value of -1, apply the negative value of it to all the distances
										(if
											(!= -1 dwe_parameter)
											(assign
												(assoc
													non_zero_distances (map
															(lambda
																(pow
																	(current_value)
																	(-
																		dwe_parameter
																	)
																)
															)
															non_zero_distances
														)
												)
											)
										)
										(assign
											(assoc
												harmonic_mean_of_non_zero_neighbors (*
														(generalized_distance
															(null)

															;weights
															(null)

															;nominal flags
															(null)

															;cyclic_feature_lengths
															(null)

															;feature_deviations
															-1

															;p parameter
															non_zero_distances
														)
														(size
															non_zero_distances
														)
													)
											)
										)

										;if there are distances for all neighbors, just return the calculated harmonic mean of all the neighbors
										(if
											(=
												(size non_zero_distances)
												number_of_closest_k_neighbors
											)
											harmonic_mean_of_non_zero_neighbors

											;if all the neighbors have zero distance, just return a 0
											(if
												(=
													(size
														non_zero_distances
													)
													0
												)
												0

												;else scale the resulting mean by the closest_k: e.g., if closest_k is 5, and there are only 2 non-zero distances
												;the harmonic mean of those 2 non-zero distances accounts for 2/5s of the total distance contribution
												;therefore we multiply that mean by the ratio of the non_zero_distances / k
												(*
													(/
														(size
															non_zero_distances
														)
														number_of_closest_k_neighbors
													)
													harmonic_mean_of_non_zero_neighbors
												)
											)
										)
									)
								)

								;module for trainee_template
								;contains methods for case generation
								(null

									;returns the closest ordinal value for a specified ordinal feature value,
									;e.g., if an ordinal feature has values of 0,5,10,15  specifying 11.4 would return 10
									;parameters:
									; feature : ordinal feature which to return the value
									; value : the value to snap to the closest ordinal
									##FindClosestOrdinalFeatureValue
									(declare
										(assoc
											feature (null)
											value (null)
											sorted_feature_values (null)
										)

										;if null is ever explicitly passed in, pull the values from cache
										(if
											(= (null) sorted_feature_values)
											(assign
												(assoc
													sorted_feature_values (get
															ordinalFeaturesValuesMap
															feature
														)
												)
											)
										)

										;if they aren't cached yet, store them into the cache
										;Note: this should never run if the model has been optimized and/or all feature values pre-cached properly
										(if
											(= (null) sorted_feature_values)
											(assign
												(assoc
													sorted_feature_values (call
															UpdateOrdinalFeaturesMapForFeature
															(assoc
																feature feature
																store_values (true)
															)
														)
												)
											)
										)

										;if ordinal value is null, output a random non-null value if nulls are not allowed, else output the null
										(if
											(= (null) value)
											(conclude
												(if
													(=
														(false)
														(get
															feature_bounds_map
															(list
																feature
																"allow_null"
															)
														)
													)
													(rand
														(filter
															sorted_feature_values
														)
													)

													;else output the null as-is
													(null)
												)
											)
										)

										;todo: use binary search instead of linear (filter)
										;create a list of only the larger values
										(declare
											(assoc
												larger_feature_values (filter
														(lambda
															(>=
																(current_value)
																value
															)
														)
														sorted_feature_values
													)
											)
										)

										;keep the two values that are closest to the number, which will be either the smallest (first) of the larger values
										;or the larger of all the values, which we know by grabbing the index of where the larger numbers started
										(declare
											(assoc
												larger (if
														(=
															(list)
															larger_feature_values
														)
														(last
															sorted_feature_values
														)
														(first
															larger_feature_values
														)
													)
												smaller (get
														sorted_feature_values
														(-
															(size
																sorted_feature_values
															)
															(size
																larger_feature_values
															)
															1
														)
													)
											)
										)

										;output the closest number
										(if
											(= smaller (null))
											larger
											(= larger (null))
											smaller
											(<
												(abs
													(-
														value
														smaller
													)
												)
												(abs
													(-
														larger
														value
													)
												)
											)
											smaller
											larger
										)
									)

									;given a boundary map for a feature, update the values for cyclic and datetime features
									;outputs a tuple (list) of [boundary_min, boundary_max]
									;
									;parameters:
									; feature : name of feature
									; bounds_map : bounds for the feature
									; is_datetime : flag, set to true if feature is a datetime feature
									; cycle_length : length of cycle if feature is cyclic
									##ConstrainBoundariesForFeature
									(let
										(assoc
											boundary_min (get
													bounds_map
													"min"
												)
											boundary_max (get
													bounds_map
													"max"
												)
										)

										;if this is a datetime feature convert the min and max boundaries from date strings into values for comparison
										(if
											is_datetime

											;if bounds_map has epoch continous values for bounds cached, use those
											(if
												(get
													bounds_map
													"has_epoch_bounds"
												)
												(assign
													(assoc
														boundary_min (get
																bounds_map
																"epoch_min_value"
															)
														boundary_max (get
																bounds_map
																"epoch_max_value"
															)
													)
												)

												;else, convert the given min and max from string date to epoch seconds
												(assign
													(assoc
														boundary_min (if
																(!=
																	(null)
																	boundary_min
																)
																(if
																	(!=
																		"number"
																		(get_type_string
																			boundary_min
																		)
																	)
																	(call
																		ConvertDateToEpoch
																		(assoc
																			date boundary_min
																			feature feature
																		)
																	)

																	;else boundary value was provided in epoch number format already, keep it as-is
																	boundary_min
																)
															)
														boundary_max (if
																(!=
																	(null)
																	boundary_max
																)
																(if
																	(!=
																		"number"
																		(get_type_string
																			boundary_max
																		)
																	)
																	(call
																		ConvertDateToEpoch
																		(assoc
																			date boundary_max
																			feature feature
																		)
																	)

																	;else boundary value was provided in epoch number format already, keep it as-is
																	boundary_max
																)
															)
													)
												)
											)
										)

										;ensure cyclic boundaries are properly specified if cyclic
										(if
											(and
												cycle_length
												(or
													(=
														(null)
														boundary_min
													)
													(=
														(null)
														boundary_max
													)
													(<
														boundary_min
														boundary_max
													)
												)
											)
											(assign
												(assoc
													boundary_min (max
															boundary_min
															0
														)
													boundary_max (or
															boundary_max
															(get
																cyclicFeaturesMap
																feature
															)
														)
												)
											)
										)

										;explicitly convert non-null boundary values to numbers if they were passed in as strings, else leave them as null
										(assign
											(assoc
												boundary_min (if
														(!=
															boundary_min
															(null)
														)
														(+
															boundary_min
														)
													)
												boundary_max (if
														(!=
															boundary_max
															(null)
														)
														(+
															boundary_max
														)
													)
											)
										)
										(list boundary_min boundary_max)
									)

									;generate a new case, returns a list of feature values in the same order as action_features
									;parameters:
									; context_features: optional, list of features for initial values that are used to condition the generated case
									; context_values: optional, list of initial feature values that are used to condition the generated case
									; action_features: full list of features to generate values for the case. Context feature values, if provided, will be output as-is
									; use_regional_model_residuals: flag, if false uses model feature residuals, if true recalculates regional model residuals. Default is true.
									; feature_bounds_map: optional assoc of :
									;				{ feature : { "min": a, "max": b, "allow_null": false/true } }
									;				to ensure that specified features' generated values stay in bounds
									;				for nominal features instead of min/max it's a set of allowed values, ie:
									;				{ feature: { "allowed" : [ "value1", "value2" ... ] }, "allow_null": false/true }
									;               allow_null - default is true, if true nulls may be generated per their distribution in the data
									; generate_novel_case :  optional flag, if true will generate a case that's not already in the model. If unable to generate a novel, outputs null
									; desired_conviction : optional, value of desired average conviction of generated cases, default is 1.0
									;                    larger values will increase the variance (or creativity) of the generated case from the existing model.
									;                    smaller values will decrease the variance (or creativity) of the generated case from the existing model.
									; ordered_by_specified_features : flag, if true order of generated feature values will match the order of features
									; case_indices: optional pair (list) of session id and index, where index is the original 0-based session_training_index of the case as it was
									;			trained into the session. If this case does not exist, this parameter is ignored.
									; preserve_feature_values : optional, list of features that will preserve their values from the case specified by case_indices, appending and
									;				overwriting the specified context and context features as necessary.  If case_indices isn't specified, will preserve feature
									;				values of a random case.
									; leave_case_out: flag, if set to true and specified along with case_indices, will ignore the case specified by case_indices
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight
									; substitute_output : flag, default is true, only applicable if a substitution value map has been set. If set to false, will not substitute categorical feature values.
									; original_substitute_output : flag, same as susbtute_output, mantains the original value of this flag on re-generation attempts
									##GenerateCase
									(declare
										(assoc
											generate_novel_case (false)
											valid_weight_feature (false)
											use_regional_model_residuals (true)
											weight_feature ".case_weight"
											context_values (list)
											leave_case_out (false)
											use_case_weights (false)
											substitute_output (true)
											preserve_feature_values (list)
											original_substitute_output (true)
											action_features defaultFeatures
											desired_conviction 1
											feature_bounds_map (assoc)
											context_features (list)
											case_indices (null)
											ordered_by_specified_features (false)
										)

										;if user doesn't want to use case weights, change weight_feature to '.none'
										(if
											(not use_case_weights)
											(assign
												(assoc
													weight_feature ".none"
												)
											)

											;else using case weights, weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
											(assign
												(assoc
													valid_weight_feature (or
															hasPopulatedCaseWeight
															(!=
																weight_feature
																".case_weight"
															)
														)
												)
											)
										)
										(declare
											(assoc
												hyperparam_map (if
														(=
															1
															(size
																action_features
															)
														)
														(call
															GetHyperparameters
															(assoc
																weight_feature weight_feature
																feature (first
																		action_features
																	)
																mode "full"
															)
														)
														(call
															GetHyperparameters
															(assoc
																weight_feature weight_feature
																feature ".targetless"
																mode "robust"
															)
														)
													)
											)
										)

										;if global residuals have have not been calculated yet, recalculate them. they are needed regardless of which residual mode is being used
										(if
											(not
												(get
													hyperparam_map
													"allFeatureResidualsCached"
												)
											)
											(call
												CalculateFeatureResiduals
												(assoc
													robust_residuals (!=
															1
															(size
																action_features
															)
														)
													num_samples 1000
													store_deviations (true)
													weight_feature weight_feature
													features defaultFeatures
													use_case_weights use_case_weights
													hyperparameter_feature (if
															(=
																1
																(size
																	action_features
																)
															)
															(first
																action_features
															)
															".targetless"
														)
												)
											)
										)

										;if for some reason expected values haven't been cached, do that here
										(if
											(=
												0
												(size expectedValuesMap)
											)
											(call
												CacheExpectedValuesAndProbabilities
												(assoc
													weight_feature weight_feature
													use_case_weights use_case_weights
													features defaultFeatures
												)
											)
										)

										;if custom feature bounds map is specified and it has datetime features, ensure that epoch min/max will be calculated for these
										;custom datetimes by setting those features' has_epoch_bounds flag to false
										(if
											feature_bounds_map
											(assign
												(assoc
													feature_bounds_map (map
															(lambda
																(if
																	(contains_index
																		featureDateTimeMap
																		(current_index)
																	)
																	(append
																		(current_value)
																		(assoc
																			has_epoch_bounds (false)
																		)
																	)
																	(current_value)
																)
															)
															feature_bounds_map
														)
												)
											)
										)

										;overwrite the model featureBoundsMap with the passed in react-specific one
										(assign
											(assoc
												feature_bounds_map (if
														hasStringOrdinals

														;overwrite allowed string ordinals if specified for react, else remove the global allowed list since it contains all values
														(map
															(lambda

																;overwrite allowed feature attribute for string ordinals
																(if
																	(contains_index
																		ordinalStringToOrdinalMap
																		(current_index)
																	)

																	;if user specified a custom allowed list for this specific react, encode it and set as the allowed list
																	(if
																		(size
																			(get
																				feature_bounds_map
																				(list
																					(current_index
																						1
																					)
																					"allowed"
																				)
																			)
																		)
																		(set
																			(current_value)
																			"allowed"
																			(unzip
																				(get
																					ordinalStringToOrdinalMap
																					(current_index)
																				)
																				(get
																					feature_bounds_map
																					(list
																						(current_index
																							1
																						)
																						"allowed"
																					)
																				)
																			)
																		)

																		;else using global bounds, clear out the allowed list since it's unnecessary
																		(remove
																			(current_value)
																			"allowed"
																		)
																	)

																	;else bounds as-is
																	(current_value)
																)
															)
															(append
																featureBoundsMap
																feature_bounds_map
															)
														)

														;else append the the passed params to the model parameters
														(append
															featureBoundsMap
															feature_bounds_map
														)
													)
											)
										)
										(declare
											(assoc
												action_features_map (zip
														action_features
													)
												feature_residual (null)
												preserve_case_id (if
														(size
															case_indices
														)
														(call
															GetCaseId
															(assoc
																session (first
																		case_indices
																	)
																session_training_index (last
																		case_indices
																	)
															)
														)
													)
												ordinal_features_map (zip
														ordinalFeatures
													)
												context_values_map (zip
														context_features
														context_values
													)
												ordinal_residual (null)
											)
										)

										;if there are preserve feature values, either grab them from the case or randomly pick a case and use those as the initial values
										(if
											(size preserve_feature_values)
											(seq
												(if
													(=
														(null)
														preserve_case_id
													)
													(let
														(assoc
															not_null_features_list (filter
																	(lambda
																		(=
																			(get
																				feature_bounds_map
																				(list
																					(current_value
																						1
																					)
																					"allow_null"
																				)
																			)
																			(false)
																		)
																	)
																	(indices
																		feature_bounds_map
																	)
																)
														)
														(assign
															(assoc
																preserve_case_id (first
																		(contained_entities
																			(append
																				(query_exists
																					internalLabelSession
																				)
																				(map
																					(lambda
																						(query_exists
																							(current_value)
																						)
																					)
																					not_null_features_list
																				)
																				(query_sample
																					1
																					(rand)
																				)
																			)
																		)
																	)
															)
														)
													)
												)
												(if
													(!=
														(null)
														preserve_case_id
													)
													(let
														(assoc
															preserved_values (call
																	ConvertToOutput
																	(assoc
																		feature_values (retrieve_from_entity
																				preserve_case_id
																				preserve_feature_values
																			)
																		has_rounded_features (false)
																		features preserve_feature_values
																		substitute_output (false)
																	)
																)
														)

														;append to the context values map each of the preserve features and the corresponding values from the matching case
														(accum
															(assoc
																context_values_map (zip
																		preserve_feature_values
																		preserved_values
																	)
															)
														)
													)
												)
											)
										)
										(if
											(>
												(size context_values_map)
												0
											)
											(seq

												;overwrite the context features and values since they may have been changed via the processes above
												(assign
													(assoc
														context_values (unzip
																context_values_map
																(indices
																	context_values_map
																)
															)
														action_features_map (filter
																(lambda
																	(not
																		(contains_index
																			context_values_map
																			(get_value
																				(current_index)
																			)
																		)
																	)
																)
																action_features_map
															)
														context_features (indices
																context_values_map
															)
													)
												)
												(if
													hasFeaturesNeedEncodingFromInput
													(assign
														(assoc
															context_values (call
																	ConvertFromInput
																	(assoc
																		feature_values context_values
																		features context_features
																	)
																)
														)
													)
												)
											)
										)

										;set the order of features for generation
										(declare
											(assoc
												rand_ordered_features
													;leave the ordering as is if ordered_by_specified_features is True
													(if
														ordered_by_specified_features
														(filter
															(lambda
																(not
																	(contains_index
																		context_values_map
																		(current_value)
																	)
																)
															)
															action_features
														)

														;randomly order features, ignoring those already specified in the initial values
														(rand
															(indices
																action_features_map
															)
															(size
																action_features_map
															)
															(true)
														)
													)
												dependent_features_map (if
														hasDependentFeatures
														(retrieve_from_entity
															"dependentFeatureMap"
														)
														(null)
													)
											)
										)

										;if user specified context features and there are dependents, precompute all residuals for dependent continuous features
										(if
											(and
												(size context_features)
												dependent_features_map
											)
											(call
												ComputeAndCacheMinMaxForDependentContinuousContexts
												(assoc
													use_regional_model_residuals use_regional_model_residuals
													context_values context_values
													hyperparam_map hyperparam_map
													context_features context_features
												)
											)
										)
										(declare
											(assoc
												threshold_feature_residuals
													;iterate over features, reacting to the growing context to generate new feature values, outputs the local residual
													(map
														(lambda
															(let
																(assoc
																	action_feature_is_dependent (false)
																	feature_is_ordinal (contains_index
																			ordinal_features_map
																			(current_value
																				1
																			)
																		)
																	local_class_probabilities_map (null)
																	regional_model_context_features (list)
																	allow_nulls (!=
																			(false)
																			(get
																				feature_bounds_map
																				(list
																					(current_value
																						2
																					)
																					"allow_null"
																				)
																			)
																		)
																	cycle_length (get
																			cyclicFeaturesMap
																			(current_value
																				1
																			)
																		)
																	feature (current_value
																			1
																		)
																	action_value (null)
																	local_case_ids (list)
																	react_map (assoc)
																	action_feature_is_dependent_and_continuous (false)
																	feature_is_nominal (contains_index
																			nominalsSet
																			(current_value
																				1
																			)
																		)
																	regional_model_cases_map (null)
																	regional_model_context_values (list)
																)
																(if
																	dependent_features_map
																	(if
																		(contains_index
																			dependent_features_map
																			feature
																		)
																		(assign
																			(assoc
																				action_feature_is_dependent (true)
																				action_feature_is_dependent_and_continuous (not
																						feature_is_nominal
																					)
																			)
																		)
																	)
																)

																;if there are contexts, react to them for the specified feature to get the new action value
																(if
																	(>
																		(size
																			context_features
																		)
																		0
																	)
																	(seq
																		(assign
																			(assoc
																				react_map (call
																						NearestRegionReact
																						(assoc
																							action_feature_is_dependent action_feature_is_dependent
																							valid_weight_feature valid_weight_feature
																							allow_nulls allow_nulls
																							ignore_case (if
																									leave_case_out
																									preserve_case_id
																								)
																							context_values context_values
																							weight_feature weight_feature
																							approximate_residual (and
																									(not
																										feature_is_nominal
																									)
																									(not
																										use_regional_model_residuals
																									)
																								)
																							action_feature feature
																							feature_is_nominal feature_is_nominal
																							hyperparam_map hyperparam_map
																							context_features context_features
																						)
																					)
																			)
																		)
																		(if
																			feature_is_nominal
																			(assign
																				(assoc
																					action_value (get
																							react_map
																							"action_value"
																						)
																					local_class_probabilities_map (get
																							react_map
																							"categorical_value_weights_map"
																						)
																				)
																			)

																			;else select action value by weighted probability using the weight of each cases's influence as the probability
																			(seq
																				(assign
																					(assoc
																						local_case_ids (get
																								react_map
																								"local_case_ids"
																							)
																					)
																				)
																				(declare
																					(assoc
																						random_weighted_case_id (weighted_rand

																								;pass in associated lists of index of local case -> its weight in the order of
																								;local_case_ids to ensure reproduceability for random seeds
																								(list
																									local_case_ids
																									(unzip
																										(get
																											react_map
																											"local_model_cases_map"
																										)
																										local_case_ids
																									)
																								)
																							)
																					)
																				)

																				;pull action value from the randomly selected case by the weight of the case's influence
																				(assign
																					(assoc
																						action_value (retrieve_from_entity
																								random_weighted_case_id
																								feature
																							)
																					)
																				)
																			)
																		)
																		(assign
																			(assoc
																				regional_model_context_features (append
																						context_features
																						feature
																					)
																				regional_model_context_values (append
																						context_values
																						action_value
																					)
																			)
																		)

																		;for continous fetaures, when not running RMR, pull the local case ids around the predicted value to approximate
																		;the residual using feature gaps in the localized area around the currently generated case
																		(if
																			(and
																				(not
																					feature_is_nominal
																				)
																				(not
																					use_regional_model_residuals
																				)
																			)
																			(seq
																				(assign
																					(assoc
																						react_map (call
																								NearestRegionReact
																								(assoc
																									action_feature_is_dependent action_feature_is_dependent
																									valid_weight_feature valid_weight_feature
																									allow_nulls allow_nulls
																									ignore_case (if
																											leave_case_out
																											preserve_case_id
																										)
																									context_values regional_model_context_values
																									weight_feature weight_feature
																									approximate_residual (true)
																									action_feature feature
																									feature_is_nominal feature_is_nominal
																									hyperparam_map hyperparam_map
																									context_features regional_model_context_features
																								)
																							)
																					)
																				)
																				(assign
																					(assoc
																						local_case_ids (get
																								react_map
																								"local_case_ids"
																							)
																					)
																				)
																			)
																		)
																	)

																	;else just pick a case at random and get that case's value for this feature
																	(let
																		(assoc
																			case_id (first
																					(contained_entities
																						(list
																							(query_exists
																								internalLabelSession
																							)
																							(if
																								valid_weight_feature

																								;select case using weighted random
																								(query_weighted_sample
																									weight_feature
																									1
																									(rand)
																								)

																								;else just select a random case
																								(query_sample
																									1
																									(rand)
																								)
																							)
																						)
																					)
																				)
																		)
																		(assign
																			(assoc
																				regional_model_context_features action_features
																				action_value (retrieve_from_entity
																						case_id
																						feature
																					)
																				regional_model_context_values (retrieve_from_entity
																						case_id
																						action_features
																					)
																			)
																		)

																		;find the localized area around the starting case to use for residual approximation for this feature
																		(assign
																			(assoc
																				react_map (call
																						NearestRegionReact
																						(assoc
																							action_feature_is_dependent action_feature_is_dependent
																							valid_weight_feature valid_weight_feature
																							allow_nulls allow_nulls
																							ignore_case (if
																									leave_case_out
																									preserve_case_id
																								)
																							context_values regional_model_context_values
																							weight_feature weight_feature
																							approximate_residual (and
																									(not
																										feature_is_nominal
																									)
																									(not
																										use_regional_model_residuals
																									)
																								)
																							action_feature feature
																							feature_is_nominal feature_is_nominal
																							hyperparam_map hyperparam_map
																							context_features regional_model_context_features
																						)
																					)
																			)
																		)
																		(if
																			feature_is_nominal
																			(assign
																				(assoc
																					local_class_probabilities_map (get
																							react_map
																							"categorical_value_weights_map"
																						)
																				)
																			)
																			(assign
																				(assoc
																					local_case_ids (get
																							react_map
																							"local_case_ids"
																						)
																				)
																			)
																		)
																	)
																)

																;if this flag is specified, recalculate residuals around this particular reaction, otherwise use the model's residuals
																(if
																	(and
																		use_regional_model_residuals
																		(>
																			(size
																				regional_model_context_features
																			)
																			0
																		)

																		;can't do regional residuals if only one feature is provided
																		(!=
																			regional_model_context_features
																			(list
																				feature
																			)
																		)
																	)
																	(let
																		(assoc
																			ignore_case (if
																					leave_case_out
																					preserve_case_id
																				)
																			feature_hyperparam_map (call
																					GetHyperparameters
																					(assoc
																						weight_feature weight_feature
																						feature feature
																						mode "robust"
																					)
																				)
																			regional_residuals (null)
																		)
																		(assign
																			(assoc
																				dependent_queries_list (if
																						action_feature_is_dependent
																						(call
																							ComputeDependentQueries
																							(assoc
																								context_values regional_model_context_values
																								action_feature feature
																								context_features regional_model_context_features
																							)
																						)
																						(list)
																					)
																			)
																		)
																		(assign
																			(assoc
																				regional_model_cases_map ##!NearestRegionalResidualCasesQuery
																					(compute_on_contained_entities
																						(append
																							(if
																								ignore_case
																								(query_not_in_entity_list
																									(list
																										ignore_case
																									)
																								)
																								(list)
																							)
																							dependent_queries_list
																							(query_nearest_generalized_distance
																								(max
																									(get
																										feature_hyperparam_map
																										"k"
																									)
																									30
																								)
																								regional_model_context_features
																								regional_model_context_values
																								(get
																									feature_hyperparam_map
																									"featureWeights"
																								)
																								nominalClassCountsMap
																								cyclicFeaturesMap
																								(if
																									(get
																										feature_hyperparam_map
																										"useDeviations"
																									)
																									(get
																										feature_hyperparam_map
																										"featureDeviations"
																									)
																								)
																								(get
																									feature_hyperparam_map
																									"p"
																								)
																								(get
																									feature_hyperparam_map
																									"dwe"
																								)
																								(if
																									valid_weight_feature
																									weight_feature
																									(null)
																								)
																								(rand)
																								(null)

																								;radius
																								lpSpaceHeuristicMultiplier
																								(true)
																							)
																						)
																					)
																			)
																		)

																		;reduce dependent feature queries list if regional_model_cases_map is too small, as appropriate
																		;if regional_model_cases_map is too small to be viable, then remove dependent feature queries and recompute
																		;regional_model_cases_map until sufficiently many cases are returned
																		(if
																			action_feature_is_dependent
																			(while
																				(and
																					(<
																						(size
																							regional_model_cases_map
																						)
																						3
																					)
																					(>
																						(size
																							dependent_queries_list
																						)
																						0
																					)
																				)
																				(assign
																					(assoc
																						dependent_queries_list (trunc
																								dependent_queries_list
																							)
																					)
																				)
																				(assign
																					(assoc
																						regional_model_cases_map (call
																								!NearestRegionalResidualCasesQuery
																							)
																					)
																				)
																			)
																		)
																		(assign
																			(assoc
																				regional_residuals (call
																						ComputeRegionalResiduals
																						(assoc
																							ignore_case ignore_case
																							residual_features (list
																									feature
																								)
																							features regional_model_context_features
																							output_ordinal_residuals feature_is_ordinal
																							regional_model_cases_map regional_model_cases_map
																						)
																					)
																			)
																		)
																		(if
																			feature_is_ordinal
																			(assign
																				(assoc
																					feature_residual (get
																							regional_residuals
																							(list
																								0
																								feature
																							)
																						)
																					ordinal_residual (get
																							regional_residuals
																							(list
																								1
																								feature
																							)
																						)
																				)
																			)
																			(assign
																				(assoc
																					feature_residual (get
																							regional_residuals
																							feature
																						)
																				)
																			)
																		)

																		;don't allow feature residual of 1, set it to: 1 - smallest theoretical residual
																		(if
																			(and
																				feature_is_nominal
																				(=
																					1
																					feature_residual
																				)
																			)
																			(assign
																				(assoc
																					feature_residual (-
																							1
																							(get
																								cachedFeatureMinResidualMap
																								feature
																							)
																						)
																				)
																			)
																		)
																	)

																	;else local and regional model feature gaps to approximate regional residual for the feature
																	(seq

																		;set residual to be the max(min feature gap/2, largest local model feature gap)
																		(if
																			(and
																				(not
																					feature_is_nominal
																				)
																				(>
																					(size
																						local_case_ids
																					)
																					1
																				)
																			)
																			(assign
																				(assoc
																					feature_residual (max
																							(get
																								cachedFeatureMinGapMap
																								feature
																							)
																							(min
																								(compute_on_contained_entities
																									(list
																										(query_in_entity_list
																											local_case_ids
																										)
																										(query_max_difference
																											feature
																											(get
																												cyclicFeaturesMap
																												feature
																											)
																										)
																									)
																								)
																								(compute_on_contained_entities
																									(list
																										(query_in_entity_list
																											(get
																												react_map
																												"regional_case_ids"
																											)
																										)
																										(query_max_difference
																											feature
																											(get
																												cyclicFeaturesMap
																												feature
																											)
																										)
																									)
																								)
																							)
																						)
																				)
																			)

																			;nominal features just use global residual
																			(assign
																				(assoc
																					feature_residual (get
																							hyperparam_map
																							(list
																								"featureDeviations"
																								feature
																							)
																						)
																				)
																			)
																		)

																		;if feature_residual is null but there is an action value, this may generate a 'nan' value for this feature
																		;to prevent that, set the residual to: boundary_max - boundary_min (if boundaries are specified)
																		(if
																			(and
																				(or
																					(=
																						(null)
																						feature_residual
																					)
																					(=
																						.nan
																						feature_residual
																					)
																				)
																				(!=
																					(null)
																					action_value
																				)
																			)
																			(let
																				(assoc
																					boundaries_tuple (call
																							ConstrainBoundariesForFeature
																							(assoc
																								feature feature
																								is_datetime (and
																										hasDateTimeFeatures
																										(contains_index
																											featureDateTimeMap
																											feature
																										)
																									)
																								cycle_length cycle_length
																								bounds_map (get
																										feature_bounds_map
																										feature
																									)
																							)
																						)
																				)
																				(assign
																					(assoc
																						feature_residual
																							;if a boundary value is not specified, residual is unknown, set it to 0
																							(if
																								(contains_value
																									boundaries_tuple
																									(null)
																								)
																								0

																								;for cyclics with exclusionary bounds where the min is larger than the max,
																								;e.g., to allow +/- 60 degrees, boundary_min=300, boundary_max=60
																								;therefore the range is: boundary_max + (cycle_length - boundary_min)
																								(and
																									cycle_length
																									(>
																										(first
																											boundaries_tuple
																										)
																										(last
																											boundaries_tuple
																										)
																									)
																								)
																								(/
																									(+
																										(last
																											boundaries_tuple
																										)
																										(-
																											cycle_length
																											(first
																												boundaries_tuple
																											)
																										)
																									)
																									4
																								)

																								;else residual is simply the range: (boundary_max - boundary_min)
																								(/
																									(-
																										(last
																											boundaries_tuple
																										)
																										(first
																											boundaries_tuple
																										)
																									)
																									4
																								)
																							)
																					)
																				)
																			)
																		)
																		(if
																			feature_is_ordinal
																			(assign
																				(assoc
																					ordinal_residual (get
																							hyperparam_map
																							(list
																								"featureOrdinalDeviations"
																								feature
																							)
																						)
																				)
																			)
																		)

																		;if there is no residual for nominal features, set it to be the smallest allowed value
																		(if
																			feature_is_nominal
																			(if
																				(or
																					(=
																						0
																						feature_residual
																					)
																					(=
																						(null)
																						feature_residual
																					)
																				)
																				(assign
																					(assoc
																						feature_residual (if
																								(get
																									cachedFeatureMinResidualMap
																									feature
																								)
																								(get
																									cachedFeatureMinResidualMap
																									feature
																								)

																								;else no cached feature min residual, set it to 50% chance you'll get the next one wrong:  1-(n+1/n+2)
																								(-
																									1
																									(/
																										(+
																											1
																											(call
																												GetNumTrainingCases
																											)
																										)
																										(+
																											2
																											(call
																												GetNumTrainingCases
																											)
																										)
																									)
																								)
																							)
																					)
																				)
																			)
																		)
																	)
																)

																;if the action features is dependent and continuous, store its min and max now that the residual has been calculated
																(if
																	action_feature_is_dependent_and_continuous
																	(if
																		(!=
																			(null)
																			action_value
																		)
																		(accum
																			"dependent_features_map"
																			(list
																				feature
																				"min"
																			)
																			(-
																				action_value
																				feature_residual
																			)
																			(list
																				feature
																				"max"
																			)
																			(+
																				action_value
																				feature_residual
																			)
																		)
																	)
																)

																;generate the new feature value using a laplace distribution around the action value
																(declare
																	(assoc
																		new_feature_value (call
																				GenerateFeatureValue
																			)
																	)
																)

																;generated values for ordinal features  are 'snapped' to the closest ordinal value
																;if the generated value is more than gap/2 away from either the min or max ordinal value,
																;we randomly pick a value based on the regional distribution of ordinal values for that feature
																;to prevent snapping to the min or the max, which would lead to a skewed distribution with too many mins and maxs
																(if
																	(contains_index
																		ordinal_features_map
																		feature
																	)
																	(let
																		(assoc
																			backup_feature_value new_feature_value
																			ordinal_values
																				;use all ordinal values (globals) if rand is less than the conviction-scaled ordinal residual
																				(if
																					(<
																						(rand)
																						(/
																							ordinal_residual
																							desired_conviction
																						)
																					)
																					(let
																						(assoc
																							allowed_values_map (zip
																									(get
																										feature_bounds_map
																										(list
																											feature
																											"allowed"
																										)
																									)
																								)
																						)
																						(if
																							(size
																								allowed_values_map
																							)

																							;filter globals down to allowed list only
																							(let
																								(assoc
																									allowed_global_ordinal_values (filter
																											(lambda
																												(contains_index
																													allowed_values_map
																													(current_value)
																												)
																											)
																											(get
																												ordinalFeaturesValuesMap
																												feature
																											)
																										)
																								)

																								;if there are no local values on the allowed list, set the local values to be the allowed list
																								(if
																									(=
																										(size
																											allowed_global_ordinal_values
																										)
																										0
																									)
																									(get
																										feature_bounds_map
																										(list
																											feature
																											"allowed"
																										)
																									)

																									;else returned only the allowed global values
																									allowed_global_ordinal_values
																								)
																							)

																							;return all the ordinal feature values
																							(get
																								ordinalFeaturesValuesMap
																								feature
																							)
																						)
																					)

																					;else only select local ordinal values
																					(let
																						(assoc
																							allowed_values_map (zip
																									(get
																										feature_bounds_map
																										(list
																											feature
																											"allowed"
																										)
																									)
																								)
																							unique_local_ordinal_values (map

																									;convert the indices to numbers since ordinals are numeric, convert .nas back to null
																									(lambda
																										(if
																											(=
																												.nas
																												(current_value)
																											)
																											(null)
																											(+
																												(current_value)
																											)
																										)
																									)

																									;grab unique values only by taking the indices of the assoc of ordinal values in the local model
																									(indices
																										(zip
																											(map
																												(lambda
																													(retrieve_from_entity
																														(current_value)
																														feature
																													)
																												)
																												local_case_ids
																											)
																										)
																									)
																								)
																						)
																						(if
																							(size
																								allowed_values_map
																							)
																							(seq
																								(assign
																									(assoc
																										unique_local_ordinal_values (filter
																												(lambda
																													(contains_index
																														allowed_values_map
																														(current_value)
																													)
																												)
																												unique_local_ordinal_values
																											)
																									)
																								)

																								;if there are no local values on the allowed list, set the local values to be the allowed list
																								(if
																									(=
																										(size
																											unique_local_ordinal_values
																										)
																										0
																									)
																									(assign
																										(assoc
																											unique_local_ordinal_values (get
																													feature_bounds_map
																													(list
																														feature
																														"allowed"
																													)
																												)
																										)
																									)
																								)
																							)
																						)
																						(sort
																							unique_local_ordinal_values
																						)
																					)
																				)
																		)
																		(if
																			(=
																				1
																				(size
																					ordinal_values
																				)
																			)
																			(assign
																				(assoc
																					new_feature_value (first
																							ordinal_values
																						)
																				)
																			)
																			(if
																				(or

																					;generated value is less than min
																					(<
																						backup_feature_value
																						(first
																							ordinal_values
																						)
																					)

																					;generated value is more than max
																					(>
																						backup_feature_value
																						(last
																							ordinal_values
																						)
																					)
																				)
																				(let
																					(assoc
																						gap (if
																								(<
																									backup_feature_value
																									(first
																										ordinal_values
																									)
																								)
																								(-
																									(get
																										ordinal_values
																										1
																									)
																									(first
																										ordinal_values
																									)
																								)

																								;else set the gap to be the diff between the last  two values if the generated value is more than max
																								(-
																									(last
																										ordinal_values
																									)
																									(get
																										ordinal_values
																										(-
																											(size
																												ordinal_values
																											)
																											2
																										)
																									)
																								)
																							)
																					)

																					;if generated value is farther than gap/2 from either the min or max, select a random one from the distribution
																					(if
																						(or
																							(<
																								backup_feature_value
																								(-
																									(first
																										ordinal_values
																									)
																									(/
																										gap
																										2
																									)
																								)
																							)
																							(>
																								backup_feature_value
																								(+
																									(last
																										ordinal_values
																									)
																									(/
																										gap
																										2
																									)
																								)
																							)
																						)
																						(assign
																							(assoc
																								new_feature_value (rand
																										ordinal_values
																									)
																							)
																						)

																						;else value is close to either min or max ordinal value, snap to the appropriate one
																						(assign
																							(assoc
																								new_feature_value (if
																										(<
																											backup_feature_value
																											(first
																												ordinal_values
																											)
																										)
																										(first
																											ordinal_values
																										)
																										(last
																											ordinal_values
																										)
																									)
																							)
																						)
																					)
																				)

																				;else snap to the closest ordinal value in the ordinal_values list
																				(assign
																					(assoc
																						new_feature_value (call
																								FindClosestOrdinalFeatureValue
																								(assoc
																									feature feature
																									value new_feature_value
																									sorted_feature_values ordinal_values
																								)
																							)
																					)
																				)
																			)
																		)
																	)
																)

																;if feature bounds are specified, ensure generated values are within the bounds by regenerating the value up to 5 times
																;only applies to non-nominal features since those have their bounds enforced inside the GenerateFeatureValue method since
																;nominals are generated from a list that may be predetermined, and thus are guaranteed to be within the bounds specified
																(if
																	(and
																		(not
																			feature_is_nominal
																		)
																		(or
																			(contains_index
																				feature_bounds_map
																				feature
																			)
																			cycle_length
																		)

																		;if nulls are allowed and this value is a null, do not regenerate
																		(not
																			(and
																				(=
																					new_feature_value
																					(null)
																				)
																				(get
																					feature_bounds_map
																					(list
																						feature
																						"allow_null"
																					)
																				)
																			)
																		)
																	)
																	(let
																		(assoc
																			regenerate 0
																			out_of_bounds (false)
																			allow_null (get
																					feature_bounds_map
																					(list
																						feature
																						"allow_null"
																					)
																				)
																			boundaries_tuple (call
																					ConstrainBoundariesForFeature
																					(assoc
																						feature feature
																						is_datetime (and
																								hasDateTimeFeatures
																								(contains_index
																									featureDateTimeMap
																									feature
																								)
																							)
																						cycle_length cycle_length
																						bounds_map (get
																								feature_bounds_map
																								feature
																							)
																					)
																				)
																		)
																		(declare
																			(assoc
																				boundary_min (first
																						boundaries_tuple
																					)
																				retry_desired_conviction (/
																						desired_conviction
																						2
																					)
																				boundary_max (last
																						boundaries_tuple
																					)
																			)
																		)

																		;if boundaries are same, set the generated value to the boundary since that is the only allowed value
																		(if
																			(and
																				(!=
																					(null)
																					boundary_min
																				)
																				(=
																					boundary_min
																					boundary_max
																				)
																			)
																			(assign
																				(assoc
																					new_feature_value boundary_min
																				)
																			)

																			;else regenerate the fetaure value up to 5 times
																			(while
																				(<
																					regenerate
																					6
																				)

																				;for cyclic features, ensure that the value is within cycle_length by setting it to new_feature_value % cycle_length
																				(if
																					(and
																						cycle_length
																						(!=
																							(null)
																							new_feature_value
																						)
																					)
																					(assign
																						(assoc
																							new_feature_value (if
																									(<
																										new_feature_value
																										0
																									)

																									;convert negative values to positive by adding the modulo to the cycle length
																									(+
																										cycle_length
																										(mod
																											new_feature_value
																											cycle_length
																										)
																									)
																									(mod
																										new_feature_value
																										cycle_length
																									)
																								)
																						)
																					)
																				)
																				(assign
																					(assoc
																						out_of_bounds (if
																								(and
																									cycle_length
																									(>=
																										boundary_min
																										boundary_max
																									)
																								)
																								(and
																									(>
																										new_feature_value
																										boundary_max
																									)
																									(<
																										new_feature_value
																										boundary_min
																									)
																								)
																								(or
																									(and
																										(!=
																											(null)
																											boundary_min
																										)
																										(<
																											new_feature_value
																											boundary_min
																										)
																									)
																									(and
																										(!=
																											(null)
																											boundary_max
																										)
																										(>
																											new_feature_value
																											boundary_max
																										)
																									)
																								)
																							)
																					)
																				)
																				(if
																					(or
																						out_of_bounds
																						(and
																							(=
																								(null)
																								new_feature_value
																							)
																							(=
																								(false)
																								allow_null
																							)
																						)
																					)
																					(seq
																						(if
																							(<
																								regenerate
																								5
																							)
																							(assign
																								(assoc
																									new_feature_value (call
																											GenerateFeatureValue
																											(assoc
																												desired_conviction retry_desired_conviction
																											)
																										)
																								)
																							)

																							;else attempted to be generated 5 times, on the 6th just choose a random value in the specified range
																							(assign
																								(assoc
																									new_feature_value (if
																											action_feature_is_dependent_and_continuous
																											(call
																												GetRandomWithinBoundariesForContinuousDependent
																											)

																											;non-dependent features
																											(if
																												(and
																													(!=
																														(null)
																														boundary_max
																													)
																													(!=
																														(null)
																														boundary_min
																													)
																												)
																												(if
																													(and
																														cycle_length
																														(<
																															boundary_max
																															boundary_min
																														)
																													)

																													;for exclusionary cyclics, generate a value in the allowed range
																													(+
																														boundary_min
																														(rand
																															(+
																																boundary_max
																																(-
																																	cycle_length
																																	boundary_min
																																)
																															)
																														)
																													)
																													(+
																														boundary_min
																														(rand
																															(-
																																boundary_max
																																boundary_min
																															)
																														)
																													)
																												)

																												;else only one boundary is specified, choose a random value by adding or subtracting the random from
																												;the boundary instead of from the action_value
																												(let
																													(assoc
																														R (-
																																(rand)
																																0.5
																															)
																													)

																													;always ensure the random value is positive by taking an abs
																													(declare
																														(assoc
																															ln_const (abs
																																	(log
																																		(-
																																			1
																																			(*
																																				2
																																				(abs
																																					R
																																				)
																																			)
																																		)
																																	)
																																)
																														)
																													)
																													(if

																														;only boundary_max was specified, subtract the random value from it
																														(!=
																															(null)
																															boundary_max
																														)
																														(-
																															boundary_max
																															(*
																																feature_residual
																																ln_const
																																(/
																																	1
																																	desired_conviction
																																)
																															)
																														)

																														;else only boundary_min was specified, add to it
																														(+
																															boundary_min
																															(*
																																feature_residual
																																ln_const
																																(/
																																	1
																																	desired_conviction
																																)
																															)
																														)
																													)
																												)
																											)
																										)
																								)
																							)
																						)

																						;halve the desired conviction to double the noise for every retry
																						(assign
																							(assoc
																								retry_desired_conviction (/
																										retry_desired_conviction
																										2
																									)
																							)
																						)
																						(accum
																							(assoc
																								regenerate 1
																							)
																						)
																					)

																					;else within bounds, stop regenerating values
																					(conclude)
																				)
																			)
																		)
																	)
																)

																;for cyclic features, ensure that the value is within cycle_length by setting it to new_feature_value % cycle_length
																(if
																	(and
																		cycle_length
																		(!=
																			(null)
																			new_feature_value
																		)
																	)
																	(assign
																		(assoc
																			new_feature_value (if
																					(<
																						new_feature_value
																						0
																					)

																					;convert negative values to positive by adding the modulo to the cycle length
																					(+
																						cycle_length
																						(mod
																							new_feature_value
																							cycle_length
																						)
																					)
																					(mod
																						new_feature_value
																						cycle_length
																					)
																				)
																		)
																	)
																)

																;grow the context using the generated value
																(assign
																	(assoc
																		context_values (append
																				context_values
																				new_feature_value
																			)
																		context_features (append
																				context_features
																				feature
																			)
																	)
																)

																;output a list of feature residuals
																feature_residual
															)
														)

														;iterate over the features to be generated
														rand_ordered_features
													)
											)
										)
										(if
											(not generate_novel_case)
											(seq

												;if nominals should be encoded, they should be decoded and substituted prior to output as well
												(if
													hasEncodedFeatures
													(assign
														(assoc
															context_values (call
																	ConvertToOutput
																	(assoc
																		feature_values context_values
																		original_context_map context_values_map
																		features context_features
																	)
																)
														)
													)

													;else if needs rounding
													hasRoundedFeatures
													(assign
														(assoc
															context_values (call
																	RoundContinuousFeatures
																	(assoc
																		feature_values context_values
																		features context_features
																	)
																)
														)
													)
												)
											)

											;should round values prior to checking for novel cases
											hasRoundedFeatures
											(assign
												(assoc
													context_values (call
															RoundContinuousFeatures
															(assoc
																feature_values context_values
																features context_features
															)
														)
												)
											)
										)

										;output values in the same order as action_features
										(if
											(not generate_novel_case)
											(conclude
												(unzip
													(zip
														context_features
														context_values
													)
													action_features
												)
											)
										)

										;if case must be novel, ensure that no exact cases like this already exist in the model
										(let
											(assoc
												checked_feature_index 0
												num_diff_features 0
												min_diff_num_features (floor
														(log
															(+
																1
																(size
																	context_features
																)
															)
														)
													)
												threshold_distance 0
												p_parameter 0.1
												local_model_cases_tuple (list)
												ignore_case (if
														leave_case_out
														preserve_case_id
													)
												local_model_cases_map (assoc)
												threshold_feature_residuals_map (null)
												closest_case_values (list)
												has_dupes (true)
												context_numeric_values (list)
												generate_attempt 0
												hyperparam_map (call
														GetHyperparameters
														(assoc
															weight_feature weight_feature
															feature ".targetless"
															mode "robust"
														)
													)
												closest_case (null)
											)
											(assign
												(assoc
													p_parameter (get
															hyperparam_map
															"p"
														)
													feature_weights (get
															hyperparam_map
															"featureWeights"
														)
													threshold_feature_residuals_map (append
															(get
																hyperparam_map
																"featureDeviations"
															)
															(zip
																rand_ordered_features
																threshold_feature_residuals
															)
														)
													feature_deviations (if
															(get
																hyperparam_map
																"useDeviations"
															)
															(get
																hyperparam_map
																"featureDeviations"
															)
														)
												)
											)

											;check if an exact duplicate already exists in the model and if so re-try up to 2 times to re-generate a novel case
											(while
												(<
													generate_attempt
													3
												)

												;increase the generate counter
												(accum
													(assoc
														generate_attempt 1
													)
												)
												(assign
													(assoc
														checked_feature_index 0
														context_numeric_values
															;output of generative retries are decoded, non-substituted string nominals
															;so encode them here
															(if
																(and
																	hasFeaturesNeedEncodingFromInput
																	(>
																		generate_attempt
																		1
																	)
																)
																(call
																	ConvertFromInput
																	(assoc
																		feature_values context_values
																		features context_features
																	)
																)

																;else just use original encoded values
																context_values
															)
													)
												)

												;do rounding prior to checking for uniqueness so the values being compared are the 'actual' generated values
												(if
													hasRoundedFeatures
													(assign
														(assoc
															context_numeric_values (call
																	RoundContinuousFeatures
																	(assoc
																		feature_values context_numeric_values
																		features context_features
																	)
																)
														)
													)
												)

												;find the closest case
												(assign
													(assoc
														local_model_cases_tuple (compute_on_contained_entities
																(append
																	(if
																		ignore_case
																		(query_not_in_entity_list
																			(list
																				ignore_case
																			)
																		)
																		(list)
																	)
																	(query_nearest_generalized_distance

																		;limit the number of considered nearby neighbors by limiting the bandwidth of local minimum distance
																		;comparison for density-based anonymity preservation, for performance reasons.
																		;May be more accuraty to remove the limit of 15 in the future.
																		(min
																			15
																			(get
																				hyperparam_map
																				"k"
																			)
																		)
																		context_features
																		context_numeric_values
																		feature_weights
																		nominalClassCountsMap
																		cyclicFeaturesMap

																		;Feature deviations are not used in order to ensure that privacy is maximally preserved.
																		;If feature deviations are used, duplicate cases may be deemed private.
																		(false)

																		;feature_deviations
																		p_parameter
																		1

																		;dwe = 1 means return computed distance to each case
																		(null)

																		;weight
																		(rand)
																		(null)

																		;radius
																		lpSpaceHeuristicMultiplier
																		(true)
																		(true)
																	)
																)
															)
													)
												)

												;set closest case to be the one with the smallest distance
												(assign
													(assoc
														closest_case (first
																(first
																	local_model_cases_tuple
																)
															)
														dist_to_closest_case (first
																(last
																	local_model_cases_tuple
																)
															)
													)
												)

												;only test for uniqueness if the generated case is not a perfect match because has_dupes begins with true,
												;skipping this block will indicate that the case is a duplicate
												(if
													(!=
														dist_to_closest_case
														0
													)
													(seq
														(assign
															(assoc
																num_diff_features 0
																closest_case_values (retrieve_from_entity
																		closest_case
																		context_features
																	)
															)
														)

														;loop over all the features and compare the generated value vs the value of the closest case
														;and if any generated feature value is larger than the local feature residual, the generated case is not a duplicate
														(map
															(lambda
																(let
																	(assoc
																		threshold_feature_residual (get
																				threshold_feature_residuals_map
																				(current_value
																					1
																				)
																			)
																		generated_value_difference (if
																				(contains_index
																					nominalsSet
																					(current_value
																						1
																					)
																				)
																				(+
																					(=
																						(get
																							context_numeric_values
																							(current_index
																								1
																							)
																						)
																						(get
																							closest_case_values
																							(current_index
																								1
																							)
																						)
																					)
																				)

																				;else continuous
																				(abs
																					(-
																						(get
																							context_numeric_values
																							(current_index
																								1
																							)
																						)
																						(get
																							closest_case_values
																							(current_index
																								1
																							)
																						)
																					)
																				)
																			)
																	)
																	(if
																		(>
																			generated_value_difference
																			threshold_feature_residual
																		)
																		(assign
																			(assoc
																				num_diff_features (+
																						1
																						num_diff_features
																					)
																				has_dupes (false)
																			)
																		)

																		;else generated value is within residual but not the same, increase count of different features
																		(>
																			generated_value_difference
																			0
																		)
																		(accum
																			(assoc
																				num_diff_features 1
																			)
																		)

																		;if one of the values is a null, check whether both are null as a mismatch check
																		(=
																			.nan
																			generated_value_difference
																		)
																		(if
																			(not
																				(=
																					(null)
																					(get
																						context_numeric_values
																						(current_index)
																					)
																					(get
																						closest_case_values
																						(current_index)
																					)
																				)
																			)
																			(assign
																				(assoc
																					num_diff_features (+
																							1
																							num_diff_features
																						)
																					has_dupes (false)
																				)
																			)
																		)
																	)
																)
															)
															context_features
														)

														;if there aren't enough different features in the similar case, it can be considered a dupe
														(if
															(<
																num_diff_features
																min_diff_num_features
															)
															(assign
																(assoc
																	has_dupes (true)
																)
															)
														)

														;if found one feature different enough, verify that the case itself is as far as any closest case in the local model
														(if
															(not
																has_dupes
															)

															;generated case fails unique test if dist to closest case is less than the minimum entity distance contribution between
															;neighbors.
															(if
																(<
																	dist_to_closest_case
																	(call
																		QueryLocalModelMinDistanceContribution
																		(assoc
																			use_feature_deviations (false)
																			feature_labels context_features
																			entity_ids_to_compute (first
																					local_model_cases_tuple
																				)
																		)
																	)
																)
																(assign
																	(assoc
																		has_dupes (true)
																	)
																)
															)
														)
													)
												)
												(if
													(not
														has_dupes
													)
													(seq

														;if nominals should be encoded, they should be decoded prior to output as well
														(if
															hasEncodedFeatures
															(assign
																(assoc
																	context_values (call
																			ConvertToOutput
																			(assoc
																				feature_values context_numeric_values
																				original_context_map context_values_map
																				features context_features
																				substitute_output original_substitute_output
																			)
																		)
																)
															)

															;else if needs rounding
															hasRoundedFeatures
															(assign
																(assoc
																	context_values (call
																			RoundContinuousFeatures
																			(assoc
																				feature_values context_values
																				features context_features
																			)
																		)
																)
															)
														)
													)
												)
												(if
													(not
														has_dupes
													)

													;no dupes, return the output by breaking out of the loop
													(conclude
														(unzip
															(zip
																context_features
																context_values
															)
															action_features
														)
													)
												)
												(if
													(<
														generate_attempt
														3
													)

													;try to generate a case, explicitly ignoring if it's novel since this block of code checks for
													;already-existing dupes, prevents being stuck in an infinite recursive loop
													(assign
														(assoc
															context_values
																;since generated case values are ordered by action_features, we unzip them in the order of context_features
																(unzip
																	(zip
																		action_features
																		(call
																			GenerateCase
																			(assoc
																				generate_novel_case (false)
																				use_regional_model_residuals use_regional_model_residuals
																				weight_feature weight_feature
																				context_values (values
																						context_values_map
																					)
																				leave_case_out leave_case_out
																				use_case_weights use_case_weights
																				substitute_output (false)
																				preserve_feature_values preserve_feature_values
																				original_substitute_output substitute_output
																				action_features action_features
																				desired_conviction desired_conviction
																				feature_bounds_map feature_bounds_map
																				case_indices case_indices
																				context_features (indices
																						context_values_map
																					)
																			)
																		)
																	)
																	context_features
																)
														)
													)

													;else failed to generated a novel case after 5 times
													(null)
												)
											)
										)
									)

									;given a list of entity ids, determine the minimum distance contribution between
									; all of those cases. Returns the minimum entity distance contribution.
									;parameters:
									; feature_labels : list of feature labels to use for determining distance contributions
									; entity_ids_to_compute : list of entity IDs to compute minimum distance between.
									; filtering_queries : optional, list of filtering queries to apply before computing entity distance
									;                     contributions. Most useful for when calling this method when computing distance ratios.
									; use_feature_deviations : optional, flag which determines whether feature_deviations are used in the query.
									##QueryLocalModelMinDistanceContribution
									(declare
										(assoc
											filtering_queries (list)
											use_feature_deviations (false)
											feature_labels (list)
											entity_ids_to_compute (list)
										)
										(apply
											"min"
											(values
												(compute_on_contained_entities
													(append
														filtering_queries
														(compute_entity_distance_contributions
															1

															;entities_returned
															feature_labels
															entity_ids_to_compute
															feature_weights
															nominalClassCountsMap
															cyclicFeaturesMap
															(if
																use_feature_deviations
																(get
																	hyperparam_map
																	"featureDeviations"
																)
																(false)
															)
															p_parameter
															1

															;dwe = 1 means return computed distance to the case
															(null)

															;weight_feature
															(rand)
															(null)

															;radius
															lpSpaceHeuristicMultiplier
															(true)
														)
													)
												)
											)
										)
									)

									;helper method of GenerateCase, all parameters passed in implicitly
									;samples the specified feature value according to a laplace distribution based on the conviction specified and the residual for the feature
									##GenerateFeatureValue
									(seq
										(if
											feature_is_nominal
											(let

												;calculate probabilities for action given desired conviction and local class probabilities
												(assoc
													class_probabilities_map (call
															BlendNominalClassProbabilities
															(assoc
																feature feature
																local_class_probabilities_map local_class_probabilities_map
																allow_nulls allow_nulls
																feature_residual feature_residual
																action_value action_value
																allowed_values (get
																		feature_bounds_map
																		(list
																			feature
																			"allowed"
																		)
																	)
																desired_conviction desired_conviction
															)
														)
												)
												(if
													(=
														(false)
														allow_nulls
													)
													(seq

														;if nulls are not allowed, but there are no probabilities to choose from,
														;output a randomly weighted global value with nulls filtered out
														(if
															(=
																0
																(size
																	class_probabilities_map
																)
															)
															(assign
																(assoc
																	class_probabilities_map
																		;nominals are enumerated, if there happens to be a class value of .nas it will be enumerated in the map and
																		;treated like any other string.  Must use lambda in filter specifically to filter out .nas indices.
																		(filter
																			(lambda
																				(!=
																					(current_index)
																					.nas
																				)
																			)
																			(call
																				ComputeModelNominalClassProbabilities
																				(assoc
																					feature feature
																				)
																			)
																		)
																)
															)
														)

														;output random class based on probability, doesn't contain nulls, non string nominals should be output as numeric
														(if
															(contains_index
																nonStringNominalFeaturesMap
																feature
															)
															(+
																(weighted_rand
																	class_probabilities_map
																)
															)
															(weighted_rand
																class_probabilities_map
															)
														)
													)

													;else output random class based on probabliity, nulls are allowed
													(let
														(assoc
															output_value (weighted_rand
																	class_probabilities_map
																)
														)

														;note: nulls stored as .nas, convert any .nas strings to an actual (null)
														(if
															(=
																.nas
																output_value
															)
															(null)

															;non string nominals should be output as numeric
															(if
																(contains_index
																	nonStringNominalFeaturesMap
																	feature
																)
																(+
																	output_value
																)
																output_value
															)
														)
													)
												)
											)

											;else use laplace distribution around the action_value to generate the new action value if that value isn't null
											; AV = reaction feature value
											; B = feature residual
											; R = rand(1) - 0.5
											; F-value = AV - B (sign(R)) * ln(1 - 2 * abs(R))
											(if
												(=
													action_value
													(null)
												)
												(null)

												;else
												(let
													(assoc
														R (-
																(rand)
																0.5
															)
													)
													(declare
														(assoc
															ln_const (log
																	(-
																		1
																		(*
																			2
																			(abs
																				R
																			)
																		)
																	)
																)
														)
													)

													;there is no sign opcode in amalgam, so just add or subtract based on sign of R
													(if
														(>
															R
															0
														)
														(-
															action_value
															(*
																feature_residual
																ln_const
																(/
																	1
																	desired_conviction
																)
															)
														)
														(<
															R
															0
														)
														(+
															action_value
															(*
																feature_residual
																ln_const
																(/
																	1
																	desired_conviction
																)
															)
														)

														;else keep the action value as-is
														action_value
													)
												)
											)
										)
									)

									;calculate the expected value for a feature, using caching as appropriate (which is cleared when train is called)
									; for nominal features returns the feature value with the most occurences
									; for continuous features, returns the average value
									;parameters:
									; feature : the feature for which to calculate the expected value
									; output_nominal_class_counts : optional flag, if true will output the nominal feature count map instead of the max count value
									; case_ids : optional list of case ids from which to consider expected values, if not specified uses all cases in the model
									;            when caseids are passed in, that means the expected value is for a local model, which will never be cached
									; output_instead_of_store : flag, if set to true will output the computed expected values and counts assoc instead of storing into model
									##CalculateFeatureExpectedValue
									(declare
										(assoc
											output_nominal_class_counts (false)
											output_instead_of_store (false)
											feature (null)
											case_ids (null)
										)

										;only use and store cached values when this method is called on the whole model (whole model wouldn't have case_ids specified)
										(declare
											(assoc
												use_and_store_cached_value (=
														(null)
														case_ids
													)
												query_weight_feature (if
														(or

															;make sure that the query weight feature is null if weight feature is not valid
															(not

																;weight feature is valid if it's custom (not .case_weight) or hasPopulatedCaseWeight
																(or
																	hasPopulatedCaseWeight
																	(!=
																		weight_feature
																		".case_weight"
																	)
																)
															)
															(=
																".none"
																weight_feature
															)
														)
														(null)
														weight_feature
													)
											)
										)
										(declare
											(assoc
												weight_feature_key (if
														(=
															(null)
															weight_feature
														)
														".none"
														weight_feature
													)
											)
										)

										;pull from cache if possible
										(if
											(and
												use_and_store_cached_value
												(contains_index
													expectedValuesMap
													(list
														weight_feature_key
														feature
													)
												)
											)

											;nominal features cache both the class_counts and the expected value
											;wheras continuous just cache the value
											(let
												(assoc
													cached_values (if
															output_nominal_class_counts
															(get
																expectedValuesMap
																(list
																	weight_feature_key
																	feature
																	"class_counts"
																)
															)
															(contains_index
																nominalsSet
																feature
															)
															(get
																expectedValuesMap
																(list
																	weight_feature_key
																	feature
																	"expected_value"
																)
															)

															;continuous feature, return the cached expected value
															(get
																expectedValuesMap
																(list
																	weight_feature_key
																	feature
																	"expected_value"
																)
															)
														)
												)

												;if cached values exist, return them, else need to compute and cache them below
												(if
													(!=
														(null)
														cached_values
													)
													(conclude
														cached_values
													)
												)
											)
										)

										;case ids may be explicitly passed in as nulls from ComputeModelNominalClassProbabilities, in which case overwrite with AllCases
										(if
											(= (null) case_ids)
											(assign
												(assoc
													case_ids (call
															AllCases
														)
												)
											)
										)

										;if feature is nominal, the expected value is the feature value that has the most instances for this feature
										(if
											(or
												output_nominal_class_counts
												(contains_index
													nominalsSet
													feature
												)
											)
											(let

												;assoc of feature value -> how many times it's encountered
												(assoc
													feature_null_count (compute_on_contained_entities
															(list
																(query_in_entity_list
																	case_ids
																)
																(query_equals
																	feature
																	(null)
																)
																(query_count)
															)
														)
													feature_mode (null)
													feature_value_count_map (compute_on_contained_entities
															(list
																(query_in_entity_list
																	case_ids
																)
																(query_value_masses
																	feature
																	query_weight_feature
																	(contains_index
																		nonStringNominalFeaturesMap
																		feature
																	)
																)
															)
														)
												)

												;store count of nulls as .nas into the map
												(if
													feature_null_count
													(accum
														(assoc
															feature_value_count_map (assoc
																	.nas feature_null_count
																)
														)
													)
												)

												;store the value into cache if needed, specifically every time this method is called on the whole model,
												;we calculate and store into cache the expected value for this feature
												;note, this cache will be cleared out any time a new case is trained into or removed from the model
												(if
													use_and_store_cached_value
													(seq
														(assign
															(assoc
																feature_mode (compute_on_contained_entities
																		(list
																			(query_in_entity_list
																				case_ids
																			)
																			(query_mode
																				feature
																				query_weight_feature
																				(contains_index
																					nonStringNominalFeaturesMap
																					feature
																				)
																			)
																		)
																	)
															)
														)
														(if
															(not
																output_instead_of_store
															)
															(assign_to_entities
																(assoc
																	expectedValuesMap (set
																			expectedValuesMap
																			(list
																				weight_feature_key
																				feature
																			)
																			(assoc
																				class_counts feature_value_count_map
																				expected_value feature_mode
																			)
																		)
																)
															)
														)
													)
												)
												(if
													output_instead_of_store
													(conclude
														(assoc
															class_counts feature_value_count_map
															expected_value feature_mode
														)
													)
												)

												;if the output is just the counts of each nominal class, then output that map
												(if
													output_nominal_class_counts
													feature_value_count_map

													;else, figure out which nominal value has the highest count and output that one as the expected
													(if
														(=
															(null)
															feature_mode
														)
														(compute_on_contained_entities
															(list
																(query_in_entity_list
																	case_ids
																)
																(query_mode
																	feature
																	query_weight_feature
																	(contains_index
																		nonStringNominalFeaturesMap
																		feature
																	)
																)
															)
														)

														;else output the feature value with the max count that was already already calculated above
														feature_mode
													)
												)
											)

											;else feature is continuous, take the average of all the encountered values
											(let
												(assoc
													avg_feature_value (compute_on_contained_entities
															(list
																(query_in_entity_list
																	case_ids
																)
																(query_not_equals
																	feature
																	(null)
																)

																;calculate arithmetic average
																(query_generalized_mean
																	feature
																	1
																	query_weight_feature
																)
															)
														)
												)

												;value maybe .nan if model is empty, prevent output by converting to null
												(if
													(=
														avg_feature_value
														.nan
													)
													(assign
														(assoc
															avg_feature_value (null)
														)
													)
												)
												(if
													output_instead_of_store
													(conclude
														(assoc
															expected_value avg_feature_value
														)
													)
												)

												;store the value into cache if needed
												(if
													use_and_store_cached_value
													(assign_to_entities
														(assoc
															expectedValuesMap (set
																	expectedValuesMap
																	(list
																		weight_feature_key
																		feature
																	)
																	(assoc
																		expected_value avg_feature_value
																	)
																)
														)
													)
												)
												avg_feature_value
											)
										)
									)

									;blend nominal class probabilities according to the desired conviction, using the feature_residual and categorical action probabilities
									;
									; local class probablities correspond to a desired conviction = 1.
									;
									; desired conviction >= 1:
									; global class probabilities are used instead of local ones with a probability of (feature_residual / desired_conviction)
									;
									; example for a local model where all classes have a non-0 probability:
									;
									; 	 0	 0.5883	 1		inf
									; 	--------------------------
									; A* 0	 0		.5		.5
									; B	 0	 0		.25	   	.25
									; C .5	.5		.125	.125
									; D	.5	.5		.125	.125
									;
									; infinite conviction:
									; to mantain distributions probablities don't change for higher convictions
									;
									;
									; desired conviction < 1:
									;
									; 0 conviction probability:
									; step1 = (entropy (list .5 .25 .125 .125)) = 1.2130075659799042
									; step2 = -ln of lowest probability, -ln(.125) = 2.0794415416798357
									; step3 = step1/step2 ~ .5833 <- lowest conviction bound, can't go lower.
									; all non-lowest classes have lowest probabilities of 0, all lowest are 1/N where N is the count of 'all lowest'
									;
									; for models where there are classes with 0 probability:
									;
									;  	 0		1		inf
									; 	--------------------------
									; A* 0		.5		.5
									; B	 0		.25	   	.25
									; C	 0		.125	.125
									; D	 0		.125	.125
									; E	.333	 0		0
									; F	.333	 0		0
									; G	.333	 0		0
									;
									; 0 conviction:
									; all non-0 probability classes have a 0 probability
									; all 0-probability classes have a 1/N probability where N is the count of all '0-probability' classes
									;
									; the probability of each class is linearly interpolated based on the conviction value and that clasess's corresponding probability
									;
									; outputs a map of class value and its blended probability
									;
									;parameters:
									;	feature : nominal feature name
									;	desired_conviction : desired conviction value
									;	local_class_probabilities_map : assoc of local class -> probability for a given prediction
									;	action_value : the selected action value
									;	allowed_values : optional list of allowed class values (boundaries)
									;	feature_residual: residual for the nominal feature
									;	allow_nulls : flag, if set to true will allow null to be generated as a valid feature value
									##BlendNominalClassProbabilities
									(declare
										(assoc
											local_class_probabilities_map (assoc)
											allow_nulls (true)
											feature (null)
											action_value (null)
											allowed_values (null)
											desired_conviction 1
										)
										(declare
											(assoc
												global_class_probabilities_map (call
														ComputeModelNominalClassProbabilities
														(assoc
															feature feature
														)
													)
											)
										)
										(if
											(>= desired_conviction 1)

											;if rand < (residual / desired_conviction) , overwrite local probabilities with global or domain ones
											;do not ovewrite for dependent features because the user has explicitly defined this feature to be dependent on another one in the local model
											(if
												(and
													(not
														action_feature_is_dependent
													)
													(<
														(rand)
														(/
															feature_residual
															desired_conviction
														)
													)
												)

												;use domain probabilities with a 1 / num_classes if the dataset is too small or using same probability WRT feature_residual
												(if
													(or
														(<
															(rand)
															(/
																feature_residual
																desired_conviction
															)
														)
														(<
															(call
																GetNumTrainingCases
															)
															(max
																30
																(get
																	hyperparam_map
																	"k"
																)
															)
														)
													)
													(assign
														(assoc
															local_class_probabilities_map (zip
																	(indices
																		global_class_probabilities_map
																	)
																	(/
																		1
																		(size
																			global_class_probabilities_map
																		)
																	)
																)
														)
													)

													;use global probabilities
													(assign
														(assoc
															local_class_probabilities_map global_class_probabilities_map
														)
													)
												)
											)
										)

										;if the case generation starts with a norminal value that's specified by user, there are no local probabilities since there was no
										;react to get them, so set them to global ones for this initial value
										(if
											(=
												0
												(size local_class_probabilities_map)
											)
											(assign
												(assoc
													local_class_probabilities_map global_class_probabilities_map
												)
											)

											;else set all probablities of classes that aren't in the local map to be 0 for low desired conviction, except when generating dependents
											(and
												(<
													desired_conviction
													1
												)
												(not action_feature_is_dependent)
											)
											(assign
												(assoc
													local_class_probabilities_map (map
															(lambda
																(if
																	(contains_index
																		local_class_probabilities_map
																		(current_index)
																	)
																	(get
																		local_class_probabilities_map
																		(current_index)
																	)
																	0
																)
															)
															global_class_probabilities_map
														)
												)
											)
										)
										(if
											(= (false) allow_nulls)
											(assign
												(assoc
													local_class_probabilities_map (filter
															(lambda
																(!=
																	(current_index)
																	.nas
																)
															)
															local_class_probabilities_map
														)
												)
											)
										)

										;if allowed list is specified, filter out any values that aren't on the allowed list
										(if
											(and
												(!=
													(null)
													allowed_values
												)
												(>
													(size
														allowed_values
													)
													0
												)
											)

											;set probabilities to 0 for those classes in the map that are not on the allowed list
											(assign
												(assoc
													local_class_probabilities_map (map
															(lambda
																(if
																	(contains_index
																		local_class_probabilities_map
																		(current_index)
																	)
																	(get
																		local_class_probabilities_map
																		(current_index)
																	)
																	0
																)
															)
															(zip
																allowed_values
															)
														)
												)
											)
										)

										;create an interpolated probabilities map that's interpolated between local and global based on desired_conviction, where
										;desired_conviction >=1 is local probabilities, 0=all classes except action_value are 1/N (uniform)
										(declare
											(assoc
												residual_blended_probabilities_map (if
														(>=
															desired_conviction
															1
														)
														local_class_probabilities_map

														;else desired_conviction < 1
														(let
															(assoc
																local_model_has_zero_probability_classes (contains_value
																		(values
																			local_class_probabilities_map
																		)
																		0
																	)
															)

															;lowest conviction boundary is 0, and therefore lowest probabliity for all non-zero classes is 0
															(if
																local_model_has_zero_probability_classes
																(let
																	(assoc
																		zero_probability_classes_map (filter
																				(lambda
																					(=
																						(current_value)
																						0
																					)
																				)
																				local_class_probabilities_map
																			)
																	)
																	(map
																		(lambda
																			(let
																				(assoc
																					zero_prob_class_zero_conv_probability_value (/
																							1
																							(size
																								zero_probability_classes_map
																							)
																						)
																				)
																				(if
																					(not
																						(contains_index
																							zero_probability_classes_map
																							(get_value
																								(current_index)
																							)
																						)
																					)

																					;the selected probability has a zero conviction probability value of 0, so just scale it directly
																					(*
																						(current_value)
																						desired_conviction
																					)

																					;probability for classes that had 0 probability approaches 0 as desired_conviction approaches 1
																					;and approaches zero_prob_class_zero_conv_probability_value as desired_conviction approaches 0
																					(-
																						zero_prob_class_zero_conv_probability_value
																						(*
																							zero_prob_class_zero_conv_probability_value
																							desired_conviction
																						)
																					)
																				)
																			)
																		)
																		local_class_probabilities_map
																	)
																)

																;else compute entropy to calculate the lowest conviction bound
																(let
																	(assoc
																		lowest_probability (apply
																				"min"
																				(values
																					local_class_probabilities_map
																				)
																			)
																		entropy_of_local_probabilities (entropy
																				(values
																					local_class_probabilities_map
																				)
																			)
																	)
																	(declare
																		(assoc
																			lowest_probability_classes_map (filter
																					(lambda
																						(=
																							(current_value)
																							lowest_probability
																						)
																					)
																					local_class_probabilities_map
																				)
																			lowest_conviction_boundary
																				;entropy is zero if there's only one class in the local probabilities. then just set the boundary
																				;to 1 to just output the probability of this one class
																				(if
																					(=
																						0
																						entropy_of_local_probabilities
																					)
																					1
																					(/
																						entropy_of_local_probabilities
																						(-
																							(log
																								lowest_probability
																							)
																						)
																					)
																				)
																		)
																	)
																	(map
																		(lambda
																			(let
																				(assoc
																					boundary_probability (/
																							1
																							(size
																								lowest_probability_classes_map
																							)
																						)
																				)
																				(if
																					(<=
																						desired_conviction
																						lowest_conviction_boundary
																					)
																					(if
																						(contains_index
																							lowest_probability_classes_map
																							(get_value
																								(current_index)
																							)
																						)
																						boundary_probability
																						0
																					)

																					;else need to linearly interpolate between lowest_conviction_boundary and 1
																					(let
																						(assoc
																							inverted_one_to_boundary_conviction_value (/
																									(-
																										1
																										desired_conviction
																									)
																									(-
																										1
																										lowest_conviction_boundary
																									)
																								)
																						)
																						(if
																							(contains_index
																								lowest_probability_classes_map
																								(get_value
																									(current_index)
																								)
																							)

																							;lowest probability classes increase their probability as they approach boundary_probability
																							;original_low_prob + (boundary_probability - original_low_prob) * inverted_conv_value
																							(+
																								(current_value)
																								(*
																									(-
																										boundary_probability
																										(current_value)
																									)
																									inverted_one_to_boundary_conviction_value
																								)
																							)

																							;original_prob - original_prob * inverted_conv_value
																							(-
																								(current_value)
																								(*
																									(current_value)
																									inverted_one_to_boundary_conviction_value
																								)
																							)
																						)
																					)
																				)
																			)
																		)
																		local_class_probabilities_map
																	)
																)
															)
														)
													)
											)
										)
										(declare
											(assoc
												total_prob_values (apply
														"+"
														(values
															residual_blended_probabilities_map
														)
													)
											)
										)

										;in the case of no probabilities, assign even probabilities to all
										(if
											(= 0 total_prob_values)
											(map
												(lambda
													(/
														1
														(size
															residual_blended_probabilities_map
														)
													)
												)
												residual_blended_probabilities_map
											)

											;output normalized probabilities that all add up to 1
											(map
												(lambda
													(/
														(current_value)
														total_prob_values
													)
												)
												residual_blended_probabilities_map
											)
										)
									)

									;compute and return class probabilities (distribution of feature values) for a specified nominal feature.
									;note: allowed classes will be given an observation of 1, as being allowed counts as an observation
									; toward the counts used for the probabilities
									;
									;parameters:
									; feature : name of feature
									; case_ids : optional list of case ids from which to consider expected values, if not specified uses all cases in the model
									; store_global_probabilities : flag, will default to storing computed global nominal probabilities. if false, will only output them
									##ComputeModelNominalClassProbabilities
									(declare
										(assoc
											feature (null)
											case_ids (null)
											nominal_class_probabilities_map (null)
											store_global_probabilities (true)
										)
										(declare
											(assoc
												weight_feature_key (if
														(=
															(null)
															weight_feature
														)
														".none"
														weight_feature
													)
											)
										)

										;if the probabilities are not cached, compute and cache them
										;or if a local/regional model is specified via case_ids
										(if
											(or
												(!=
													(null)
													case_ids
												)
												(not
													(contains_index
														nominalClassProbabilitiesMap
														(list
															weight_feature_key
															feature
														)
													)
												)
											)
											(let
												(assoc
													nominal_class_weight_map (call
															CalculateFeatureExpectedValue
															(assoc
																output_nominal_class_counts (true)
																feature feature
																case_ids case_ids
															)
														)
												)

												;when computing for the whole model, if there are globally allowed values for this features that haven't
												;been trained yet add them to the list of class counts with a count of '1'.
												(if
													(and
														(=
															(null)
															case_ids
														)
														(>
															(size
																(get
																	featureBoundsMap
																	(list
																		feature
																		"allowed"
																	)
																)
															)
															(size
																nominal_class_weight_map
															)
														)
													)
													(let
														(assoc
															allowed_classes_map (zip
																	(get
																		featureBoundsMap
																		(list
																			feature
																			"allowed"
																		)
																	)
																	1
																)
														)

														;add the allowed observation to nominal_class_weight_map
														(assign
															(assoc
																nominal_class_weight_map (map
																		(lambda
																			(+
																				(or
																					(first
																						(current_value)
																					)
																				)
																				(or
																					(last
																						(current_value)
																					)
																				)
																			)
																		)
																		allowed_classes_map
																		nominal_class_weight_map
																	)
															)
														)
													)
												)
												(declare
													(assoc
														total_weight (apply
																"+"
																(values
																	nominal_class_weight_map
																)
															)
													)
												)

												;output the normalized counts of each class by converting them to probabilities
												(assign
													(assoc
														nominal_class_probabilities_map (map
																(lambda
																	(/
																		(current_value)
																		total_weight
																	)
																)
																nominal_class_weight_map
															)
													)
												)

												;only cache probabilities for the global model, meaning no local/regional case_ids were specified
												(if
													(and
														(=
															(null)
															case_ids
														)
														store_global_probabilities
													)
													(assign_to_entities
														(assoc
															nominalClassProbabilitiesMap (set
																	nominalClassProbabilitiesMap
																	(list
																		weight_feature_key
																		feature
																	)
																	nominal_class_probabilities_map
																)
														)
													)
												)
											)
										)

										;output probabilities for the specified feature
										(if
											(and
												(=
													(null)
													case_ids
												)
												store_global_probabilities
											)
											(get
												nominalClassProbabilitiesMap
												(list
													weight_feature_key
													feature
												)
											)

											;else
											nominal_class_probabilities_map
										)
									)

									;React to the provided context, querying the local region if necessary, outputting the local/regional cases and local probabilities
									; For nominal action features: outputs the action_value and the local categorical probabilities
									; For continuous action features: outputs the list of local case ids and the local model with normalized influence weights, additionally
									; outputs the regional model case ids if approximating the residual.
									;
									; action_feature : feature that is being generated
									; context_features : list of context features for the react
									; context_values : list of context values to use in the react
									; feature_is_nominal : flag, set to true if action_feature is nominal
									; allow_nulls : flag, if set to true, cases where the action_feature is null will be considered
									; hyperparam_map: optional assoc of hyperparameters to use (instead of system-determined ones)
									; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
									; valid_weight_feature : flag, set to true if the provided weight_feature should be used to scale the results
									; approximate_residual : flag, set to true if approximating RMR and action feature is continuous
									; ignore_case : optional, case id of case to ignore during the react
									##NearestRegionReact
									(declare
										(assoc
											valid_weight_feature (false)
											allow_nulls (true)
											ignore_case (null)
											context_values (list)
											weight_feature ".case_weight"
											approximate_residual (true)
											action_feature (null)
											feature_is_nominal (false)
											hyperparam_map (null)
											context_features (list)
										)
										(if
											(= (null) hyperparam_map)
											(assign
												(assoc
													hyperparam_map (call
															GetHyperparameters
															(assoc
																weight_feature weight_feature
																feature action_feature
																mode "robust"
															)
														)
												)
											)
										)
										(declare
											(assoc
												dependent_queries_list (if
														action_feature_is_dependent
														(call
															ComputeDependentQueries
															(assoc
																context_values context_values
																action_feature action_feature
																context_features context_features
															)
														)
														(list)
													)
												local_k (get
														hyperparam_map
														"k"
													)
												local_case_ids (list)
												regional_case_ids (list)
											)
										)
										(declare
											(assoc
												local_model_cases_tuple ##!NearestRegionalCasesQuery
													(compute_on_contained_entities
														(append

															;if ignoring null action feature, query for cases where action feature is not null
															(if
																(not
																	allow_nulls
																)
																(query_not_equals
																	action_feature
																	(null)
																)
																(list)
															)
															(if
																ignore_case
																(query_not_in_entity_list
																	(list
																		ignore_case
																	)
																)
																(list)
															)
															dependent_queries_list
															(query_nearest_generalized_distance
																(if
																	approximate_residual

																	;regional is a max of e * k and 30
																	(max
																		(*
																			2.718281828459045
																			local_k
																		)
																		30
																	)
																	local_k
																)
																context_features
																context_values
																(get
																	hyperparam_map
																	"featureWeights"
																)
																nominalClassCountsMap
																cyclicFeaturesMap
																(if
																	(get
																		hyperparam_map
																		"useDeviations"
																	)
																	(get
																		hyperparam_map
																		"featureDeviations"
																	)
																)
																(get
																	hyperparam_map
																	"p"
																)
																(get
																	hyperparam_map
																	"dwe"
																)
																(if
																	valid_weight_feature
																	weight_feature
																	(null)
																)
																(rand)
																(null)

																;radius
																lpSpaceHeuristicMultiplier
																(true)
																(true)
															)
														)
													)
											)
										)

										;if local_model_cases_tuple is too small to be viable, then remove dependent feature queries and recompute
										;local_model_cases_tuple until sufficiently many cases are returned
										(if
											action_feature_is_dependent
											(if
												action_feature_is_dependent_and_continuous

												;continuous values should have at least 3 values for privacy
												(while
													(and
														(<
															(size
																(first
																	local_model_cases_tuple
																)
															)
															3
														)
														(>
															(size
																dependent_queries_list
															)
															0
														)
													)
													(assign
														(assoc
															dependent_queries_list (trunc
																	dependent_queries_list
																)
														)
													)
													(assign
														(assoc
															local_model_cases_tuple (call
																	!NearestRegionalCasesQuery
																)
														)
													)
												)

												;nominals need to have at least one value
												(while
													(and
														(=
															(size
																(first
																	local_model_cases_tuple
																)
															)
															0
														)
														(>
															(size
																dependent_queries_list
															)
															0
														)
													)
													(assign
														(assoc
															dependent_queries_list (trunc
																	dependent_queries_list
																)
														)
													)
													(assign
														(assoc
															local_model_cases_tuple (call
																	!NearestRegionalCasesQuery
																)
														)
													)
												)
											)
										)
										(declare
											(assoc local_model_cases_map (assoc))
										)

										;if approximating regional residual for continuous, need to truncate the regional model to output probabilities for local only
										(if
											approximate_residual
											(seq
												(assign
													(assoc
														regional_case_ids (first
																local_model_cases_tuple
															)
													)
												)

												;keep only the local k closest case ids
												(assign
													(assoc
														local_case_ids (trunc
																regional_case_ids
																local_k
															)
													)
												)

												;keep only the local k cases in the map
												(assign
													(assoc
														local_model_cases_map (zip
																local_case_ids
																(trunc
																	(last
																		local_model_cases_tuple
																	)
																	local_k
																)
															)
													)
												)
											)

											;else the local case_ids are the same as the indices of local model map
											(assign
												(assoc
													local_model_cases_map (apply
															"zip"
															local_model_cases_tuple
														)
													local_case_ids (first
															local_model_cases_tuple
														)
												)
											)
										)
										(declare
											(assoc
												local_cases_total_weight (apply
														"+"
														(values
															local_model_cases_map
														)
													)
											)
										)

										;normalize the weights in the local model
										(assign
											(assoc
												local_model_cases_map
													;if has perfect matches, set their weight to 1, others to 0
													(if
														(=
															.infinity
															local_cases_total_weight
														)
														(map
															(lambda
																(if
																	(=
																		.infinity
																		(current_value)
																	)
																	1
																	0
																)
															)
															local_model_cases_map
														)

														;else just scale the weights
														(map
															(lambda
																(/
																	(current_value)
																	local_cases_total_weight
																)
															)
															local_model_cases_map
														)
													)
											)
										)

										;compute categorical action probabilities for nominal features
										(if
											feature_is_nominal
											(let
												(assoc
													action_value (null)
													categorical_value_weights_map (assoc)
												)
												(if
													(=
														.infinity
														local_cases_total_weight
													)
													(let
														(assoc
															neighbor_id_to_values_map (map
																	(lambda
																		(retrieve_from_entity
																			(current_index)
																			action_feature
																		)
																	)

																	;only consider perfect match neighbors by filtering out those with a weight of 0
																	(filter
																		(lambda
																			(=
																				1
																				(current_value)
																			)
																		)
																		local_model_cases_map
																	)
																)
														)

														;since these are perfect matches, they all have equal weight
														(declare
															(assoc
																value_weight (/
																		1
																		(size
																			neighbor_id_to_values_map
																		)
																	)
															)
														)

														;iterate over all the nearby cases, to create the mapping between each categorical action value and its summed
														;weight for this categorical feature.  for each unique categorical value in all the neighbors, sum up its weight
														(assign
															(assoc
																categorical_value_weights_map (zip
																		(lambda
																			(+
																				(current_value
																					1
																				)
																				(current_value)
																			)
																		)
																		(values
																			neighbor_id_to_values_map
																		)
																		value_weight
																	)
															)
														)
													)

													;else iterate over all the nearby cases, to create the mapping between each categorical action value and its summed
													;weight for this categorical feature.  for each unique categorical value in all the neighbors, sum up its weight
													(assign
														(assoc
															categorical_value_weights_map (zip
																	(lambda
																		(+
																			(current_value
																				1
																			)
																			(current_value)
																		)
																	)

																	;feature value for each case
																	(map
																		(lambda
																			(retrieve_from_entity
																				(current_value)
																				action_feature
																			)
																		)
																		(indices
																			local_model_cases_map
																		)
																	)

																	;weights of corresponding case
																	(values
																		local_model_cases_map
																	)
																)
														)
													)
												)

												;sort the assoc of discrete values by their weights from high to low
												;returns the first (highest weighted) categorical value
												(assign
													(assoc
														action_value (first
																(sort
																	(lambda
																		(>
																			(get
																				categorical_value_weights_map
																				(current_value
																					1
																				)
																			)
																			(get
																				categorical_value_weights_map
																				(current_value)
																			)
																		)
																	)
																	(indices
																		categorical_value_weights_map
																	)
																)
															)
													)
												)

												;parse the categorical neighbor value to handle the situation where the value is the string .nas
												;and convert it to an actual (null), all other numerical or string literals will remain unchanged
												(if
													(=
														.nas
														action_value
													)
													(assign
														(assoc
															action_value (null)
														)
													)
												)

												;categorical action feature output
												(assoc
													action_value action_value
													categorical_value_weights_map categorical_value_weights_map
												)
											)

											;else continuous action feature output
											(assoc
												local_model_cases_map local_model_cases_map
												local_case_ids local_case_ids
												regional_case_ids regional_case_ids
											)
										)
									)

									;if after failing to generate a valid value and having to pick a random value within a feature range, when
									;picking for a continuous dependent, select from a limited range by looking up all the possible bounds
									;given nominal dependent features in the contexts. If there are no nominal contexts, just use the default bounds.
									##GetRandomWithinBoundariesForContinuousDependent
									(let
										(assoc
											context_map (zip
													context_features
													context_values
												)
											boundary_pairs (list)
											nominals (get
													continuousDependentsMap
													feature
												)
										)

										;iterate over the list of nominal dependents for this continous feature, pulling the bounds corresponding
										;to the context values
										(map
											(lambda
												(if
													(contains_index
														context_map
														(current_value)
													)
													(let
														(assoc
															f_value (get
																	context_map
																	(current_value
																		1
																	)
																)
															f_index (get_value
																	(current_index
																		1
																	)
																)
															boundary_combos (list)
														)

														;leave only those value combinations that have this nominal context value for this nominal feature
														(assign
															(assoc
																boundary_combos (filter
																		(lambda
																			(=
																				f_value
																				(get
																					(current_value)
																					f_index
																				)
																			)
																		)
																		(get
																			dependentValuesCombinationsMap
																			feature
																		)
																	)
															)
														)

														;pull all the defined boundaries for this nominal feature value
														(accum
															(assoc
																boundary_pairs (map
																		(lambda
																			(get
																				dependentsBoundaryMap
																				(append
																					feature
																					(current_value)
																				)
																			)
																		)
																		boundary_combos
																	)
															)
														)
													)
												)
											)
											nominals
										)

										;if there's just the one boundary pair, output it as-is
										(if
											(=
												1
												(size boundary_pairs)
											)
											(+
												(first boundary_pairs)
												(rand
													(-
														(last
															boundary_pairs
														)
														(first
															boundary_pairs
														)
													)
												)
											)

											;else no bounds defined, output default feature boundary random value
											(=
												0
												(size boundary_pairs)
											)
											(+
												boundary_min
												(rand
													(-
														boundary_max
														boundary_min
													)
												)
											)

											;else need to output the largest min and the smallest max if min < max of all the boundary pairs
											(let
												(assoc
													min boundary_min
													max boundary_max
												)
												(map
													(lambda
														(seq
															(if
																(>
																	(first
																		(current_value)
																	)
																	min
																)
																(assign
																	(assoc
																		min (first
																				(current_value
																					1
																				)
																			)
																	)
																)
															)
															(if
																(<
																	(last
																		(current_value)
																	)
																	max
																)
																(assign
																	(assoc
																		max (last
																				(current_value
																					1
																				)
																			)
																	)
																)
															)
														)
													)
													boundary_pairs
												)
												(if
													(<
														min
														max
													)
													(+
														min
														(rand
															(-
																max
																min
															)
														)
													)

													;else min is more than max, output default feature boundary random value
													(+
														boundary_min
														(rand
															(-
																boundary_max
																boundary_min
															)
														)
													)
												)
											)
										)
									)
								)

								;module for trainee_template
								;contains method to derive and/or create features or feature values as defined by feature attributes
								(null

									;Derived during train features should have a feature attribute of 'auto_derive_on_train', an asoc defining how to derive the feature with the
									; following attributes:
									;
									;   derive_type: string attribute defining the type of derivation, one of 'custom', 'start', 'end'.  Each derive_type has its own attribute set.
									;
									;	   'derive_type' : "custom" -
									;		   This feature is derived using the specified 'code'. For each series, where each series is defined by "series_id_features",
									;		   the rows are processed in order, after being sorted by "ordered_by_features". If series is not specified, processes the entire
									;		   dataset. Referencing data in rows uses 0-based indexing, where the current row index is 0, the previous row's is 1, etc.
									;		   Specified code may do simple logic and numeric operations on feature values referenced via feature name and row offset.
									;		   Examples:
									;			   "#x 1" - Use the value for feature 'x' from the previously processed row (offset of 1, one lag value).
									;			   "(- #y 0 #x 1)" - Feature 'y' value from current (offset 0) row  minus feature 'x' value from previous (offest 1) row.
									;	   'code': string, Code describing how feature could be derived. Example: "(- #y 0 #x 1)"
									;	   'series_id_features' : (optional) list of feature name(s) of series for which to derive this feature. A series is the conjunction of all
									;		   the features specified by this attribute.
									;	   'ordered_by_features' : (optional) list of fature name(s) by which to order the series specified by "series_id_features". Series values
									;		   are order by the order of feature names specified by this attribute.
									;
									;
									;	   'derive_type' : "start" -
									;		   This will create a nominal feature with the value set to 'false' for all cases except those where the time value of
									;		   "start_time_feature" is smallest (earliest) for each series, where each series is defined by "start_id_features".
									;		   These 'first in each series' cases will have their value set to 'true'.
									;	   'start_time_feature' :  string, feature name of the series id's time feature to find the start time entry.
									;	   'start_id_features' :  list, feature name(s) of series for which to derive this start feature. A series is the conjunction of all the
									;		   features specified by this attribute.
									;
									;
									;	   'derive_type" : "end" -
									;		   This will create a nominal feature with the value set to 'false' for all cases except those where the time value of
									;		   "end_time_feature" is largest (latest) for each series, where each series is defined by "end_id_features".
									;		   These 'last in each series' cases will have their value set to 'true'.
									;	   'end_time_feature' : string, feature name of the series id's time feature to find the end time entry.
									;	   'end_id_features' : list, feature name(s) of series for which to derive this end feature. A series is the conjunction of all the features
									;		   specified by this attribute.
									;At the end of train, derive features using the existing model, provided a list of features to derive. Creates and populates the specified
									;features to the model.
									;
									;parameters:
									; features: list of features the dataset was trained with originally
									; derived_features: list of features to derive, in the specified order.
									##DeriveTrainFeatures
									(declare
										(assoc
											derived_features (list)
											cases_derive_imputed_map (assoc)
											features (list)
										)
										(map
											(lambda
												(let
													(assoc
														feature (current_value
																1
															)
														feature_attribute_map (get
																featureAttributes
																(list
																	(current_value
																		2
																	)
																	"auto_derive_on_train"
																)
															)
													)
													(if

														;code-based derived feature
														(=
															"custom"
															(get
																feature_attribute_map
																"derive_type"
															)
														)
														(call
															DeriveCustomFeatureFromCode
															(assoc
																series_id_features (get
																		feature_attribute_map
																		"series_id_features"
																	)
																series_ordered_by_features (get
																		feature_attribute_map
																		"ordered_by_features"
																	)
																feature feature
																features features
																raw_code_string (get
																		feature_attribute_map
																		"code"
																	)
															)
														)

														;create end-time feature
														(=
															"end"
															(get
																feature_attribute_map
																"derive_type"
															)
														)
														(call
															CreateStartEndSeriesFeature
															(assoc
																series_id_features (get
																		feature_attribute_map
																		"end_id_features"
																	)
																feature feature
																start (false)
																series_time_feature (get
																		feature_attribute_map
																		"end_time_feature"
																	)
															)
														)

														;create start-time feature
														(=
															"start"
															(get
																feature_attribute_map
																"derive_type"
															)
														)
														(call
															CreateStartEndSeriesFeature
															(assoc
																series_id_features (get
																		feature_attribute_map
																		"start_id_features"
																	)
																feature feature
																start (true)
																series_time_feature (get
																		feature_attribute_map
																		"start_time_feature"
																	)
															)
														)

														;else derivation method isn't specified, create the feature with all nulls if the feature is defined in featureAttributes
														(size
															feature_attribute_map
														)
														(call
															StoreCaseValues
															(assoc
																case_values_map (zip
																		(call
																			AllCases
																		)
																	)
																overwrite (true)
																label_name feature
															)
														)
													)
												)
											)
											derived_features
										)
									)

									;creates a nominal start or end time feature for a specified series_id using the specified series_time to determine start and end
									;
									;parameters:
									; feature: name of feature to add and populate
									; series_id_features: list of feature names that specify the series id for which to derive this feature.
									;	   If more than one specified, a unique 'series id' is then the conjuction of the specified ids.
									;	   E.g., if 'sender' and 'reciever' are specified, a 'series id' is then each unique pair of sender-reciever.
									; series_time_feature: name of series id's time feature which to use to determine the start or end flag
									; start: flag, if true determine the start time (smallest time value), if false determine end time (largest time value)
									##CreateStartEndSeriesFeature
									(declare
										(assoc
											series_id_features (list)
											case_values_map (zip
													(call
														AllCases
													)
													0
												)
											feature ""
											start (true)
											series_time_feature ""
										)

										;create as boolean feature here
										(assign_to_entities
											(assoc
												hasFeaturesNeedEncodingFromInput (true)
												hasBooleans (true)
												nonStringNominalFeaturesMap (append
														nonStringNominalFeaturesMap
														(associate
															feature
															"boolean"
														)
													)
												nominalsSet (append
														nominalsSet
														(associate
															feature
															(null)
														)
													)
												hasEncodedFeatures (true)
												nominalClassCountsMap (append
														nominalClassCountsMap
														(associate
															feature
															2
														)
													)
												encodingNeededFeaturesSet (append
														encodingNeededFeaturesSet
														(associate
															feature
															(null)
														)
													)
											)
										)
										(declare
											(assoc
												marked_case_ids (map
														(lambda
															(first

																;(current_value) is in the format of (list (query_equals "series_feature_name" value) ... ) for all series_feature_name
																(contained_entities
																	(append
																		(current_value)
																		(if
																			start
																			(query_min
																				series_time_feature
																			)

																			;else find end
																			(query_max
																				series_time_feature
																			)
																		)
																	)
																)
															)
														)

														;generates a list of queries for each unique series id (where each series id may be a conjuction of several features)
														(call
															GenerateUniqueSeriesQueries
															(assoc
																series_id_features series_id_features
															)
														)
													)
											)
										)

										;set the enumerated value for start cases to be 1 ("true")
										(accum
											(assoc
												case_values_map (zip
														marked_case_ids
														1
													)
											)
										)

										;add feature, setting each case's corresponding value
										(call
											StoreCaseValues
											(assoc
												case_values_map case_values_map
												overwrite (true)
												label_name feature
											)
										)
									)

									;generate and output a list of queries for each 'unique' series id, where a unique series id may be a conjuction of several features.
									; for example, if there are two series features, 'id1' and 'id2', with values of a, b, and c in each, it's possible that there may be six
									; 'unique' series, i.e., ab, ac, ba, bc, ca, cb, thus the generated output would be this:
									;		(list
									;			(list (query_equals "id1" "a") (query_equals "id2" "b"))
									;			(list (query_equals "id1" "a") (query_equals "id2" "c"))
									;			(list (query_equals "id1" "b") (query_equals "id2" "a"))
									;			(list (query_equals "id1" "b") (query_equals "id2" "c"))
									;			(list (query_equals "id1" "c") (query_equals "id2" "a"))
									;			(list (query_equals "id1" "c") (query_equals "id2" "b"))
									;		)
									;
									;parameters:
									; series_id_features: list of feature names that specify the series id for which to generate the list of queries.
									;	   If more than one specified, a unique 'series id' is then the conjuction of the specified ids.
									;	   E.g., if 'sender' and 'reciever' are specified, a 'series id' is then each unique pair of sender-reciever.
									##GenerateUniqueSeriesQueries
									(declare
										(assoc series_id_features (list))

										;if series_id_features isn't specified, return the entire dataset
										(if
											(=
												0
												(size series_id_features)
											)
											(list
												(query_exists internalLabelSession)
											)
											(=
												1
												(size series_id_features)
											)
											(let
												(assoc
													series_id_feature (first
															series_id_features
														)
												)

												;output a list of query_equals statements for each unique series id for this one series id feature
												(map
													(lambda

														;indices of assocs are strings, convert back to number if nominal feature is non-string
														(if
															(contains_index
																nonStringNominalFeaturesMap
																series_id_feature
															)
															(list
																(query_equals
																	series_id_feature
																	(+
																		(current_value
																			1
																		)
																	)
																)
															)

															;else leave id as string
															(list
																(query_equals
																	series_id_feature
																	(current_value
																		1
																	)
																)
															)
														)
													)

													;pull all values for each unique series id for this series id feature
													(indices
														(compute_on_contained_entities
															(list
																(query_value_masses
																	series_id_feature
																	(null)
																	(contains_index
																		nonStringNominalFeaturesMap
																		series_id_feature
																	)
																)
															)
														)
													)
												)
											)

											;else create a list of query_equals statements for all unique series ids (conjuctions of series ids for all the series
											;id features) and output their respective query parameters
											(map
												(lambda

													;a list of (query_equals "series_feature_name" value) for each unique conjuction
													;each item in the list if there were two series id features would look like so:
													;(list (query_equals "id1" 12345) (query_equals "id2" 800))
													(map
														(lambda

															;covnvert value back to number if feature is non-string
															(if
																(contains_index
																	nonStringNominalFeaturesMap
																	(get
																		series_id_features
																		(current_index)
																	)
																)
																(query_equals
																	(get
																		series_id_features
																		(current_index)
																	)
																	(+
																		(current_value)
																	)
																)

																;else leave id as string
																(query_equals
																	(get
																		series_id_features
																		(current_index)
																	)
																	(current_value)
																)
															)
														)
														(parse
															(current_value)
														)
													)
												)

												;unique conjuctions of feature values for all the series features in an unparsed list (string) format
												;each item in the list if there were two series id features would look like so: "(list 12345 800)"
												(indices
													(zip
														(map
															(lambda
																(unparse
																	(retrieve_from_entity
																		(current_value)
																		series_id_features
																	)
																)
															)
															(call
																AllCases
															)
														)
													)
												)
											)
										)
									)

									;Helper method to iterate over all the specified derived_features in order and derive them.  If unable to derive, will generate the value instead.
									; Updates series_data in place.
									; return true if derivation failed and series generation should stop, othewise returns false
									;
									; All parameters are passed in implicitly from the calling method except these:
									;parameters:
									; derived_features: list of feature names to derive, in the specified order
									; react_context_features: list of features name that serve as the starting context features. Each feature is appended to this list as it's derived
									;   so that it can be used in the generation of the next derived feature
									##DeriveOrGenerateFeatures
									(declare
										(assoc derivation_failed (false))
										(map
											(lambda
												(let
													(assoc
														feature (current_value
																1
															)
														valid_derivation (call
																DeriveSeriesValue
																(assoc
																	feature_index_map feature_index_map
																	derived_feature (current_value
																			2
																		)
																	series_data series_data
																	last_series_index last_series_index
																)
															)
													)

													;feature needs to be generated if it references a row that's not in the current series_data or is out of bounds
													(if
														(not
															valid_derivation
														)
														(seq

															;valid_derivation of (null) means a time feature generated a value past the max bondary, stop the series
															(if
																(=
																	(null)
																	valid_derivation
																)
																(seq
																	(assign
																		(assoc
																			derivation_failed (true)
																		)
																	)
																	(conclude)
																)
															)

															;grab the latest case values
															(assign
																(assoc
																	current_case_map (zip
																			features
																			(last
																				series_data
																			)
																		)
																)
															)

															;generate value for this feature
															(assign
																(assoc
																	react_output (call
																			React
																			(assoc
																				use_regional_model_residuals use_regional_model_residuals
																				details (null)
																				context_values (unzip
																						current_case_map
																						react_context_features
																					)
																				weight_feature weight_feature
																				action_values (null)
																				input_is_substituted input_is_substituted
																				derived_action_features (list)
																				derived_context_features (list)
																				generate_new_cases "no"
																				use_case_weights use_case_weights
																				rand_seed rand_seed
																				substitute_output substitute_output
																				preserve_feature_values preserve_feature_values
																				action_features (list
																						feature
																					)
																				desired_conviction desired_conviction
																				feature_bounds_map feature_bounds_map
																				context_features react_context_features
																				ordered_by_specified_features ordered_by_specified_features
																			)
																		)
																)
															)

															;update series_data in place, updating the last row, the column matching the feature with the value
															(assign
																"series_data"
																(list
																	last_series_index
																	(get
																		feature_index_map
																		feature
																	)
																)
																(first
																	(get
																		react_output
																		"action_values"
																	)
																)
															)
														)
													)

													;grow the context features to be used in the generativereact as each feature is derived
													(accum
														(assoc
															react_context_features feature
														)
													)
												)
											)
											derived_features
										)
										derivation_failed
									)

									;Derive feature value for the last row in series_data.
									; returns true and updates series_data in place if derived value within allowed bounds.
									; returns false without updating series_data if out derived value of bounds or it references na an invalid row offset.
									; returns (null) without updating series_data if a time feature exceeds its feature max boundary
									;
									;parameters:
									; derived_feature: feature name for which to derive value
									; feature_index_map: map of feature -> index of column in series_data corresponding to the feature
									; series_data: list of lists (a matrix) of series values, where the last list (row) is the one being updated
									; last_series_index: index of the last row in series_data
									##DeriveSeriesValue
									(declare
										(assoc
											feature_index_map (assoc)
											derived_feature (null)
											series_data (list)
											last_series_index 0
										)
										(if
											(= (null) derived_feature)
											(conclude (false))
										)

										;pull the max row lag for this derived_feature
										(declare
											(assoc
												max_row_lag (get
														featureAttributes
														(list
															derived_feature
															"max_row_lag"
														)
													)
											)
										)

										;if max value > last_series_index, this feature needs to be generated because it references a row offset
										;that isn't in this series, return false because this value can't be derived
										(if
											(> max_row_lag last_series_index)
											(conclude (false))
										)
										(declare
											(assoc
												new_feature_transform_processed (get
														featureCustomDerivedMethods
														(list
															derived_feature
															"series_react"
														)
													)
											)
										)
										(declare
											(assoc
												derived_feature_value (get_value
														(call
															new_feature_transform_processed
															(assoc
																series_row_index last_series_index
																feature_index_map feature_index_map
																series_data series_data
															)
														)
													)
											)
										)

										;replace .nan with (null).  .nan are possible for initial cases in a series since they don't have any lags
										(if
											(= .nan derived_feature_value)
											(assign
												(assoc
													derived_feature_value (null)
												)
											)
										)
										(declare
											(assoc
												valid_value (true)
												is_datetime (contains_index
														featureDateTimeMap
														derived_feature
													)
												bounds_map
													;if specific bounds were passed in, use those, else use globally specified feature bounds
													(if
														(contains_index
															feature_bounds_map
															derived_feature
														)
														(get
															feature_bounds_map
															derived_feature
														)
														(get
															featureBoundsMap
															derived_feature
														)
													)
											)
										)

										;check bounds if they are specified
										(if
											(size bounds_map)
											(seq

												;invalid if generated a null and nulls are not allowed
												(if
													(and
														(=
															(null)
															derived_feature_value
														)
														(=
															(get
																bounds_map
																"allow_null"
															)
															(false)
														)
													)
													(conclude
														(assign
															(assoc
																valid_value (false)
															)
														)
													)

													;else this is a nominal that has an allowed list, check if it's in the list
													(contains_index
														bounds_map
														"allowed"
													)
													(conclude
														(assign
															(assoc
																valid_value (contains_value
																		(get
																			bounds_map
																			"allowed"
																		)
																		derived_feature_value
																	)
															)
														)
													)
												)
												(let
													(assoc
														boundary_min (null)
														cycle_length (get
																cyclicFeaturesMap
																derived_feature
															)
														boundary_max (null)
														boundaries_tuple (null)
													)
													(assign
														(assoc
															boundaries_tuple (call
																	ConstrainBoundariesForFeature
																	(assoc
																		feature derived_feature
																		is_datetime is_datetime
																		cycle_length cycle_length
																		bounds_map bounds_map
																	)
																)
														)
													)
													(assign
														(assoc
															boundary_min (first
																	boundaries_tuple
																)
															boundary_max (last
																	boundaries_tuple
																)
														)
													)
													(assign
														(assoc
															valid_value (if
																	(and
																		cycle_length
																		(>=
																			boundary_min
																			boundary_max
																		)
																	)

																	;for cyclic, exclusionary bounds mean the value has to be less than max or more than min
																	(or
																		(<=
																			derived_feature_value
																			boundary_max
																		)
																		(>=
																			derived_feature_value
																			boundary_min
																		)
																	)

																	;normal bounds check, if bound specified, value must be either more than min or less than max, respectively
																	(and
																		(or
																			(=
																				(null)
																				boundary_min
																			)
																			(>=
																				derived_feature_value
																				boundary_min
																			)
																		)
																		(or
																			(=
																				(null)
																				boundary_max
																			)
																			(<=
																				derived_feature_value
																				boundary_max
																			)
																		)
																	)
																)
														)
													)
													(if
														(get
															featureAttributes
															(list
																derived_feature
																"time_series"
																"time_feature"
															)
														)

														;if time feature exceeds the feature boundary max, stop generating the series by setting valid_value to 0
														;instead of (false), as long as other rows exist (this isn't the first row being generated)
														(if
															(and
																(not
																	valid_value
																)
																(>
																	derived_feature_value
																	boundary_max
																)
																(>
																	(size
																		series_data
																	)
																	1
																)
															)
															(assign
																(assoc
																	valid_value (null)
																)
															)
														)
													)
												)
											)
										)

										;failed bounds check, return the invalid value
										(if
											(not valid_value)
											(conclude valid_value)
										)

										;convert epoch value back to string date
										(if
											(and
												is_datetime
												(!=
													(null)
													derived_feature_value
												)
											)
											(assign
												(assoc
													derived_feature_value (format
															derived_feature_value
															"number"
															(get
																featureDateTimeMap
																(list
																	derived_feature
																	"date_time_format"
																)
															)
															""
															(get
																featureDateTimeMap
																(list
																	derived_feature
																	"locale"
																)
															)
														)
												)
											)
										)

										;edit series_data in place, updating the last row, the column matching the derived_feature with the derived_feature_value
										(assign
											"series_data"
											(list
												last_series_index
												(get
													feature_index_map
													derived_feature
												)
											)
											derived_feature_value
										)

										;return true upon completion
										(true)
									)

									;derive new features using a custom code string and store into model
									;parameters:
									; features: list of features the dataset was trained with originally
									; feature : name of feature to create / derive
									; raw_code_string : string, code defining how the feature should be derived
									; series_id_features: list of feature names that specify the series id for which to derive this feature.
									;	   If more than one specified, a unique 'series id' is then the conjuction of the specified ids.
									;	   E.g., if 'sender' and 'reciever' are specified, a 'series id' is then each unique pair of sender-reciever.
									; series_ordered_by_features : list of features names by which to sort the series.  Multi-sorts by the specified features if several specified.
									##DeriveCustomFeatureFromCode
									(declare
										(assoc
											series_id_features (list)
											series_ordered_by_features (list)
											feature ""
											features (list)
											raw_code_string ""
										)
										(declare
											(assoc
												cases_to_impute (list)
												cycle_length (null)
												sourced_features_offsets_map (assoc)
												sourced_features (indices
														(get_all_labels
															(parse
																raw_code_string
															)
														)
													)
												unique_source_offsets_set (assoc)
												impute_nulls (=
														(false)
														(get
															featureBoundsMap
															(list
																feature
																"allow_null"
															)
														)
													)
												boundaries_tuple (null)
											)
										)

										;the features being sourced from to derive this feature are referred to as sourced features. sourced features may use different row offets.
										;continuous features cache a map of all source features and their offsets, to be used later in boundary checking.
										(if
											(not
												(contains_index
													nominalsSet
													feature
												)
											)
											(seq
												(assign
													(assoc
														cycle_length (get
																cyclicFeaturesMap
																feature
															)
														boundaries_tuple (call
																ConstrainBoundariesForFeature
																(assoc
																	feature feature
																	is_datetime (contains_index
																			featureDateTimeMap
																			feature
																		)
																	cycle_length (get
																			cyclicFeaturesMap
																			feature
																		)
																	bounds_map (get
																			featureBoundsMap
																			feature
																		)
																)
															)
													)
												)

												;To collect a mapping of all features and their offsets used to derive this feature, use rewrite to accumulate a list of offsets per feature,
												;but only bother to collect sourced feature offsets if there are bounds that may need to be checked against
												(if
													(or
														(!=
															(null)
															(first
																boundaries_tuple
															)
														)
														(!=
															(null)
															(last
																boundaries_tuple
															)
														)
													)
													(seq
														(rewrite
															(lambda
																(let
																	(assoc
																		label_name (first
																				(get_labels
																					(current_value
																						1
																					)
																				)
																			)
																		offset_value (current_value
																				1
																			)
																	)
																	(if
																		(!=
																			(null)
																			label_name
																		)
																		(accum
																			"sourced_features_offsets_map"
																			(list
																				label_name
																			)
																			(list
																				(get_value
																					offset_value
																				)
																			)
																		)
																	)
																)
															)
															(parse
																raw_code_string
															)
														)
														(assign
															(assoc
																unique_source_offsets_set (zip
																		(apply
																			"append"
																			(values
																				sourced_features_offsets_map
																			)
																		)
																	)
															)
														)
													)
												)
											)
										)

										;declare all the features that are necessary that are needed to derive this feature,
										;where the first features are the ones that need to be sorted on
										(declare
											(assoc
												boundary_min (first
														boundaries_tuple
													)
												necessary_features (append
														series_ordered_by_features

														;filter out features in sourced_features that already exist in series_ordered_by_features
														;leaving only the ones that are unique to sourced_features
														(filter
															(lambda
																(not
																	(contains_value
																		series_ordered_by_features
																		(current_value)
																	)
																)
															)
															sourced_features
														)
													)
												boundary_max (last
														boundaries_tuple
													)
											)
										)

										;process each series individually
										;pull all the values for the necessary_features, sort them, and then derive this feature based on the specified code
										(map
											(lambda
												(let

													;(current_value) is in the format of (list (query_equals "series_feature_name" value) ... ) for all series_feature_name
													(assoc
														series_case_ids (contained_entities
																(current_value
																	1
																)
															)
													)
													(declare
														(assoc
															series_data (map
																	(lambda
																		(append
																			(retrieve_from_entity
																				(current_value)
																				necessary_features
																			)
																			(current_value)
																		)
																	)
																	series_case_ids
																)
														)
													)

													;sort the series data according to the specified features if ordering has been provided
													(if
														(size
															series_ordered_by_features
														)
														(assign
															(assoc
																series_data (call
																		MultiSortList
																		(assoc
																			column_order_indices (range
																					0
																					(size
																						series_ordered_by_features
																					)
																				)
																			data series_data
																		)
																	)
															)
														)
													)

													;store the case ids in the new sorted order of series_data
													(assign
														(assoc
															series_case_ids (map
																	(lambda
																		(last
																			(current_value)
																		)
																	)
																	series_data
																)
														)
													)

													;remove the case_id column from series_data
													(assign
														(assoc
															series_data (map
																	(lambda
																		(trunc
																			(current_value)
																		)
																	)
																	series_data
																)
														)
													)

													;overwrite series data with just the new generated series values
													(assign
														(assoc
															series_data (call
																	AddDerivedCodeFeature
																	(assoc
																		feature feature
																		features necessary_features
																		series_data series_data
																	)
																)
														)
													)

													;replace .nan with (null).  .nan are possible for initial cases in a series since they don't have any lags
													(assign
														(assoc
															series_data (map
																	(lambda
																		(if
																			(=
																				.nan
																				(current_value)
																			)
																			(null)
																			(current_value)
																		)
																	)
																	series_data
																)
														)
													)

													;do nothing if deriving nominals since they are restricted already
													(if
														(contains_index
															nominalsSet
															feature
														)
														(null)

														;else derived continuous values need to be within bounds if bounds exist,
														;but only bound those values that resulted from imputed values.
														(or
															(!=
																(null)
																boundary_min
															)
															(!=
																(null)
																boundary_max
															)
														)
														(let
															(assoc
																bound_check_indices_map (filter
																		(lambda
																			(let
																				(assoc
																					series_case_index (current_index
																							1
																						)
																					offset_to_derived_imputed_features_map (assoc)
																				)

																				;create a map of relative offset -> set of derived imputed features in that case as referenced by that offset
																				(assign
																					(assoc
																						offset_to_derived_imputed_features_map (map
																								(lambda

																									;grab the set of imputed features for the correct series case id
																									;by its index using the current series case index minus the offset
																									(get
																										cases_derive_imputed_map
																										(get
																											series_case_ids
																											(-
																												series_case_index
																												(current_index)
																											)
																										)
																									)
																								)
																								unique_source_offsets_set
																							)
																					)
																				)

																				;leave only those source features that are on the imputed features list for their respective offset
																				;e.g., if source feature 'B' uses an offset of 1, and happens to be on the list of imputed features for
																				;the case referenced by that offset, we leave 'B' and filter out the rest as appropriate
																				(size
																					(filter
																						(lambda
																							(let
																								(assoc
																									sourced_feature (current_value
																											1
																										)
																									offsets (get
																											sourced_features_offsets_map
																											(current_value
																												1
																											)
																										)
																								)

																								;keep those source features that were imputed in their respected offset row
																								(size
																									(filter
																										(lambda

																											;leave only those offsets that had source features that were imputed, e.g., if source
																											;feature 'B' was on offset 1's list, leave "1", while filtering out the rest as appropriate
																											(contains_index
																												(get
																													offset_to_derived_imputed_features_map
																													(current_value)
																												)
																												sourced_feature
																											)
																										)
																										offsets
																									)
																								)
																							)
																						)
																						sourced_features
																					)
																				)
																			)
																		)

																		;iterate over a map of case index -> series case id so that it can be filtered
																		(zip
																			(indices
																				series_case_ids
																			)
																			series_case_ids
																		)
																	)
															)

															;only do bounds check if there are indices that need checking
															(if
																(size
																	bound_check_indices_map
																)
																(seq
																	(assign
																		(assoc
																			series_data (map
																					(lambda
																						(let
																							(assoc
																								valid_value (if
																										(contains_index
																											bound_check_indices_map
																											(current_index
																												1
																											)
																										)
																										(if
																											(=
																												(null)
																												(current_value
																													1
																												)
																											)
																											(true)
																											(and
																												cycle_length
																												(>=
																													boundary_min
																													boundary_max
																												)
																											)

																											;for cyclic, exclusionary bounds mean the value has to be less than max or more than min
																											(or
																												(<=
																													(current_value
																														1
																													)
																													boundary_max
																												)
																												(>=
																													(current_value
																														1
																													)
																													boundary_min
																												)
																											)

																											;normal bounds check, if bound specified, value must be either more than min or less than max, respectively
																											(and
																												(or
																													(=
																														(null)
																														boundary_min
																													)
																													(>=
																														(current_value
																															1
																														)
																														boundary_min
																													)
																												)
																												(or
																													(=
																														(null)
																														boundary_max
																													)
																													(<=
																														(current_value
																															1
																														)
																														boundary_max
																													)
																												)
																											)
																										)

																										;else this indix isn't on the list that needs checking, thus this is a valid value
																										(true)
																									)
																							)

																							;leave value as is
																							(if
																								valid_value
																								(current_value)

																								;else bound to max value
																								(>
																									(current_value)
																									boundary_max
																								)
																								boundary_max

																								;else bound to min value
																								boundary_min
																							)
																						)
																					)
																					series_data
																				)
																		)
																	)

																	;these case values were derived from imputed features, so we add this feature to cases_derive_imputed_map
																	(assign
																		(assoc
																			bound_check_indices_map
																				;iterate over the case ids to create a map of case id -> updated derive_imputed map for just the updated cases
																				(map
																					(lambda
																						(if
																							(contains_index
																								cases_derive_imputed_map
																								(current_index)
																							)
																							(append
																								(get
																									cases_derive_imputed_map
																									(current_index)
																								)
																								(associate
																									feature
																									(null)
																								)
																							)

																							;else just store the feature
																							(associate
																								feature
																								(null)
																							)
																						)
																					)
																					(zip
																						(values
																							bound_check_indices_map
																						)
																					)
																				)
																		)
																	)

																	;update cases_derive_imputed_map
																	(accum
																		(assoc
																			cases_derive_imputed_map bound_check_indices_map
																		)
																	)
																)
															)
														)
													)

													;add feature, setting each case's corresponding value
													(call
														StoreCaseValues
														(assoc
															case_values_map (zip
																	series_case_ids
																	series_data
																)
															overwrite (true)
															label_name feature
														)
													)

													;accumulate case ids for imputation after all series are derived
													(if
														(and
															impute_nulls
															(contains_value
																series_data
																(null)
															)
														)
														(let
															(assoc
																case_indices_to_impute (filter
																		(lambda
																			(=
																				(null)
																				(get
																					series_data
																					(current_value)
																				)
																			)
																		)
																		(indices
																			series_data
																		)
																	)
															)
															(accum
																(assoc
																	cases_to_impute (unzip
																			series_case_ids
																			case_indices_to_impute
																		)
																)
															)
														)
													)
												)
											)

											;generates a list of queries for each unique series id (where each series id may be a conjuction of several features)
											(call
												GenerateUniqueSeriesQueries
												(assoc
													series_id_features series_id_features
												)
											)
										)

										;update nominal counts for this newly derived nominal feature
										(if
											(size nominalsSet)
											(call
												UpdateNominalClassCountsForFeature
												(assoc
													feature feature
												)
											)
										)

										;once all the values have been derived for the entire feature, impute nulls if necessary
										(if
											(and
												impute_nulls
												(size cases_to_impute)
											)
											(seq
												(map
													(lambda
														(let
															(assoc
																react_value (null)
																context_values (retrieve_from_entity
																		(current_value
																			1
																		)
																		features
																	)
																case_id (current_value
																		1
																	)
															)
															(assign
																(assoc
																	react_value (call
																			ReactDiscriminative
																			(assoc
																				context_values context_values
																				skip_decoding (true)
																				return_action_values_only (true)
																				allow_nulls (false)
																				action_features (list
																						feature
																					)
																				skip_encoding (true)
																				context_features features
																			)
																		)
																)
															)

															;update null value in the case with the reacted value
															(call
																StoreCaseValues
																(assoc
																	case_values_map (associate
																			case_id
																			(first
																				react_value
																			)
																		)
																	overwrite (true)
																	label_name feature
																)
															)
														)
													)
													cases_to_impute
												)

												;add this feature to all these cases_to_impute as an imputed feature
												(declare
													(assoc
														cases_to_impute_imputed_features_map
															;iterate over the case ids to create a map of case id -> updated derive_imputed map for just the updated cases
															(map
																(lambda
																	(if
																		(contains_index
																			cases_derive_imputed_map
																			(current_index)
																		)
																		(append
																			(get
																				cases_derive_imputed_map
																				(current_index)
																			)
																			(associate
																				feature
																				(null)
																			)
																		)

																		;else just store the feature
																		(associate
																			feature
																			(null)
																		)
																	)
																)
																(zip
																	cases_to_impute
																)
															)
													)
												)

												;update cases_derive_imputed_map
												(accum
													(assoc
														cases_derive_imputed_map cases_to_impute_imputed_features_map
													)
												)
											)
										)
									)

									;adds derived features and returns a new data set with the additional features
									; feature: name of feature being derived
									; features: list of feature names to match the series_data
									; series_data: list of lists, where the inner list is in order of features
									;  where the code can access the series_data via series_data via index series_row_index and values via series_row_values
									;returns a list of the new derived series data
									##AddDerivedCodeFeature
									(declare
										(assoc
											feature ""
											features (list)
											series_data (list)
										)
										(declare
											(assoc
												feat_index_map (zip
														features
														(indices
															features
														)
													)
												new_feature_transform (get
														featureCustomDerivedMethods
														(list
															feature
															"train"
														)
													)
											)
										)

										;process and return the generated series data
										(map
											(lambda
												(let
													(assoc
														series_row_index (get_value
																(current_index
																	1
																)
															)
													)
													(get_value
														(call
															new_feature_transform
															(assoc
																feat_index_map feat_index_map
																series_row_index series_row_index
																series_data series_data
															)
														)
													)
												)
											)
											series_data
										)
									)

									;constrains code to the specified list of allowed_opcodes
									; then it finds any node that has a label and replaces it by a copy of label_to_code,
									; replacing label_value with the value at the label and label_name with the label name
									##ParseDerivedFeatureCode
									(declare
										(assoc
											label_to_code (null)
											code_string (null)
											allowed_opcodes (list
													"+"
													"-"
													"*"
													"/"
													"="
													"!="
													"<"
													"<="
													">"
													">="
													"number"
													"string"
													"concat"
													"if"
													"and"
													"or"
													"xor"
													"not"
													"null"
													"min"
													"max"
													"mod"
													"sqrt"
													"pow"
													"abs"
													"log"
													"exp"
													"floor"
													"ceil"
													"round"
													"rand"
													"sin"
													"cos"
													"acos"
													"tan"
													"atan"
													"sinh"
													"asinh"
													"cosh"
													"acosh"
													"tanh"
													"atanh"
												)
										)
										(declare
											(assoc
												code (parse
														code_string
													)
											)
										)
										(rewrite
											(lambda
												(let
													(assoc
														node (current_value
																1
															)
														label_name (first
																(get_labels
																	(current_value
																		1
																	)
																)
															)
													)
													(if

														;make sure it's an allowed opcode
														(not
															(contains_value
																allowed_opcodes
																(get_type_string
																	node
																)
															)
														)
														(null)

														;if not a label, just use
														(not
															label_name
														)
														node

														;else need to rewrite label_to_code
														(rewrite
															(lambda
																(let
																	(assoc
																		to_replace_node (current_value
																				1
																			)
																	)
																	(if

																		;replaces instance of 'label_value' found in the passed in label_to_code with the actual node value (i.e., offset)
																		(=
																			to_replace_node
																			(lambda
																				label_value
																			)
																		)
																		(get_value
																			node
																		)

																		;replaces instance of 'label_name' found in the passed in label_to_code with the actual name of the label (i.e., feature)
																		(=
																			to_replace_node
																			(lambda
																				label_name
																			)
																		)
																		label_name
																		to_replace_node
																	)
																)
															)
															label_to_code
														)
													)
												)
											)
											code
										)
									)

									;Derive feature values from the provided features and values using each derived feature's custom code string, output a list of computed values.
									;
									;parameters:
									; derived_features: list of strings, feature name(s) for which values should be derived, in the specified order.
									; features_values_map: assoc of feature -> values used to compute the resulting value.
									##ComputeFeatureValuesFromCode
									(declare
										(assoc
											feature_values_map (assoc)
											has_derived_datetime_features (false)
											derived_features (list)
										)

										;if there are datetime features, make sure to convert them appropriately
										(if
											hasDateTimeFeatures
											(seq
												(assign
													(assoc
														has_derived_datetime_features (size
																(intersect
																	(zip
																		derived_features
																	)
																	featureDateTimeMap
																)
															)
													)
												)

												;if feature_values_map has datetime features, convert them to epoch
												(if
													(size
														(intersect
															feature_values_map
															featureDateTimeMap
														)
													)
													(assign
														(assoc
															feature_values_map (map
																	(lambda
																		(if
																			(contains_index
																				featureDateTimeMap
																				(current_index)
																			)

																			;encode datetime by converting string date time into seconds since epoch
																			(if
																				(!=
																					(null)
																					(current_value)
																				)
																				(format
																					(current_value)
																					(get
																						featureDateTimeMap
																						(list
																							(current_index
																								1
																							)
																							"date_time_format"
																						)
																					)
																					"number"
																					(get
																						featureDateTimeMap
																						(list
																							(current_index
																								1
																							)
																							"locale"
																						)
																					)
																					""
																				)
																			)

																			;else output original value
																			(current_value)
																		)
																	)
																	feature_values_map
																)
														)
													)
												)
											)
										)
										(declare
											(assoc
												derived_values
													;iterate over the list of derived features and compute each feature value from the provided features and feature_values
													(map
														(lambda
															(if
																(contains_index
																	(get
																		featureAttributes
																		(current_value)
																	)
																	"derived_feature_code"
																)
																(let
																	(assoc
																		raw_code_string (get
																				featureAttributes
																				(list
																					(current_value
																						2
																					)
																					"derived_feature_code"
																				)
																			)
																	)
																	(declare
																		(assoc
																			new_feature_transform_processed (get
																					featureCustomDerivedMethods
																					(list
																						(current_value
																							2
																						)
																						"react"
																					)
																				)
																			output_value (null)
																		)
																	)
																	(assign
																		(assoc
																			output_value (get_value
																					(call
																						new_feature_transform_processed
																						(assoc
																							feature_values_map feature_values_map
																						)
																					)
																				)
																		)
																	)

																	;prevent output of .nan, replace with null if any encountered
																	(if
																		(=
																			.nan
																			output_value
																		)
																		(assign
																			(assoc
																				output_value (null)
																			)
																		)
																	)

																	;append derived feature and value to the input features and values so that they could be used by the next derived feature
																	(accum
																		(assoc
																			feature_values_map (associate
																					(current_value
																						2
																					)
																					output_value
																				)
																		)
																	)
																	output_value
																)
															)
														)
														derived_features
													)
											)
										)

										;if derived_features has datetime features, convert them to strings
										(if
											has_derived_datetime_features
											(map
												(lambda
													(let
														(assoc
															feature (get
																	derived_features
																	(current_index
																		1
																	)
																)
														)
														(if
															(contains_index
																featureDateTimeMap
																feature
															)

															;encode datetime by converting seconds since epoch back into a string date
															(if
																(!=
																	(null)
																	(current_value)
																)
																(format
																	(current_value)
																	"number"
																	(get
																		featureDateTimeMap
																		(list
																			feature
																			"date_time_format"
																		)
																	)
																	""
																	(get
																		featureDateTimeMap
																		(list
																			feature
																			"locale"
																		)
																	)
																)
															)

															;else output original value
															(current_value)
														)
													)
												)
												derived_values
											)

											;else just return the values
											derived_values
										)
									)

									;sort a data by multiple columns
									;parameters:
									; data : list of list of numbers
									; column_order_indices : zero-based column indices to sort by
									##MultiSortList
									(declare
										(assoc
											column_order_indices (list 0)
											data (list)
										)
										(sort

											; generate the multi-column sort method in the format of:
											; (or
											;	(- (get a 0) (get b 0)) ; compare the first column
											;	(- (get a 1) (get b 1)) ; compare the second column
											;	...  ; etc
											; )
											(lambda
												(let
													(assoc
														b (current_value
																2
															)
														a (current_value
																1
															)
													)
													(apply
														"or"
														(map
															(lambda
																(-
																	(get
																		a
																		(current_value)
																	)
																	(get
																		b
																		(current_value)
																	)
																)
															)
															column_order_indices
														)
													)
												)
											)
											data
										)
									)
								)
							)

							;resets all hyperparameters and thersholds back to original values, while leaving feature definitions alone
							##ResetParameterDefaults
							(seq
								(assign_to_entities
									(assoc
										hyperparameterMetadataMap (assoc
												".targetless" (assoc
														robust (assoc
																".none" (assoc
																		featureDeviations (null)
																		dwe -1
																		featureWeights (null)
																		useDeviations (false)
																		k 8
																		allFeatureResidualsCached (false)
																		p 0.1
																		paramPath (list
																				".targetless"
																				"robust"
																				".none"
																			)
																	)
															)
													)
											)
										defaultNumSamples 100
										lpSpaceHeuristicMultiplier 2
										convictionUpperThreshold (null)
										convictionLowerThreshold (null)
									)
								)
								(accum_to_entities
									(assoc revision 1)
								)
							)

							;value-storing labels, initialized and commented below via the initialize label
							##lpSpaceHeuristicMultiplier 2
							##convictionLowerThreshold
							(null)
							##convictionUpperThreshold
							(null)
							##defaultFeatures
							(list
								"stock"
								"time"
								"value"
								".value_lag"
								".time_start"
								".time_lag"
								".time_delta"
								".time_end"
								".value_delta"
							)
							##metaData
							(assoc)
							##categoricalFeaturesSet
							(assoc ".custom_nominal" (null) stock (null))
							##ordinalFeatures
							(list)
							##hasEncodedFeatures
							(true)
							##hasFeaturesNeedEncodingFromInput
							(true)
							##hasCyclicFeatures 0
							##cyclicFeaturesMap
							(null)
							##nonStringNominalFeaturesMap
							(assoc ".time_start" "boolean" ".time_end" "boolean")
							##stringNominalFeaturesSet
							(assoc ".custom_nominal" (null) stock (null))
							##userSpecifiedFeatureErrorsMap
							(assoc)
							##averageModelCaseEntropyAddition
							(null)
							##averageModelCaseEntropyRemoval
							(null)
							##averageModelCaseDistanceContribution
							(null)
							##storedCaseConvictionsFeatureAddition
							(null)
							##storedConvictionsFeatureSet
							(null)
							##modelAccuracyEntropyMap
							(assoc)
							##modelTargetedAccuracyEntropyMap
							(assoc)
							##minResidualMagnitudeMap
							(assoc)
							##minTargetedResidualMagnitudeMap
							(assoc)
							##nominalClassProbabilitiesMap
							(assoc
								".none" (assoc
										stock (assoc
												stk_A 0.5238095238095238
												stkB 0.47619047619047616
											)
									)
							)
							##expectedValuesMap
							(assoc
								".none" (assoc
										".time_start" (assoc
												class_counts (assoc
														0 19
														1 2
													)
												expected_value 0
											)
										stock (assoc
												class_counts (assoc
														stk_A 11
														stkB 10
													)
												expected_value "stk_A"
											)
										".time_lag" (assoc expected_value 1585749494.2432997)
										value (assoc expected_value 106.04761904761905)
										time (assoc expected_value 1585752720)
										".time_end" (assoc
												class_counts (assoc
														0 19
														1 2
													)
												expected_value 0
											)
										".time_delta" (assoc expected_value 3225.756700254622)
										".value_lag" (assoc expected_value 105.91206189153607)
										".value_delta" (assoc expected_value 0.1355571560829667)
									)
							)
							##featureNullRatiosMap
							(assoc
								".time_start" (assoc
										non_null_ratio 1
										min 0
										null_residual 1
										num_nulls 0
										max 1
									)
								stock (assoc
										non_null_ratio 1
										min 0
										null_residual 1
										num_nulls 0
										max 1
									)
								".time_lag" (assoc
										non_null_ratio 1
										min 1585728000
										null_residual 46800
										num_nulls 0
										max 1585774800
									)
								value (assoc
										non_null_ratio 1
										min 100
										null_residual 10.5
										num_nulls 0
										max 110.5
									)
								time (assoc
										non_null_ratio 1
										min 1585728000
										null_residual 50400
										num_nulls 0
										max 1585778400
									)
								".time_end" (assoc
										non_null_ratio 1
										min 0
										null_residual 1
										num_nulls 0
										max 1
									)
								".time_delta" (assoc
										non_null_ratio 1
										min -1357.5772910118103
										null_residual 6757.57729101181
										num_nulls 0
										max 5400
									)
								".value_lag" (assoc
										non_null_ratio 1
										min 100
										null_residual 10.5
										num_nulls 0
										max 110.5
									)
								".value_delta" (assoc
										non_null_ratio 1
										min -2
										null_residual 4
										num_nulls 0
										max 2
									)
							)
							##defaultNumSamples 100
							##ordinalFeaturesValuesMap
							(assoc)
							##ordinalFeaturesRangesMap
							(assoc)
							##uniqueNominalsMap
							(assoc)
							##cachedFeatureMinResidualMap
							(assoc
								".time_start" 0.022727272727272728
								stock 0.022727272727272728
								".time_lag" 15.874272644519806
								time 16.363636363636363
								value 0.011363636363636364
								".time_end" 0.022727272727272728
								".time_delta" 2.727272727272727
								".value_lag" 0.0034700315871958117
								".value_delta" 0.004409520179674654
							)
							##cachedFeatureMinGapMap
							(assoc
								".time_start" 0.5
								stock 0.5
								".time_lag" 349.23399817943573
								value 0.25
								time 360
								".time_end" 0.5
								".time_delta" 60
								".value_lag" 0.07634069491830786
								".value_delta" 0.09700944395284239
							)
							##hyperparameterMetadataMap
							(assoc
								".targetless" (assoc
										robust (assoc
												".none" (assoc
														dwe -1
														gridSearchError 75111.0192867884
														allFeatureResidualsCached (true)
														featureWeights (assoc
																".time_start" 1
																stock 1.157461093425284
																".time_lag" 0.40896345735135664
																time 0.4134584465891669
																value 0.9606120786030677
																".time_end" 1
																".time_delta" 0.4987065787622407
																".value_lag" 0.9525978606678481
																".value_delta" 0.9812613140588551
															)
														featureDeviations (assoc
																".time_start" 0.9858630952380952
																stock 0.23303326875548294
																".time_lag" 6897.97588602826
																value 1.7032763286779884
																time 7902.125091005117
																".time_end" 0.9858630952380952
																".time_delta" 931.3147273928937
																".value_lag" 1.5864199026018293
																".value_delta" 1.2260481504030745
															)
														p 0.1
														paramPath (list
																".targetless"
																"robust"
																".none"
															)
														k 5
													)
											)
									)
							)
							##staleOrdinalValuesCount
							(true)
							##minAblatementModelSize 100
							##hasSubstituteFeatureValues
							(false)
							##substitutionValueMap
							(assoc)
							##unSubstituteValueMap
							(assoc)
							##featureAttributes
							(assoc
								".value_lag" (assoc
										derived_feature_code "#value 1"
										auto_derive_on_train (assoc
												code "#value 1"
												ordered_by_features (list
														"time"
													)
												series_id_features (list
														"stock"
													)
												derive_type "custom"
											)
										type "continuous"
										bounds (assoc allow_null (false))
										max_row_lag 1
									)
								".time_start" (assoc
										auto_derive_on_train (assoc
												start_id_features (list
														"stock"
													)
												start_time_feature "time"
												derive_type "start"
											)
										"non-sensitive" (true)
									)
								".time_lag" (assoc
										derived_feature_code "#time 1"
										auto_derive_on_train (assoc
												code "#time 1"
												ordered_by_features (list
														"time"
													)
												series_id_features (list
														"stock"
													)
												derive_type "custom"
											)
										type "continuous"
										bounds (assoc
												min "2020-04-01T08:00:00"
												max "2020-04-01T14:00:00"
												allow_null (false)
											)
										max_row_lag 1
										date_time_format "%Y-%m-%dT%H:%M:%S"
									)
								".custom_nominal" (assoc
										derived_feature_code "(concat #stock 0 \"_custom\""
										type "nominal"
										max_row_lag 0
									)
								value (assoc
										derived_feature_code "(+ #.value_delta 0 #.value_lag 0)"
										type "continuous"
										bounds (assoc
												min 98
												max 115
												allow_null (true)
											)
										max_row_lag 0
									)
								stock (assoc
										derived_feature_code "#stock 1"
										id_feature (true)
										type "nominal"
										bounds (assoc
												allowed (list
														"stk_A"
														"stkB"
													)
											)
										max_row_lag 1
									)
								".time_end" (assoc
										auto_derive_on_train (assoc
												end_id_features (list
														"stock"
													)
												end_time_feature "time"
												derive_type "end"
											)
										"non-sensitive" (true)
									)
								".time_delta" (assoc
										auto_derive_on_train (assoc
												code "(- #time 0 #.time_lag 0)"
												ordered_by_features (list
														"time"
													)
												series_id_features (list
														"stock"
													)
												derive_type "custom"
											)
										type "continuous"
										bounds (assoc allow_null (true))
									)
								time (assoc
										derived_feature_code "(+ #.time_delta 0 #.time_lag 0)"
										time_series (assoc time_feature (true))
										type "continuous"
										bounds (assoc
												min "2020-04-01T08:00:00"
												max "2020-04-01T14:00:00"
												allow_null (false)
											)
										max_row_lag 0
										date_time_format "%Y-%m-%dT%H:%M:%S"
									)
								".value_delta" (assoc
										auto_derive_on_train (assoc
												code "(- #value 0 #.value_lag 0)"
												ordered_by_features (list
														"time"
													)
												series_id_features (list
														"stock"
													)
												derive_type "custom"
											)
										type "continuous"
										bounds (assoc allow_null (true))
									)
							)
							##featureRoundingMap
							(assoc)
							##hasRoundedFeatures
							(false)
							##hasDateTimeFeatures
							(true)
							##hasPopulatedCaseWeight
							(false)
							##featureDateTimeMap
							(assoc
								".time_lag" (assoc
										locale (null)
										time_delta_format (null)
										date_time_format "date:%Y-%m-%dT%H:%M:%S"
									)
								time (assoc
										locale (null)
										time_delta_format (null)
										date_time_format "date:%Y-%m-%dT%H:%M:%S"
									)
							)
							##featureBoundsMap
							(assoc
								".value_lag" (assoc allow_null (false))
								".time_lag" (assoc
										epoch_max_value 1585764000
										has_epoch_bounds (true)
										min "2020-04-01T08:00:00"
										max "2020-04-01T14:00:00"
										epoch_min_value 1585742400
										allow_null (false)
									)
								value (assoc
										min 98
										max 115
										allow_null (true)
									)
								stock (assoc
										allowed (list "stk_A" "stkB")
									)
								".time_delta" (assoc allow_null (true))
								time (assoc
										epoch_max_value 1585764000
										has_epoch_bounds (true)
										min "2020-04-01T08:00:00"
										max "2020-04-01T14:00:00"
										epoch_min_value 1585742400
										allow_null (false)
									)
								".value_delta" (assoc allow_null (true))
							)
							##seriesStore
							(assoc)
							##seriesFeatures
							(assoc)
							##autoOptimizeEnabled
							(null)
							##autoOptimizeThreshold
							(null)
							##autoOptimizeGrowthFactorAmount
							(null)
							##autoOptimizeLimitSize 100000
							##savedOptimizeParameterMap
							(assoc
								bypass_calculate_feature_residuals (null)
								k_folds_by_indices (null)
								bypass_hyperparameter_optimization (null)
								use_deviations (null)
								k_folds 1
								action_features (list)
								bypass_calculate_feature_weights (null)
								bypass_calculate_case_predictions (null)
								dwe_values (null)
								bypass_calculate_feature_predictions (null)
								k_values (null)
								p_values (null)
								optimization_sub_model_size (null)
								num_samples (null)
								num_optimization_samples (null)
								context_features (list)
								targeted_model (null)
								optimize_level (null)
								id_feature_case_weighting (false)
								weight_feature ".case_weight"
								inverse_residuals_as_weights (null)
							)
							##derivedFeaturesMap
							(assoc
								".value_lag" (null)
								".time_start" (null)
								".time_lag" (null)
								".time_end" (null)
								".time_delta" (null)
								".value_delta" (null)
							)
							##sourceToDerivedFeatureMap
							(assoc
								".value_lag" (list ".value_delta")
								".time_lag" (list ".time_delta")
								value (list ".value_lag" ".value_delta")
								time (list ".time_start" ".time_lag" ".time_end" ".time_delta")
							)
							##featureCustomDerivedMethods
							(assoc
								".value_lag" (assoc
										react (if
												(and
													(=
														1
														0
													)
													(contains_index
														feature_values_map
														"value"
													)
												)
												(get
													feature_values_map
													"value"
												)
												(null)
											)
										series_react (if
												(and
													(>=
														(-
															series_row_index
															1
														)
														0
													)
													(contains_index
														feature_index_map
														"value"
													)
												)
												(let
													(assoc
														val (get
																series_data
																(list
																	(-
																		series_row_index
																		1
																	)
																	(get
																		feature_index_map
																		"value"
																	)
																)
															)
													)
													(if
														(contains_index
															featureDateTimeMap
															"value"
														)
														(if
															(!=
																(null)
																val
															)
															(call
																ConvertDateToEpoch
																(assoc
																	date val
																	feature "value"
																)
															)
														)
														val
													)
												)
												(null)
											)
										train (if
												(and
													(>=
														(-
															series_row_index
															1
														)
														0
													)
													(contains_index
														feat_index_map
														"value"
													)
												)
												(get
													series_data
													(list
														(-
															series_row_index
															1
														)
														(get
															feat_index_map
															"value"
														)
													)
												)
												(null)
											)
									)
								".time_lag" (assoc
										react (if
												(and
													(=
														1
														0
													)
													(contains_index
														feature_values_map
														"time"
													)
												)
												(get
													feature_values_map
													"time"
												)
												(null)
											)
										series_react (if
												(and
													(>=
														(-
															series_row_index
															1
														)
														0
													)
													(contains_index
														feature_index_map
														"time"
													)
												)
												(let
													(assoc
														val (get
																series_data
																(list
																	(-
																		series_row_index
																		1
																	)
																	(get
																		feature_index_map
																		"time"
																	)
																)
															)
													)
													(if
														(contains_index
															featureDateTimeMap
															"time"
														)
														(if
															(!=
																(null)
																val
															)
															(call
																ConvertDateToEpoch
																(assoc
																	date val
																	feature "time"
																)
															)
														)
														val
													)
												)
												(null)
											)
										train (if
												(and
													(>=
														(-
															series_row_index
															1
														)
														0
													)
													(contains_index
														feat_index_map
														"time"
													)
												)
												(get
													series_data
													(list
														(-
															series_row_index
															1
														)
														(get
															feat_index_map
															"time"
														)
													)
												)
												(null)
											)
									)
								".custom_nominal" (assoc
										react (concat
												(if
													(and
														(=
															0
															0
														)
														(contains_index
															feature_values_map
															"stock"
														)
													)
													(get
														feature_values_map
														"stock"
													)
													(null)
												)
												"_custom"
											)
										series_react (concat
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feature_index_map
															"stock"
														)
													)
													(let
														(assoc
															val (get
																	series_data
																	(list
																		(-
																			series_row_index
																			0
																		)
																		(get
																			feature_index_map
																			"stock"
																		)
																	)
																)
														)
														(if
															(contains_index
																featureDateTimeMap
																"stock"
															)
															(if
																(!=
																	(null)
																	val
																)
																(call
																	ConvertDateToEpoch
																	(assoc
																		date val
																		feature "stock"
																	)
																)
															)
															val
														)
													)
													(null)
												)
												"_custom"
											)
										train (null)
									)
								value (assoc
										react (+
												(if
													(and
														(=
															0
															0
														)
														(contains_index
															feature_values_map
															".value_delta"
														)
													)
													(get
														feature_values_map
														".value_delta"
													)
													(null)
												)
												(if
													(and
														(=
															0
															0
														)
														(contains_index
															feature_values_map
															".value_lag"
														)
													)
													(get
														feature_values_map
														".value_lag"
													)
													(null)
												)
											)
										series_react (+
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feature_index_map
															".value_delta"
														)
													)
													(let
														(assoc
															val (get
																	series_data
																	(list
																		(-
																			series_row_index
																			0
																		)
																		(get
																			feature_index_map
																			".value_delta"
																		)
																	)
																)
														)
														(if
															(contains_index
																featureDateTimeMap
																".value_delta"
															)
															(if
																(!=
																	(null)
																	val
																)
																(call
																	ConvertDateToEpoch
																	(assoc
																		date val
																		feature ".value_delta"
																	)
																)
															)
															val
														)
													)
													(null)
												)
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feature_index_map
															".value_lag"
														)
													)
													(let
														(assoc
															val (get
																	series_data
																	(list
																		(-
																			series_row_index
																			0
																		)
																		(get
																			feature_index_map
																			".value_lag"
																		)
																	)
																)
														)
														(if
															(contains_index
																featureDateTimeMap
																".value_lag"
															)
															(if
																(!=
																	(null)
																	val
																)
																(call
																	ConvertDateToEpoch
																	(assoc
																		date val
																		feature ".value_lag"
																	)
																)
															)
															val
														)
													)
													(null)
												)
											)
										train (null)
									)
								stock (assoc
										react (if
												(and
													(=
														1
														0
													)
													(contains_index
														feature_values_map
														"stock"
													)
												)
												(get
													feature_values_map
													"stock"
												)
												(null)
											)
										series_react (if
												(and
													(>=
														(-
															series_row_index
															1
														)
														0
													)
													(contains_index
														feature_index_map
														"stock"
													)
												)
												(let
													(assoc
														val (get
																series_data
																(list
																	(-
																		series_row_index
																		1
																	)
																	(get
																		feature_index_map
																		"stock"
																	)
																)
															)
													)
													(if
														(contains_index
															featureDateTimeMap
															"stock"
														)
														(if
															(!=
																(null)
																val
															)
															(call
																ConvertDateToEpoch
																(assoc
																	date val
																	feature "stock"
																)
															)
														)
														val
													)
												)
												(null)
											)
										train (null)
									)
								".time_delta" (assoc
										train (-
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feat_index_map
															"time"
														)
													)
													(get
														series_data
														(list
															(-
																series_row_index
																0
															)
															(get
																feat_index_map
																"time"
															)
														)
													)
													(null)
												)
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feat_index_map
															".time_lag"
														)
													)
													(get
														series_data
														(list
															(-
																series_row_index
																0
															)
															(get
																feat_index_map
																".time_lag"
															)
														)
													)
													(null)
												)
											)
									)
								time (assoc
										react (+
												(if
													(and
														(=
															0
															0
														)
														(contains_index
															feature_values_map
															".time_delta"
														)
													)
													(get
														feature_values_map
														".time_delta"
													)
													(null)
												)
												(if
													(and
														(=
															0
															0
														)
														(contains_index
															feature_values_map
															".time_lag"
														)
													)
													(get
														feature_values_map
														".time_lag"
													)
													(null)
												)
											)
										series_react (+
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feature_index_map
															".time_delta"
														)
													)
													(let
														(assoc
															val (get
																	series_data
																	(list
																		(-
																			series_row_index
																			0
																		)
																		(get
																			feature_index_map
																			".time_delta"
																		)
																	)
																)
														)
														(if
															(contains_index
																featureDateTimeMap
																".time_delta"
															)
															(if
																(!=
																	(null)
																	val
																)
																(call
																	ConvertDateToEpoch
																	(assoc
																		date val
																		feature ".time_delta"
																	)
																)
															)
															val
														)
													)
													(null)
												)
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feature_index_map
															".time_lag"
														)
													)
													(let
														(assoc
															val (get
																	series_data
																	(list
																		(-
																			series_row_index
																			0
																		)
																		(get
																			feature_index_map
																			".time_lag"
																		)
																	)
																)
														)
														(if
															(contains_index
																featureDateTimeMap
																".time_lag"
															)
															(if
																(!=
																	(null)
																	val
																)
																(call
																	ConvertDateToEpoch
																	(assoc
																		date val
																		feature ".time_lag"
																	)
																)
															)
															val
														)
													)
													(null)
												)
											)
										train (null)
									)
								".value_delta" (assoc
										train (-
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feat_index_map
															"value"
														)
													)
													(get
														series_data
														(list
															(-
																series_row_index
																0
															)
															(get
																feat_index_map
																"value"
															)
														)
													)
													(null)
												)
												(if
													(and
														(>=
															(-
																series_row_index
																0
															)
															0
														)
														(contains_index
															feat_index_map
															".value_lag"
														)
													)
													(get
														series_data
														(list
															(-
																series_row_index
																0
															)
															(get
																feat_index_map
																".value_lag"
															)
														)
													)
													(null)
												)
											)
									)
							)
							##hasStringOrdinals
							(false)
							##hasBooleans
							(true)
							##ordinalStringToOrdinalMap
							(assoc)
							##ordinalOrdinalToStringMap
							(assoc)
							##ordinalNumericFeaturesSet
							(assoc)
							##hasDependentFeatures
							(false)
							##dependentFeatureMap
							(assoc)
							##continuousDependentsMap
							(null)
							##dependentsBoundaryMap
							(assoc)
							##dependentValuesCombinationsMap
							(assoc)
							##nominalClassCountsMap
							(assoc
								".value_lag" 0
								".time_start" 2
								".time_lag" 0
								value 0
								stock 2
								".time_end" 2
								".time_delta" 0
								time 0
								".value_delta" 0
							)
							##encodingNeededFeaturesSet
							(assoc
								".time_start" (null)
								".time_lag" (null)
								".custom_nominal" (null)
								stock (null)
								".time_end" (null)
								time (null)
							)
							##nominalsSet
							(assoc
								".time_start" (null)
								".custom_nominal" (null)
								stock (null)
								".time_end" (null)
							)
							##inactiveFeaturesMap
							(null)
							##hasInactiveFeatures
							(false)
							##residualsMap
							(assoc
								"robust.targetlessrobust.none" (assoc
										".time_start" 0.9858630952380952
										stock 0.23303326875548294
										".robust" (true)
										".time_lag" 6897.97588602826
										time 7902.125091005117
										value 1.7032763286779884
										".time_delta" 931.3147273928937
										".time_end" 0.9858630952380952
										".hyperparam_path" (list
												".targetless"
												"robust"
												".none"
											)
										".value_lag" 1.5864199026018293
										".value_delta" 1.2260481504030745
									)
							##mdaMap
							(assoc)
							##queryFeatureLimitsMap
							(assoc
								".value_lag" (null)
								".time_start" (null)
								".time_lag" (list "2020-04-01T08:00:00" "2020-04-01T14:00:00")
								".custom_nominal" (null)
								value (list 98 115)
								stock (null)
								".time_end" (null)
								".time_delta" (null)
								time (list "2020-04-01T08:00:00" "2020-04-01T14:00:00")
								".value_delta" (null)
							)
							##queryDistanceTypeMap
							(assoc
								".value_lag" "continuous"
								".time_start" "continuous"
								".time_lag" "continuous"
								".custom_nominal" "nominal"
								value "continuous"
								stock "nominal"
								".time_end" "continuous"
								".time_delta" "continuous"
								time "continuous"
								".value_delta" "continuous"
							)
							##contributionsMap
							(assoc)
							##influenceWeightThreshold 0.99
							##regionalModelMinSize 30
							##regionalModelMinPercent 0.15
							##revision 3
							##attributesModule "attributes"
							##optimizationModule "optimization"
							##explanationModule "explanation"
							##editingModule "editing"
							##convictionModule "conviction"
							##imputeModule "impute"
							##generationModule "generation"
							##reactModule "react"
							##residualsModule "residuals"
							##deriveModule "derive"

							;load module entities code directly into trainee template
							##LoadModules
							(seq
								(direct_assign_to_entities
									(assoc
										loadModulesEndpoint (map
												(lambda
													(retrieve_entity_root
														(current_value)
													)
												)

												;names of modules to load
												(list
													attributesModule
													reactModule
													residualsModule
													optimizationModule
													explanationModule
													editingModule
													imputeModule
													convictionModule
													generationModule
													deriveModule
												)
											)
									)
								)

								;delete the module entities after their code has been loaded in
								(destroy_entities
									attributesModule
									reactModule
									residualsModule
									optimizationModule
									explanationModule
									editingModule
									imputeModule
									convictionModule
									generationModule
									deriveModule
								)
							)
							##Initialize
							(seq

								;load module code into trainee template if they haven't been loaded yet
								(if
									(= (null) loadModulesEndpoint)
									(call LoadModules)
								)
								##InitializeValues
								(assign_to_entities
									(assoc
										regionalModelMinPercent 0.15
										storedConvictionsFeatureSet (null)
										revision 0
										hasFeaturesNeedEncodingFromInput (false)
										defaultFeatures (list)
										regionalModelMinSize 30
										ordinalFeatures (list)
										mdaMap (assoc)
										substitutionValueMap (assoc)
										averageModelCaseEntropyAddition (null)
										averageModelCaseEntropyRemoval (null)
										hasBooleans (false)
										continuousDependentsMap (assoc)
										hasCyclicFeatures (false)
										uniqueNominalsMap (assoc)
										hasStringOrdinals (false)
										minAblatementModelSize 100
										categoricalFeaturesSet (assoc)
										hasInactiveFeatures (true)
										modelTargetedAccuracyEntropyMap (assoc)
										autoOptimizeEnabled (false)
										stringNominalFeaturesSet (assoc)
										ordinalFeaturesValuesMap (assoc)
										featureAttributes (assoc)
										ordinalStringToOrdinalMap (assoc)
										minTargetedResidualMagnitudeMap (assoc)
										metaData (assoc)
										queryDistanceTypeMap (assoc)
										inactiveFeaturesMap (assoc)
										expectedValuesMap (assoc)
										hyperparameterMetadataMap (assoc
												".targetless" (assoc
														robust (assoc
																".none" (assoc
																		featureDeviations (null)
																		dwe -1
																		featureWeights (null)
																		useDeviations (false)
																		k 8
																		allFeatureResidualsCached (false)
																		p 0.1
																		paramPath (list
																				".targetless"
																				"robust"
																				".none"
																			)
																	)
															)
													)
											)
										dependentValuesCombinationsMap (assoc)
										averageModelCaseDistanceContribution (null)
										autoOptimizeGrowthFactorAmount 7.389056
										featureCustomDerivedMethods (assoc)
										nonStringNominalFeaturesMap (assoc)
										autoOptimizeLimitSize 100000
										hasPopulatedCaseWeight (false)
										dependentsBoundaryMap (assoc)
										savedOptimizeParameterMap (null)
										ordinalNumericFeaturesSet (assoc)
										contributionsMap (assoc)
										dependentFeatureMap (assoc)
										defaultNumSamples 100
										cachedFeatureMinResidualMap (assoc)
										influenceWeightThreshold 0.99
										cachedFeatureMinGapMap (assoc)
										minResidualMagnitudeMap (assoc)
										nominalClassProbabilitiesMap (assoc)
										featureRoundingMap (assoc)
										nominalsSet (assoc)
										autoOptimizeThreshold 100
										sourceToDerivedFeatureMap (assoc)
										hasEncodedFeatures (false)
										featureBoundsMap (assoc)
										ordinalFeaturesRangesMap (assoc)
										userSpecifiedFeatureErrorsMap (assoc)
										derivedFeaturesMap (assoc)
										featureNullRatiosMap (assoc)
										seriesFeatures (assoc)
										staleOrdinalValuesCount (true)
										residualsMap (assoc)
										nominalClassCountsMap (null)
										hasDependentFeatures (false)
										featureDateTimeMap (assoc)
										lpSpaceHeuristicMultiplier 2
										unSubstituteValueMap (assoc)
										hasRoundedFeatures (false)
										queryFeatureLimitsMap (assoc)
										encodingNeededFeaturesSet (assoc)
										cyclicFeaturesMap (null)
										hasSubstituteFeatureValues (false)
										hasDateTimeFeatures (false)
										convictionUpperThreshold (null)
										ordinalOrdinalToStringMap (assoc)
										modelAccuracyEntropyMap (assoc)
										seriesStore (assoc)
										convictionLowerThreshold (null)
										storedCaseConvictionsFeatureAddition (null)
									)
								)
							)

							;howso version for this model
							##majorVersion -1
							##minorVersion -1
							##pointVersion -1
							##debug_print 0
						)
					)
				)
			)
	)
	(set_entity_rand_seed new_entity "9*�&a��Q���� ��")
	(create_entities
		(append
			new_entity
			(list "session")
		)
		(lambda
			(null
				##.replay_steps
				(list
					"_2567431107"
					"_541691990"
					"_1331724925"
					"_1380026028"
					"_330983550"
					"_146735784"
					"_3509605058"
					"_29131284"
					"_365885413"
					"_2820628188"
					"_143947683"
					"_1055610092"
					"_106109422"
					"_260006025"
					"_3821126114"
					"_614453050"
					"_1555739108"
					"_1865829883"
					"_2385920582"
					"_2236282867"
					"_2831706264"
				)
				##.indices_map
				(assoc
					5 "_146735784"
					14 "_3821126114"
					19 "_2236282867"
					20 "_2831706264"
					17 "_1865829883"
					10 "_143947683"
					7 "_29131284"
					8 "_365885413"
					13 "_260006025"
					3 "_1380026028"
					4 "_330983550"
					1 "_541691990"
					18 "_2385920582"
					15 "_614453050"
					16 "_1555739108"
					6 "_3509605058"
					0 "_2567431107"
					12 "_106109422"
					11 "_1055610092"
					9 "_2820628188"
					2 "_1331724925"
				)
				##.trained_instance_count 21
				##.metadata
				(assoc)
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "session")
		)
		"�s��I�ȸ\0wX[]��"
	)
	(create_entities
		(append
			new_entity
			(list "_2567431107")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585742400
				##value 100
				##.session "session"
				##.session_training_index 0
				##.time_lag 1585743501.5320036
				##.value_lag 100.30598111209432
				##.time_delta -1101.5320036411285
				##.value_delta -0.3059811120943152
				##.time_end 0
				##.time_start 1
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_2567431107")
		)
		"{����sռ]K?Kaa�"
	)
	(create_entities
		(append
			new_entity
			(list "_541691990")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585746000
				##value 101
				##.session "session"
				##.session_training_index 1
				##.time_lag 1585742400
				##.value_lag 100
				##.time_delta 3600
				##.value_delta 1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_541691990")
		)
		"iա,��7�y�F~��"
	)
	(create_entities
		(append
			new_entity
			(list "_1331724925")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585749600
				##value 103
				##.session "session"
				##.session_training_index 2
				##.time_lag 1585746000
				##.value_lag 101
				##.time_delta 3600
				##.value_delta 2
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_1331724925")
		)
		"�ƪ�e)^%�����I�"
	)
	(create_entities
		(append
			new_entity
			(list "_1380026028")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585753200
				##value 105
				##.session "session"
				##.session_training_index 3
				##.time_lag 1585749600
				##.value_lag 103
				##.time_delta 3600
				##.value_delta 2
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_1380026028")
		)
		"�������;���(,P�"
	)
	(create_entities
		(append
			new_entity
			(list "_330983550")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585756800
				##value 104
				##.session "session"
				##.session_training_index 4
				##.time_lag 1585753200
				##.value_lag 105
				##.time_delta 3600
				##.value_delta -1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_330983550")
		)
		"�qHm�A̉���DK�"
	)
	(create_entities
		(append
			new_entity
			(list "_146735784")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585760400
				##value 106
				##.session "session"
				##.session_training_index 5
				##.time_lag 1585756800
				##.value_lag 104
				##.time_delta 3600
				##.value_delta 2
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_146735784")
		)
		"�x��!KT`mȜ3)��"
	)
	(create_entities
		(append
			new_entity
			(list "_3509605058")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585764000
				##value 104
				##.session "session"
				##.session_training_index 6
				##.time_lag 1585760400
				##.value_lag 106
				##.time_delta 3600
				##.value_delta -2
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_3509605058")
		)
		"+����ك3\\-�%H�H�"
	)
	(create_entities
		(append
			new_entity
			(list "_29131284")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585767600
				##value 103
				##.session "session"
				##.session_training_index 7
				##.time_lag 1585764000
				##.value_lag 104
				##.time_delta 3600
				##.value_delta -1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_29131284")
		)
		"��ƆS{���wb��]~�"
	)
	(create_entities
		(append
			new_entity
			(list "_365885413")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585771200
				##value 105
				##.session "session"
				##.session_training_index 8
				##.time_lag 1585767600
				##.value_lag 103
				##.time_delta 3600
				##.value_delta 2
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_365885413")
		)
		"�)��N��`\"h�D���"
	)
	(create_entities
		(append
			new_entity
			(list "_2820628188")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585774800
				##value 106
				##.session "session"
				##.session_training_index 9
				##.time_lag 1585771200
				##.value_lag 105
				##.time_delta 3600
				##.value_delta 1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_2820628188")
		)
		"{D�շ{4�m�0�"
	)
	(create_entities
		(append
			new_entity
			(list "_143947683")
		)
		(lambda
			(null
				##stock "stk_A"
				##time 1585778400
				##value 107
				##.session "session"
				##.session_training_index 10
				##.time_lag 1585774800
				##.value_lag 106
				##.time_delta 3600
				##.value_delta 1
				##.time_end 1
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_143947683")
		)
		"�sT���__RKD�"
	)
	(create_entities
		(append
			new_entity
			(list "_1055610092")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585728000
				##value 110.5
				##.session "session"
				##.session_training_index 11
				##.time_lag 1585729357.577291
				##.value_lag 109.84731861016338
				##.time_delta -1357.5772910118103
				##.value_delta 0.6526813898366157
				##.time_end 0
				##.time_start 1
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_1055610092")
		)
		"c�w{M{\\�Rg���"
	)
	(create_entities
		(append
			new_entity
			(list "_106109422")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585731120
				##value 109
				##.session "session"
				##.session_training_index 12
				##.time_lag 1585728000
				##.value_lag 110.5
				##.time_delta 3120
				##.value_delta -1.5
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_106109422")
		)
		"��Ϯ���8^3Yv�"
	)
	(create_entities
		(append
			new_entity
			(list "_260006025")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585735200
				##value 110
				##.session "session"
				##.session_training_index 13
				##.time_lag 1585731120
				##.value_lag 109
				##.time_delta 4080
				##.value_delta 1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_260006025")
		)
		"Ǐ�(�GUx��{��"
	)
	(create_entities
		(append
			new_entity
			(list "_3821126114")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585739520
				##value 109
				##.session "session"
				##.session_training_index 14
				##.time_lag 1585735200
				##.value_lag 110
				##.time_delta 4320
				##.value_delta -1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_3821126114")
		)
		"�Ol��r,f���<�����"
	)
	(create_entities
		(append
			new_entity
			(list "_614453050")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585741680
				##value 108
				##.session "session"
				##.session_training_index 15
				##.time_lag 1585739520
				##.value_lag 109
				##.time_delta 2160
				##.value_delta -1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_614453050")
		)
		"S����_~�$0���"
	)
	(create_entities
		(append
			new_entity
			(list "_1555739108")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585744200
				##value 109
				##.session "session"
				##.session_training_index 16
				##.time_lag 1585741680
				##.value_lag 108
				##.time_delta 2520
				##.value_delta 1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_1555739108")
		)
		"�W�,=\0w�;;!ݶ�"
	)
	(create_entities
		(append
			new_entity
			(list "_1865829883")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585749600
				##value 108
				##.session "session"
				##.session_training_index 17
				##.time_lag 1585744200
				##.value_lag 109
				##.time_delta 5400
				##.value_delta -1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_1865829883")
		)
		".?&��|�����5�g���"
	)
	(create_entities
		(append
			new_entity
			(list "_2385920582")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585753200
				##value 107
				##.session "session"
				##.session_training_index 18
				##.time_lag 1585749600
				##.value_lag 108
				##.time_delta 3600
				##.value_delta -1
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_2385920582")
		)
		"�\n���YV�8B�s���"
	)
	(create_entities
		(append
			new_entity
			(list "_2236282867")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585758000
				##value 106.5
				##.session "session"
				##.session_training_index 19
				##.time_lag 1585753200
				##.value_lag 107
				##.time_delta 4800
				##.value_delta -0.5
				##.time_end 0
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_2236282867")
		)
		"d���I��5#Vmc���"
	)
	(create_entities
		(append
			new_entity
			(list "_2831706264")
		)
		(lambda
			(null
				##stock "stkB"
				##time 1585762200
				##value 106
				##.session "session"
				##.session_training_index 20
				##.time_lag 1585758000
				##.value_lag 106.5
				##.time_delta 4200
				##.value_delta -0.5
				##.time_end 1
				##.time_start 0
			)
		)
	)
	(set_entity_rand_seed
		(append
			new_entity
			(list "_2831706264")
		)
		"t^���6:� 8p�"
	)
	new_entity
)