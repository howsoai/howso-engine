(seq
	#unit_test (direct_assign_to_entities (assoc unit_test (load "unit_test.amlg")))
	(call (load "unit_test_howso.amlg") (assoc name "ut_h_clustering.amlg"))

	(declare (assoc
		data (load "unit_test_data/iris.csv")
	))

	(declare (assoc
		features (first data)
		training_data (tail data)
		result (null)
	))

	(assign (assoc
		training_data
			(sort
				(lambda (> (last (current_value)) (last (current_value 1))))
				training_data
			)
	))

	(call_entity "howso" "set_feature_attributes" (assoc
		feature_attributes (associate (last features) (assoc "type" "nominal" "data_type" "number"))
	))

	(call_entity "howso" "train" (assoc
		features features
		cases training_data
		session "my_session"
	))

	(call_entity "howso" "analyze")

	(print "Clustering Iris..\n")

	(call_entity "howso" "react_into_features" (assoc
		clustering .true
		clustering_expansion_threshold 0.6
	))

	(assign (assoc
		result (call_entity "howso" "get_cases" (assoc features [".cluster_id"]))
	))
	(call keep_result_payload)

	(declare (assoc
		cluster_ids (values (apply "append" (get result "cases")) )
	))

	(declare (assoc
		num_unclustered (size (filter (lambda (= -1 (current_value))) cluster_ids))
	))

	(print "Iris has 3 (or 4) clusters and some unclustered: ")
	(call assert_true (assoc
		obs (contains_value [4 5] (size (values cluster_ids .true)))
	))
	(print "A few unclustered: ")
	(call assert_true (assoc
		obs
			(and
				(> num_unclustered 0)
				(< num_unclustered 10)
			)
	))

	(call exit_if_failures (assoc msg "Clustering Iris into 3-4 clusters."))


	(assign (assoc
		result
			(call_entity "howso" "react" (assoc
				context_features features
				context_values [[4 3 1 0.1 0]]
				action_features [".cluster_id"]
			))
	))
	(call keep_result_payload)

	(print "Predicts cluster 1: ")
	(call assert_same (assoc
		exp [1]
		obs (get result ["action_values" 0])
	))

	(print "Outputs non clustered DC and SC in details:")
	(call assert_not_null (assoc
		obs (get result ["non_clustered_distance_contribution" 0])
	))
	(call assert_not_null (assoc
		obs (get result ["non_clustered_similarity_conviction" 0])
	))


	(assign (assoc
		result
			(call_entity "howso" "react" (assoc
				context_features features
				context_values [[6 2 4 1 1]]
				action_features [".cluster_id"]
			))
	))
	(call keep_result_payload)

	(print "Predicts unclustered -1: ")
	(call assert_same (assoc
		exp [-1]
		obs (get result ["action_values" 0])
	))

	(assign (assoc
		result
			(call_entity "howso" "react" (assoc
				preserve_feature_values features
				case_indices [["my_session" 149]]
				action_features [".cluster_id"]
			))
	))
	(call keep_result_payload)

	(print "Gets last cluster (3 or 4) from existing case: ")
	(call assert_true (assoc
		obs (contains_value [3 4] (get result ["action_values" 0 0]))
	))

	(call exit_if_failures (assoc msg "Predicts case clusters."))


	(destroy_entities "howso")
	(call (load "unit_test_howso.amlg") (assoc name "ut_h_clustering.amlg" skip_init .true) )

	(assign (assoc
		data (load "unit_test_data/wine_combined.csv")
	))

	(assign (assoc
		features (first data)
		training_data (tail data)
	))

	(call_entity "howso" "train" (assoc
		features features
		cases training_data
		session "my_session"
	))

	(call_entity "howso" "analyze" (assoc context_features (trunc features) ))

	(print "Clustering Wine...\n")

	(call_entity "howso" "react_into_features" (assoc
		features (trunc features)
		clustering "custom_cluster_id"
	))

	(assign (assoc
		result (call_entity "howso" "get_cases" (assoc features [ "custom_cluster_id"] ))
	))
	(call keep_result_payload)


	(assign (assoc
		cluster_ids (values (apply "append" (get result "cases")))
	))

	(assign (assoc
		num_unclustered (size (filter (lambda (= -1 (current_value))) cluster_ids))
	))

	(assign (assoc
		result
			(call_entity "howso" "get_cases" (assoc
				features [ "custom_cluster_id" ".session_training_index"]
			))
	))
	(call keep_result_payload)

	(declare (assoc
		;ground truth is that all cases not in the first 10 are supposedly in cluster 1
		cluster_1_expected_indices_map (zip (range 10 128))

		;get the indices of all cases in cluster 1
		cluster_1_clustered_indices_map
			(zip
				(map
					(lambda (last (current_value)))
					(filter (lambda (= 1 (first (current_value)))) (get result "cases"))
				)
			)
	))

	(declare (assoc
		cluster_1_commonality
			(/
				(commonality
					cluster_1_expected_indices_map
					cluster_1_clustered_indices_map
					{ "recursive_matching" .false }
				)
				(+ 1 (max (size cluster_1_clustered_indices_map) (size cluster_1_expected_indices_map)) )
			)
	))

	;compute average commonality
	(print "Expected commonality for the big cluster is over 0.9 (" cluster_1_commonality "): ")
	(call assert_true (assoc
		obs (> cluster_1_commonality 0.9)
	))


	(print "Very few unclustered (" num_unclustered "): ")
	(call assert_true (assoc
		obs
			(and
				(> num_unclustered 0)
				(< num_unclustered 5)
			)
	))

	(declare (assoc
		small_cluster_size (size (filter (lambda (= 2 (current_value))) cluster_ids))
	))

	(if small_cluster_size
		(seq
			(print "Small Cluster is about 10 cases: " small_cluster_size " ")
			(call assert_approximate (assoc
				exp 10
				obs small_cluster_size
				thresh 2
			))

			(print "First 10 cases are clustered together into the small cluster: ")
			(call assert_same (assoc
				obs (values (unzip cluster_ids (range 0 9)) .true)
				exp [2]
			))

			(call exit_if_failures (assoc msg "Clustering Wine into two clusters."))

			(assign (assoc
				result
					(call_entity "howso" "get_cases" (assoc
						condition { "custom_cluster_id" { "exclude" [1 -1]}}
						features [".session_training_index"]
					))
			))
			(call keep_result_payload)
			(print "Condition to ignore cluster 1 and unclustered cases returns the small cluster cases only: ")
			(call assert_approximate (assoc
				exp 10
				obs (size (get result "cases"))
				thresh 2
			))

			(assign (assoc
				result
					(call_entity "howso" "get_cases" (assoc
						condition { "custom_cluster_id" { "include" 2 }}
						features [".session_training_index"]
					))
			))
			(call keep_result_payload)
			(print "Condition to only include cluster 2 returns the small cluster cases only: ")
			(call assert_approximate (assoc
				exp 10
				obs (size (get result "cases"))
				thresh 2
			))
		)

		(print "\nFAILED to cluster into 2 clusters (not always unexpected)\n\n")
	)

	(call exit_if_failures (assoc msg unit_test_name))
)
