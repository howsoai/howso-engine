;Howso API Labels:
;
;	"clean_data"
;	"clear_conviction_thresholds"
;	"compute_conviction_of_features"
;	"batch_react_group"
;	"create_trainee"
;	"delete"
;	"get_num_training_cases"
;	"edit_cases"
;	"get_sessions"
;	"get_session_metadata"
;	"set_session_metadata"
;	"get_session_indices"
;	'get_session_training_indices"
;	"impute"
;	"load"
;	"train"
;	"react"
;	"react_series"
;	"batch_react"
;	"append_to_series_store"
;	"remove_series_store"
;	"remove_session"
;	"get_cases"
;	"save"
;	"copy_subtrainee"
;	"rename_subtrainee"
;	"set_conviction_upper_threshold"
;	"set_conviction_lower_threshold"
;	"set_feature_attributes"
;	"get_feature_attributes"
;	"get_metadata"
;	"set_metadata"
;	"set_substitute_feature_values"
;	"get_substitute_feature_values"
;	"react_into_features"
;	"retrieve_extreme_cases_for_feature"
;	"auto_analyze"
;	"analyze"
;	"set_random_seed"
;	"get_internal_parameters"
;	"set_internal_parameters"
;	"set_auto_ablation_params"
;	"get_auto_ablation_params"
;	"set_auto_analyze_params"
;	"move_cases"
;	"remove_cases"
;	"reset_parameter_defaults"
;	"get_trainee_version"
;	"remove_feature"
;	"add_feature"
;	"react_into_trainee"
;	"get_feature_residuals"
;	"get_feature_mda"
;	"get_feature_contributions"
;	"get_prediction_stats"
;	"get_marginal_stats"
;	"pairwise_distances"
;	"distances"
;	"set_influence_weight_threshold"
;	"export_trainee"
;	"upgrade_trainee"
;	"get_api"
;	"get_revision"
;	"evaluate"
;	"get_hierarchy"
;	"execute_on_subtrainee"
;
; Style notes:
; all methods are assumed to have null values as defaults for parameters
; any methods that need non-null default parameters are inside (declare) blocks, where the non-null defaults are explicitly defined
; "methods" should be #lower_case_snake_case in howso.amlg, #UpperCaseCamelCase in trainee_template
; 			internal helper methods should be private, #!snake_case in howso.amlg or #!UpperCaseCamelCase in trainee_template.amlg
; "attributes" of the model should be lowerCaseCamelCase
; parameters and "local variables" should be lower_case_snake_case
; parameters/variables and attributes that are sets or assocs should end with "_map" or "Map" respectively for readability (or _set and Set)

;performs the training and management of trainees
(null

	;concatenated version
	#version (get (load (concat filepath "version.json")) "version")
	#major_version 0
	#minor_version 0
	#point_version 0


	;export trainee's metadata, case and session data into json files.
	;this method should be run by a script from the ./migrations folder
	;
	;parameters:
	; trainee: name of trainee
	; decode_cases: flag, default false. if true will decode (e.g., convert from epoch to datetime) any encoded feature values
	;				when exporting cases If false case feature values will be exported just as they are stored in the trainee
	; root_filepath: base path to Howso Engine Core installation
	; trainee_filepath: optional, base path from which to load persisted trainee
	; separate_files: optional flag, if true will load each case from its individual file
	#export_trainee
		(declare
			(assoc decode_cases (false) )

			(declare (assoc trainee_is_loaded (contains_value (contained_entities) trainee) ))
			(declare (assoc
				loaded_successfully_id
					(if (not trainee_is_loaded)
						(get (call load (assoc filename trainee filepath trainee_filepath)) (list "payload" "name"))
						;else trainee is already loaded, output is same as a succssfull load
						trainee
					)
				migration_filepath (concat root_filepath !migration_folder)
			))

			(if (!= trainee loaded_successfully_id)
				(conclude
					(call !return (assoc errors (list "Failed to load trainee: invalid filepath or filename provided.") ))
				)
			)

			(call !export_trainee_metadata (assoc trainee trainee migration_filepath migration_filepath))

			(if decode_cases
				(call !export_cases_and_sessions_decoded (assoc trainee trainee migration_filepath migration_filepath))

				(call !export_cases_and_sessions (assoc trainee trainee migration_filepath migration_filepath))
			)

			;if trainee wasn't loaded to begin with, unload it from memory
			(if (not trainee_is_loaded) (destroy_entities trainee))

			(call !return)
		)


	;update version to latest and overwrite persisted trainee, auto importing any exported data.
	;this method should be run by a script from the ./upgrade_migration folder
	;
	;parameters:
	; trainee: name of trainee to import and update
	; root_filepath: base path to Howso Engine Core installation
	; trainee_filepath: optional, base path from which to load persisted trainee
	; separate_files: optional flag, if true will load each case from its individual file
	#upgrade_trainee
		(seq
			(declare (assoc
				;metadata json should be in the format of: { label : value }
				import_metadata_map (load (concat root_filepath !migration_folder trainee ".meta.json") )
				;cases and sessions json should be in the format of: { entity_id : { feature : value } }
				import_cases_and_sessions_map (load (concat root_filepath !migration_folder  trainee ".exp.json") )
				trainee_is_loaded (contains_value (contained_entities) trainee)
			))

			(declare (assoc
				loaded_successfully_id
					(if (not trainee_is_loaded)
						;don't need to load existing trainee if are going to be importing all exportable data
						(if (and (!= (null) import_metadata_map) (!= (null) import_cases_and_sessions_map) )
							(get (call create_trainee (assoc filepath root_filepath)) (list "payload" "name"))

							(get (call load (assoc filename trainee filepath trainee_filepath)) (list "payload" "name"))
						)
						;else trainee is already loaded, output is same as a succssfull load
						trainee
					)
			))

			(if (!= trainee loaded_successfully_id)
				(conclude
					(call !return (assoc errors (list "Failed to load trainee: invalid filepath or filename provided") ))
				)
			)

			;run the update
			(declare (assoc
				output
					(call !update_trainee_code (assoc
						trainee trainee
						root_filepath root_filepath
						import_metadata_map import_metadata_map
						import_cases_and_sessions_map import_cases_and_sessions_map
					))
			))

			(if (= (null) output)
				(conclude
					(call !return (assoc errors (list "Failed to instantiate trainee: check permissions and validate installation.") ))
				)
			)

			;save the updated trainee
			(call save (assoc trainee trainee filename trainee filepath trainee_filepath))

			;print statement for use in utility scripts: upgrade_trainee and export_trainee
			(print
				"Updated " trainee " to version: "
				(retrieve_from_entity trainee "majorVersion") "."
				(retrieve_from_entity trainee "minorVersion") "."
				(retrieve_from_entity trainee "pointVersion")
				"\n"
			)

			;if trainee wasn't loaded to begin with, unload it from memory
			(if (not trainee_is_loaded) (destroy_entities trainee))

			(call !return)
		)


	;returns a structure containing all of the API details for this module
	#get_api
		(seq
			(declare (assoc
				api
					(assoc
						"description"
						(get_entity_comments)

						"labels"
						(map
							(lambda
								(assoc
									"description" (current_value 1)
									"parameters" (get_entity_comments (null) (current_index 1) (true))
								)
							)
							(get_entity_comments (null) (null) (true))
						)
					)
			))

			;output api with all 'breeding' labels removed
			(call !return (assoc
				payload
					(set api "labels"
						(remove (get api "labels") (list "initialize_breeding" "breeder_load_point"))
					)
			))
		)

	; -----------------------------------------------------------------------------
	; labels below are used internally and should NOT be referenced by outside  API calls
	; -----------------------------------------------------------------------------

	#!migration_folder "migrations/"

	;set the private label !file_extension during deployment and clear out this method so that the file extension cannot be edited after deployment.
	;This should be run once by the deployment script.
	#initialize_for_deployment
		(declare
			(assoc file_extension "caml")
			(assign_to_entities (assoc !file_extension file_extension ))

			;clear out this label so that it can't be run again
			(assign_to_entities (assoc initialize (null)))
		)

	;loads the breeding framework so it can be called and sets up a manifest such that it can keep track of entity evaluations for breeding
	#initialize_breeding
		(seq
			(direct_assign_to_entities (assoc breeder_load_point (load (concat filepath "breeder" "." !file_extension))))
			(call "initialize_population_manifest")

			;evaluate to indicate it worked
			(!= breeder_load_point (null))
		)

	;label from which to load the breeder code into so that its labels can be loaded
	#breeder_load_point (null)

	;internal label for GP entities
	#!breeder_manifest "_breeder_manifest"

	;default value to use for filepath when calling save or load
	#filepath "./"

	;location of Howso Engine Core and trainee_template files, used for upgrading trainees (referencing
	#root_filepath "./"

	;default value to use for filename when calling save or load
	#filename "default_trainee"

	;location of trainee template
	#!trainee_template_filename "trainee_template"

	;current trainee being processed
	#trainee "TestTrainee"

	;valid extensions are:
	; amlg : raw amalgam code
	; caml : compressed amalgam, binary format
	#!file_extension "amlg"

	;debug value, if set to something other than 0 will parse debug prints when a trainee is created
	#debug_print 0


	;Method to update a trainee by overwriting its data and running all version dependent migration scripts.
	;
	;parameters:
	; trainee: name of trainee
	; root_filepath: base path to Howso Engine Core installation
	; import_metadata_map: optional imported metadata map, if one existed for this trainee
	; import_cases_and_sessions_map: optional imported cases and sessions map, if one existed for this trainee
	#!update_trainee_code
		(seq
			(declare (assoc temptrainee (concat "_temptrainee" (rand)) ))
			(load_entity (concat root_filepath !trainee_template_filename "." !file_extension) temptrainee (false) (false))

			;this can only happen if the trainee_template file fails to load, meaning probably a bad installation
			(if (not (contains_entity temptrainee))
				(conclude (null))
			)

			(call_entity temptrainee "Initialize" (assoc trainee_id (retrieve_from_entity trainee "traineeId")))

			(declare (assoc
				old_major_version (retrieve_from_entity trainee "majorVersion")
				old_minor_version (retrieve_from_entity trainee "minorVersion")
				old_point_version (retrieve_from_entity trainee "pointVersion")
				imported_metadata (false)
			))

			;if not importing metadata from saved file, then copy it from the persisted trainee
			(if (= (null) import_metadata_map)
				(let
					(assoc
						;create a list of all the matadata labels
						labels_to_keep (indices (first (retrieve_from_entity temptrainee "InitializeValues")))
						old_labels (indices (first (retrieve_from_entity trainee "InitializeValues")))
					)

					;keep only those that are in the old trainee
					(assign (assoc
						labels_to_keep (filter (lambda (contains_label trainee (current_value))) labels_to_keep)

						;set import_metadata_map to values from the old trainee
						import_metadata_map (zip old_labels (retrieve_from_entity trainee old_labels) )
					))

					;for each label pull its value from the old trainee and overwrite it in the new one
					(assign_to_entities temptrainee (zip labels_to_keep (retrieve_from_entity trainee labels_to_keep)))
				)

				;else overwrite old version from exported file instead of from trainee
				(assign (assoc
					imported_metadata (true)
					old_major_version (get import_metadata_map "majorVersion")
					old_minor_version (get import_metadata_map "minorVersion")
					old_point_version (get import_metadata_map "pointVersion")
				))
			)

			;overwrite trainee code with the new code, this does not overwrite contained entities (cases, sessions),
			;but does overwrite all labels including versions with new ones
			(assign_entity_roots trainee (retrieve_entity_root temptrainee))

			;import cases and sessions from saved json and re-create them in the trainee
			(if import_cases_and_sessions_map
				;iterate over all the entities and re-create them as contained entities with corresponding features and values
				(map
					(lambda
						(create_entities
							(list trainee (current_index 1))
							(set_type
								(zip_labels
									(indices (current_value))
									(values (current_value))
								)
								(null)
							)
						)
					)
					import_cases_and_sessions_map
				)
			)

			;import metadata into trainee from exported file
			(if imported_metadata
				;store data_map into trainee without the old version information and with parsed code
				(seq
					(assign (assoc
						import_metadata_map
							(set import_metadata_map
								"featureCustomDerivedMethods"
								(parse (get import_metadata_map "featureCustomDerivedMethods"))
							)
					))
					(assign_to_entities trainee (remove import_metadata_map (list "majorVersion" "minorVersion" "pointVersion")) )
				)
			)

			;recreate custom derive feature code on trainee if it has derived features
			(call !recreate_feature_custom_derived_methods (assoc trainee trainee))

			(declare (assoc migration_filepath (concat root_filepath !migration_folder) ))

			;perform all custom version-based conversions on metadata/cases/sessions here now that they are stored in the trainee
			(declare (assoc migration_conversions (load (concat migration_filepath "migrations" "." !file_extension))))

			;filter out all script versions older than the version of the trainee being upgraded
			(declare (assoc
				migration_versions
					(filter
						(lambda (let
							(assoc
								file_versions (split (current_value 1) "\\.")
								major 0
								minor 0
								point 0
							)
							(assign (assoc
								major (first file_versions)
								minor (get file_versions 1)
								point (last file_versions)
							))

							;keep files with newer major version. if major is same, consider minor version, etc.
							(if (> major old_major_version)
								(true)

								;filter out older major versions
								(< major old_major_version)
								(false)

								(> minor old_minor_version)
								(true)

								;major is same, filter out older minor versions
								(< minor old_minor_version)
								(false)

								(> point old_point_version)
								(true)

								;else filter out any version that is same or older
								(false)
							)
						))
						(sort (indices (first migration_conversions)))
					)
			))

			;execute all the necessary conversion scripts in ascending version order
			(map
				(lambda (call (get (first migration_conversions) (current_value))))
				migration_versions
			)

			(accum_to_entities trainee (assoc revision 1))
			(destroy_entities temptrainee)

			;output true on success
			(true)
		)


	;Export trainee metadata in json format as a dict of: { label : value }
	;
	;parameters:
	; trainee: name of trainee, reference for filename
	; migration_filepath: path to migration folder where migration scripts are stored
	#!export_trainee_metadata
		(declare
			(assoc
				meta_labels_to_persist (indices (get (retrieve_from_entity trainee "InitializeValues")  0))
				meta_values_to_persist (list)
			)

			(assign (assoc
				meta_values_to_persist
					(map
						(lambda
							;code needs to be stored as a string
							(if (= "featureCustomDerivedMethods" (current_value))
								(unparse (retrieve_from_entity trainee (current_value)))

								(retrieve_from_entity trainee (current_value))
							)

						)
						meta_labels_to_persist
					)
			))

			;ensure the version of the trainee is exported along with the data
			(accum (assoc
				 meta_values_to_persist (retrieve_from_entity trainee (list "majorVersion" "minorVersion" "pointVersion"))
				 meta_labels_to_persist (list "majorVersion" "minorVersion" "pointVersion")
			))

			(store
				(concat migration_filepath trainee ".meta.json")
				(zip meta_labels_to_persist meta_values_to_persist)
			)
		)


	;Export entities in json format as they are currently stored in the trainee
	;as dict of:  { entity_id : { feature : value } }
	;
	;parameters:
	; trainee: name of trainee, reference for filename
	; migration_filepath: path to migration folder where migration scripts are stored
	#!export_cases_and_sessions
		(store
			(concat migration_filepath trainee ".exp.json")
			(map
				(lambda
					(get_all_labels
						(retrieve_entity_root (list trainee (current_index 1)) (true))
					)
				)
				(zip (contained_entities trainee))
			)
		)


	;Export entities in json format, keeping all original case values as they were trained,
	;instead of whatever they are encoded internally.
	;as dict of:  { entity_id : { feature : value } }
	;Decode nominal encoding, round and convert from epoch back to correct datetime formats as necessary
	;
	;parameters:
	; trainee: name of trainee, reference for filename
	; migration_filepath: path to migration folder where migration scripts are stored
	#!export_cases_and_sessions_decoded
		(seq

			(declare (assoc
				has_encoded_features (retrieve_from_entity trainee "hasEncodedFeatures")
				has_rounded_features (retrieve_from_entity trainee "hasRoundedFeatures")
				has_datetime_features (retrieve_from_entity trainee "hasDateTimeFeatures")
			))

			;if there are no encoded features, run the raw ExportCasesAndSessions call
			(if (= (false) has_encoded_features has_rounded_features has_datetime_features)
				(conclude (call !export_cases_and_sessions))
			)

			(store
				(concat migration_filepath trainee ".exp.json")
				(map
					(lambda (let
						(assoc
							;assoc of feature -> feature value
							entity_code_map	(get_all_labels (retrieve_entity_root (list trainee (current_index 2)) (true)) )
						)

						;"case" entity has a label named ".session", decode values as needed
						(if (contains_index entity_code_map ".session")
							(zip
								(indices entity_code_map)
								;decode the values accordingly
								(if has_encoded_features
									(call_entity trainee "ConvertToOutput" (assoc
										features (indices entity_code_map)
										feature_values (values entity_code_map)
										has_rounded_features has_rounded_features
										has_datetime_features has_datetime_features
									))

									has_rounded_features
									(call_entity trainee "RoundContinuousFeatures" (assoc
										features (indices entity_code_map)
										feature_values (values entity_code_map)
									))
								)
							)

							;else non-case entity, output as-is
							entity_code_map
						)
					))
					(zip (contained_entities trainee))
				)
			)
		)


	;Method to re-create the featureCustomDerivedMethods label from attributes for a trainee, used when upgrading a trainee
	#!recreate_feature_custom_derived_methods
		(let
			(assoc
				custom_derived_features_map
					(filter
						(lambda (or
							(!= (null) (get (current_value) "auto_derive_on_train"))
							(!= (null) (get (current_value) "derived_feature_code"))
						))
						(retrieve_from_entity trainee "featureAttributes")
					)
			)

			;only if there are derived features
			(if (size custom_derived_features_map)
				(let
					(assoc
						;filter features, leaving only those with custom derivations
						custom_derived_features_map
							(filter
								(lambda (or
									(= "custom" (get (current_value) (list "auto_derive_on_train" "derive_type")))
									(!= (null) (get (current_value) "derived_feature_code"))
								))
								custom_derived_features_map
							)
					)

					;cache all the custom specified derivation code into trainee
					(assign_to_entities trainee (assoc
						featureCustomDerivedMethods
							(call_entity trainee "ComposeCustomDerivedMethods" (assoc
								custom_derived_features_map custom_derived_features_map
							))
					))
				)
			)
		)


	;method that rewrites the trainee code such that any comments that start with '^^^' are parsed as code to print out debug info
	#!parse_debug_print
		(seq
			(assign_entity_roots trainee
				(rewrite
					(lambda
						(let
							(assoc
								comments (get_comments (current_value 1))
								;list to hold indivdiual lines of 'debug' comments that should be parsed as code
								debug_code (list)
							)
							(if (!= (null) comments)
								(let
									(assoc chars (explode comments))
									(declare (assoc
										carriage_indices (filter (lambda (= (get chars (current_value)) "\r")) (indices chars))
										prev_index 0
									))
									(accum (assoc carriage_indices (size chars)))

									(declare (assoc
										individual_comment_lines
											(map
												(lambda
													(let
														(assoc line (apply "concat" (unzip chars (range prev_index (- (current_value 1) 1)))))
														;adjust for "\r\n"
														(assign (assoc prev_index (+ 2 (current_value 1))))
														line
													)
												)
												carriage_indices
											)
									))

									(map
										(lambda
											;if comment starts with ^^^, parse it as code
											(if (= "^^^" (trunc (current_value) 3))
												(accum (assoc debug_code (tail (current_value 1) (- (size (current_value 1)) 3)  )))
											)
										)
										individual_comment_lines
									)
								)
							)

							(set_labels
								;if there is debug code, pre-pend it above its code block, and then change from 'list' to 'seq' to
								;ensure that the original code block isn't encompassed in a list
								(if (size debug_code)
									(set_type
										(append
											(map
												(lambda (parse (current_value)))
												debug_code
											)
											(get_value (current_value))
										)
										"seq"
									)

									;else just output the code
									(get_value (current_value))
								)

								(get_labels (current_value))
							)
						)
					)
					(retrieve_entity_root trainee 1)
				)
			)
			(assign_to_entities trainee (assoc debug_print debug_print ))
		)

)
