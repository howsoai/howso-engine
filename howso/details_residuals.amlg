;Contains helper methods for calculating case and feature residuals and optionally prediction stats for details and explanations.
(null

	;Helper method to compute and add to output local feature residuals and optionally prediction stats
	#!ComputeReactFeatureResiduals
	(declare
		(assoc
			relevant_features (append context_features action_features)
			local_case_ids
				(contained_entities
					filtering_queries
					(query_nearest_generalized_distance
						k_parameter
						context_features
						context_values
						p_parameter
						feature_weights
						!queryDistanceTypeMap
						query_feature_attributes_map
						feature_deviations
						(null)
						dt_parameter
						(if valid_weight_feature weight_feature (null))
						;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
						"fixed rand seed"
						(null)
						!numericalPrecision
					)
				)
			local_feature_case_id_map (null)
		)

		;since full residuals computes residual per-feature for all the cases in the local space, if all or most cases have only nulls
		;for any feature, query for additional similar cases where the value is not null so that a local residual can be computed correctly
		(if (not robust_residuals)
			(let
				(assoc
					non_null_feature_cases_map
						;create a map of feature -> list of cases with non-null values, for features where all/most cases were null
						(filter (map
							(lambda (let
								(assoc feature (current_index 1))

								;filter out nulls from local cases
								(declare (assoc
									local_not_null_cases (filter (lambda (retrieve_from_entity (current_value) feature)) local_case_ids)
									num_cases_to_query
										;if k is a number, use the smaller of 5 or the k, else grab the min_k from the k_parameter tuple
										(if (~ 0 k_parameter) (min 5 k_parameter) (get k_parameter 1))
								))

								;if there are less than num_cases_to_query non-null values, need to find more local cases with non-nulls
								(if (< (size local_not_null_cases) num_cases_to_query)
									(append
										local_not_null_cases
										(contained_entities
											filtering_queries
											(if (size local_not_null_cases) (query_not_in_entity_list local_not_null_cases) [])
											(query_not_equals feature (null))
											(query_nearest_generalized_distance
												;if there are some local cases with non-null values, don't need to query for that many
												(- num_cases_to_query (size local_not_null_cases) )
												context_features
												context_values
												p_parameter
												feature_weights
												!queryDistanceTypeMap
												query_feature_attributes_map
												feature_deviations
												(null)
												dt_parameter
												(if valid_weight_feature weight_feature (null))
												;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
												"fixed rand seed"
												(null)
												!numericalPrecision
											)
										)
									)
								)
							))

							(remove (zip features) (indices !inactiveFeaturesMap))
						))
				)

				;cases had to be added to the original local_case_ids to account for null values in the local space
				(if (size non_null_feature_cases_map)
					(assign (assoc
						;create a map of feature -> case ids
						local_feature_case_id_map
							(map
								(lambda
									(if (contains_index non_null_feature_cases_map (current_index))
										(get non_null_feature_cases_map (current_index))
										;else keep the original case ids
										local_case_ids
									)
								)
								(remove (zip features) (indices !inactiveFeaturesMap))
							)
					))
				)
			)
		)

		(declare (assoc
			local_feature_metrics
				(if (>= dataset_size 2)
					(call !ExpandResidualValuesToUncertainty  (assoc
						feature_residuals_map
							(call !CalculateFeatureResiduals (assoc
								;only the features from the details
								context_features relevant_features
								features (or details_features relevant_features)
								case_ids local_case_ids
								local_feature_case_id_map local_feature_case_id_map
								regional_data_only .true
								robust_residuals robust_residuals
								compute_all_statistics compute_all_statistics
								;use the same hyperparameters that were used to make the original prediction
								custom_hyperparam_map hyperparam_map
								compute_null_uncertainties .false
							))
					))

					;can't compute residuals or prediction stats if dataset is too small
					(assoc
						"residual_map" (zip relevant_features 0)
						"prediction_stats" (zip relevant_features (assoc))
					)
				)
		))

		;append feature deviations to output if selected
		(if (or (get details "feature_full_residuals") (get details "feature_robust_residuals"))
			(accum (assoc output
				(if robust_residuals
					(assoc "feature_robust_residuals" (get local_feature_metrics "residual_map"))
					(assoc "feature_full_residuals" (get local_feature_metrics "residual_map"))
				)
			))
		)

		;append prediction stats to output if selected
		(if (get details "prediction_stats")
			(accum (assoc
				output
					(assoc
						"prediction_stats"
							(append
								(keep
									(get local_feature_metrics "prediction_stats")
									;Only keep the selected prediction stats
									(append selected_prediction_stats "residual_map")
								)
								(if (contains_value selected_prediction_stats "mae")
									(assoc mae (get local_feature_metrics "residual_map"))
								)
							)
					)
			))
		)
	)

	;Helper method to compute and add to output local feature residuals and optionally prediction stats
	#!ComputeReactFeatureDeviations
	(declare
		(assoc
			relevant_features (append context_features action_features)
			local_case_ids
				(contained_entities
					filtering_queries
					(query_nearest_generalized_distance
						k_parameter
						context_features
						context_values
						p_parameter
						feature_weights
						!queryDistanceTypeMap
						query_feature_attributes_map
						feature_deviations
						(null)
						dt_parameter
						(if valid_weight_feature weight_feature (null))
						;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
						"fixed rand seed"
						(null)
						!numericalPrecision
					)
				)
		)

		(assign (assoc
			react_feature_deviations
				(get
					(call !ExpandResidualValuesToUncertainty  (assoc
						feature_residuals_map
							(call !CalculateFeatureResiduals (assoc
								features (or details_features relevant_features)
								context_features relevant_features
								case_ids local_case_ids
								regional_data_only .true
								robust_residuals "deviations"
								;use the same hyperparameters that were used to make the original prediction
								custom_hyperparam_map hyperparam_map
								compute_null_uncertainties .false
								weight_feature (if valid_weight_feature weight_feature (null))
								valid_weight_feature valid_weight_feature
							))
					))
					"residual_map"
				)
		))

		(if (get details "feature_deviations")
			(accum (assoc
				output (assoc feature_deviations react_feature_deviations)
			))
		)
	)

	;calculate residuals for a given case, assuming the case is already not in the dataset
	;outputs an assoc of features -> residual value (mean absolute error for continuous, difference in categorical action probability for categorical)
	;parameters:
	; context_features: features to use as contexts in residuals calculations, may include action_features
	; action_features: features for which to calculate residuals
	; case_value_map : map of case values, i.e. the expected values
	; ignore_case: case_id, if set will query for K+1 cases and ignore the perfect matching case during the reaction
	#!CalculateResidualsForCase
	(declare
		(assoc
			context_features (list)
			action_features (list)
			case_value_map (assoc)
			ignore_case (null)
			case_residuals_map (null)
		)

		;if dataset is too small to compute residuals, output fixed values
		(if (<= dataset_size 2)
			(conclude
				(seq
					(if (get details "feature_full_residuals_for_case")
						(accum (assoc output (assoc "feature_full_residuals_for_case" (zip features 0)) ))
					)
					(if (get details "feature_robust_residuals_for_case")
						(accum (assoc output (assoc "feature_robust_residuals_for_case" (zip features 0)) ))
					)
					(if (get details "feature_full_residual_convictions_for_case")
						(accum (assoc output (assoc "feature_full_residual_convictions_for_case" (zip features 1)) ))
					)
				)
			)
		)

		(declare (assoc
			context_map (keep case_value_map context_features)
			inactive_features_zeros_map (assoc)
		))

		(if (and
				!tsTimeFeature
				(contains_index context_map ".series_index")
			)
			(declare (assoc
				undefined_ts_features
					(let
						(assoc
							ts_feature_lag_amount_map (call !BuildTSFeatureLagAmountMap)
						)

						;list of features that are undefined for this case because of the series index (lags greater than series index, deltas/rates on not first case)
						(filter
							(lambda (and
								(contains_index ts_feature_lag_amount_map (current_value))
								(> (get ts_feature_lag_amount_map (current_value)) (get context_map ".series_index"))
							))
							action_features
						)
					)
			))
		)

		;remove any inactive features from all features lists so they are ignored during compute
		;and create an assoc of inactive feature -> 0 for requested action_features to add to output of all residual computations
		(if !inactiveFeaturesMap
			(assign (assoc
				features (filter (lambda (not (contains_index !inactiveFeaturesMap (current_value)))) features)
				inactive_features_zeros_map (map 0 (keep !inactiveFeaturesMap action_features))
			))
		)

		(if (get details "feature_robust_residuals_for_case")
			(call !CalculateCaseResiduals (assoc robust_residuals .true))
		)

		(if
			(or
				(get details "feature_full_residuals_for_case")
				(get details "feature_full_residual_convictions_for_case")
			)
			(let
				(assoc
					predicted_case_values_map (call !CalculateCaseResiduals (assoc robust_residuals .false))
				)
				(accum (assoc
					output
						(assoc
							"predicted_values_for_case"
								(zip
									(indices predicted_case_values_map)
									(call !ConvertToOutput (assoc
										features (indices predicted_case_values_map)
										feature_values (values predicted_case_values_map)
									))
								)
						)
				))
				(if (get details "feature_full_residual_convictions_for_case")
					(call !CalculateLocalCaseFeatureResidualConvictions)
				)
			)
		)
	)

	;Helper method to compute residuals for specified action_features on the case itself.
	;For full residuals flows outputs the assoc of feature -> predicted value
	#!CalculateCaseResiduals
	(seq
		(assign (assoc
			;create an assoc of action feature -> value by iterating over an assoc of action features so that it can be used later
			;to either output individual case residuals or to use these computed values in the ratio computation for residual conviction
			case_residuals_map
				(if robust_residuals
					;for each feature, do 30 reacts with randomly selected contexts
					(map
						(lambda (let
							(assoc
								expected_case_value (get case_value_map (current_index 1))
								action_feature (current_index 1)
								action_is_nominal (contains_index !nominalsMap (current_index 1))
								contexts_only_map (remove context_map (current_index 1))
								robust_predictions (list)
							)

							;if the case value is null, but nulls aren't allowed, return null as residual so it can be computed below
							(if (= (null) expected_case_value)
								(null)

								(seq
									(assign (assoc
										robust_predictions
											(range
												(lambda (let
													(assoc
														;randomly remove features from the context map
														filtered_context_map (filter (lambda (< (rand) .5)) contexts_only_map)
													)
													(declare (assoc
														reaction
															(call !ReactDiscriminative (assoc
																return_action_values_only .true
																context_features (indices filtered_context_map)
																context_values (values filtered_context_map)
																action_features (list action_feature)
																ignore_case ignore_case
																;bypass encoding since stored case values are all encoded and we're reacting to raw retrieved values
																skip_encoding 1
																;bypass decoding since computing distances to each reaction uses encoded numeric values
																skip_decoding 1
																force_targetless force_targetless
																substitute_output .false
																details (if action_is_nominal (assoc "categorical_action_probabilities" .true))
															))
													))

													;if feature is nominal get the categorical action probability for expected value, if it's null then set it to 0
													;else it's: 1 - probability
													(if action_is_nominal
														(let
															(assoc
																predicted_probability
																	(or (get reaction (list "categorical_action_probabilities" action_feature expected_case_value)) 0)
															)

															(- 1 predicted_probability)
														)

														;else this is a continuous feature, return the absolute difference between the expected and the actual
														(abs (- expected_case_value (get reaction 0)))
													)
												))
												1 30 1
											)
									))

									;return average of all the robust predictions for each feature
									(/ (apply "+" robust_predictions) 30)
								)
							)
						))
						;iterate over an assoc of action_features
						(zip action_features)
					)

					;else standard computation, do leave-one-out for each feature and predict it once
					(map
						(lambda (let
							(assoc
								filtered_context_features (indices (remove context_map (current_index 1)))
								expected_case_value (get case_value_map (current_index 1))
								action_feature (current_index 1)
								action_is_nominal (contains_index !nominalsMap (current_index 1))
							)

							(if (and
									!tsTimeFeature
									(contains_value undefined_ts_features action_feature)
								)
								;predicted value is null and residual is zero for all undefined TS features
								(conclude [(null) 0])
							)

							(let
								(assoc
									reaction
										(call !ReactDiscriminative (assoc
											return_action_values_only .true
											context_features filtered_context_features
											context_values (unzip context_map filtered_context_features)
											action_features (list action_feature)
											ignore_case ignore_case
											allow_nulls .true
											;bypass encoding since stored case values are all encoded and we're reacting to raw retrieved values
											skip_encoding 1
											;bypass decoding since computing distances to each reaction uses encoded numeric values
											skip_decoding 1
											force_targetless force_targetless
											substitute_output .false
											details (if action_is_nominal (assoc "categorical_action_probabilities" .true))
										))
								)

								;output pair of: [predicted value, residual] , will be separated outside the loop
								[
									(if action_is_nominal
										(get reaction ["action_values" 0])
										(get reaction 0)
									)

									;if feature is nominal get the categorical action probability for expected value, if it's null then set it to 0
									;else it's: 1 - probability
									(if action_is_nominal
										(let
											(assoc
												predicted_probability
													(or (get reaction (list "categorical_action_probabilities" action_feature expected_case_value)) 0)
											)

											(- 1 predicted_probability)
										)

										;else this is a continuous feature, return the absolute difference between the expected and the actual
										(abs (- expected_case_value (get reaction 0)))
									)
								]
							)
						))
						;output as an assoc of action feature -> values
						(zip action_features)
					)
				)
		))

		(declare (assoc predicted_case_values_map (assoc) ))

		;separate out predicted values and residuals into their individual maps
		(if (not robust_residuals)
			(seq
				(assign (assoc
					predicted_case_values_map
						(map
							(lambda (first (current_value)))
							case_residuals_map
						)
				))
				(assign (assoc
					case_residuals_map
						(map
							(lambda (last (current_value)))
							case_residuals_map
						)
				))
			)
		)

		;replace case residual nulls with computed values if nulls aren't allowed
		(if (contains_value case_residuals_map (null))
			(let
				(assoc
					;leave only features with null values
					;if computing robust residuals, all null_features are features for which the case had a null value
					;if computing full residuals, either the case had a null value or the predicted value was null
					null_features
						(indices (filter (lambda (= (null) (current_value))) case_residuals_map))
				)

				;iterate over all the null features and populate a map of feature -> adjusted residual value
				(declare (assoc
					null_case_residuals_map
						(map
							(lambda (let
								(assoc
									null_feature (current_index 1)
									filtered_context_features (indices (remove context_map (current_index 1)))
									null_feature_value (get case_value_map (current_index 1))
									num_local_cases (size regional_cases_influence_map)
									;list of all non null values for this null_feature in this regional data
									non_null_local_values (list)
								)

								(if (and
										!tsTimeFeature
										(contains_value undefined_ts_features null_feature)
									)
									;residual should be zero for undefined TS features
									(conclude 0)
								)

								(declare (assoc
									influential_cases_map
										(normalize (compute_on_contained_entities
											filtering_queries
											(query_nearest_generalized_distance
												k_parameter
												filtered_context_features
												(unzip context_map filtered_context_features)
												p_parameter
												feature_weights
												!queryDistanceTypeMap
												query_feature_attributes_map
												feature_deviations
												null_feature
												dt_parameter
												(if valid_weight_feature weight_feature (null))
												;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
												"fixed rand seed"
												(null)
												!numericalPrecision
											)
										))
								))

								;pull all values for this feature and filter out nulls
								(assign (assoc
									non_null_local_values
										(filter (map
											(lambda (retrieve_from_entity (current_value) null_feature))
											(indices influential_cases_map)
										))
								))

								(declare (assoc
									local_non_null_influence
										(if (size non_null_local_values)
											(apply "+" (values
												(filter
													(lambda
														(!= (null) (retrieve_from_entity (current_index) null_feature))
													)
													influential_cases_map
												)
											))

											;this number may be used as a divisor, so special fallback here
											; 1 / (2 * max_k)
											(/
												1
												(if (~ 0 k_parameter) k_parameter (get k_parameter 2) )
												2
											)
										)
								))

								(if (= (null) null_feature_value)
									;case value is null
									(if (contains_index !nominalsMap null_feature)
										;if nominal, output the percentage of the local data that is not null
										local_non_null_fraction

										;else continuous
										(let
											(assoc
												num_unique_local_values (size (values non_null_local_values .true ))
											)

											;if entire local data is null or only has 1 non-null value, use the global null residual
											(if (<= num_unique_local_values 1)
												(*
													(get !featureNullRatiosMap (list null_feature "null_residual"))
													local_non_null_influence
												)

												;else there are enough local values to compute local null residual
												(*
													(call !ComputeMAD (assoc vals non_null_local_values))
													local_non_null_influence
												)
											)
										)
									)

									;else feature value is not null, but was predicted as null
									(if (contains_index !nominalsMap null_feature)
										;if nominal, output the percentage of the local data that is null
										;(This shouldn't really be reached bc (null) will have a CAP that is used for the residual
										;in the above code)
										(- 1 local_non_null_influence)

										;else continuous
										(let
											(assoc
												num_unique_local_values (size (values non_null_local_values .true ))
											)

											;if entire local data is null or only has 1 non-null value, use the global null-value uncertainty
											(if (<= num_unique_local_values 1)
												;use the null-value uncertainty for the feature if one exists
												(if (and
														(~ [] (get feature_deviations null_feature))
														(!= (null) (get feature_deviations [null_feature 1]))
													)
													;feature deviation is a tuple of: [deviation, null-value, null-null]
													(get feature_deviations [null_feature 1])

													;else use the cached maximum null-null range as defined for the feature
													(get !featureNullRatiosMap (list null_feature "null_residual"))
												)

												;else there are enough local values to compute local null residual
												(/
													(call !ComputeMAD (assoc vals non_null_local_values))
													local_non_null_influence
												)
											)
										)
									)
								)

							))
							(zip null_features)
						)
				))

				(accum (assoc
					case_residuals_map null_case_residuals_map
				))
			)
		)

		;add case_feature_residuals to output if requested
		(if (or (get details "feature_full_residuals_for_case")  (get details "feature_robust_residuals_for_case"))
			(accum (assoc output
				(if robust_residuals
					(assoc "feature_robust_residuals_for_case" (append case_residuals_map inactive_features_zeros_map))
					(assoc "feature_full_residuals_for_case" (append case_residuals_map inactive_features_zeros_map))
				)
			))
		)

		;output predicted values
		predicted_case_values_map
	)

	#!CalculateLocalCaseFeatureResidualConvictions
	(declare
		(assoc
			action_features_map (keep case_value_map action_features)
			global_residuals_map (get hyperparam_map "featureResiduals")
		)


		(assign (assoc
			local_convictions_map
				(map
					(lambda
						;current_index is the feature
						;current_value is a list of residuals [local, case]
						(if (and
								!tsTimeFeature
								(contains_value undefined_ts_features (current_index))
							)
							;if an undefined TS feature (in the triangle/shadow), conviction should just be 1.0
							1.0

							;otherwise do proper logic:
							;conviction is: local / case residual, prevent divide by 0 by using the minimum residual instead if necesssary
							; conviction is expected surprisal E(I) divided by observed surprisal, I
							; C = E(I) / I
							; The expected surprisal E(I) is the dataset residual divided by the dataset residual: MR / MR = 1.0
							; The observed surprisal I is the observed residual divded by the dataset residual: OR / MR
							; So, E(I) / I = (MR / MR) / (OR / MR) = MR / OR
							; In this way, we can directly divide the dataset (global or local) residual by the observed residual to get conviction
							(if (= 0 (last (current_value)) )
								(/
									(call !LK_metric_exp (assoc
										difference (first (current_value 1))
										deviation (or (get global_residuals_map (current_index 1)) 0)
									))
									(call !LK_metric_exp (assoc
										difference (get !cachedFeatureMinResidualMap (current_index 1))
										deviation (or (get global_residuals_map (current_index 1)) 0)
									))
								)

								;prevent nan from divide by null, output null as-is when nulls are allowed
								(= (null) (last (current_value)))
								(null)

								(/
									(call !LK_metric_exp (assoc
										difference (first (current_value 1))
										deviation (or (get global_residuals_map (current_index 1)) 0)
									))
									(call !LK_metric_exp (assoc
										difference (last (current_value 1))
										deviation (or (get global_residuals_map (current_index 1)) 0)
									))
								)
							)
						)
					)
					;compute the local area residuals for each context feature by
					;a) finding the corresponding local data  using all context features without the specific residual feature
					;b) computing the feature residual in that local data
					(map
						(lambda (let
							(assoc
								;the feature for which to compute the residual
								residual_feature (current_index 1)
								;context features without the residual feature
								local_context_features (indices (remove context_map (current_index 1)))
								num_cases_to_query
									;if k is a number, use the smaller of 5 or the k, else grab the min_k from the k_parameter tuple
									(if (~ 0 k_parameter) (min 5 k_parameter) (get k_parameter 1))
							)

							(declare (assoc
								local_cases_tuple
									(compute_on_contained_entities
										filtering_queries
										(query_nearest_generalized_distance
											(replace k_parameter)
											(replace local_context_features)
											(replace (unzip case_value_map local_context_features))
											(replace p_parameter)
											(replace feature_weights)
											(replace !queryDistanceTypeMap)
											(replace query_feature_attributes_map)
											(replace feature_deviations)
											(null)
											(replace dt_parameter)
											(if valid_weight_feature (replace weight_feature) (null))
											;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
											"fixed rand seed"
											(null)
											(replace !numericalPrecision)
											residual_feature
										)
									)
							))

							(declare (assoc
								local_case_ids
									;if there are less than num_cases_to_query cases in local space that are non-null,
									;find num_cases_to_query cases with non-null values to be able to compute a residual value
									(if (>= (size (filter (last local_cases_tuple))) num_cases_to_query)
										(first local_cases_tuple)

										(contained_entities
											filtering_queries
											(query_not_equals residual_feature (null))
											(query_nearest_generalized_distance
												num_cases_to_query
												(replace local_context_features)
												(replace (unzip case_value_map local_context_features))
												(replace p_parameter)
												(replace feature_weights)
												(replace !queryDistanceTypeMap)
												(replace query_feature_attributes_map)
												(replace feature_deviations)
												(null)
												(replace dt_parameter)
												(if valid_weight_feature (replace weight_feature) (null))
												;use a fixed random seed to guarantee deterministic behavior for reacts (named "fixed rand seed")
												"fixed rand seed"
												(null)
												(replace !numericalPrecision)
												residual_feature
											)
										)
									)
							))

							(get
								(call !ExpandResidualValuesToUncertainty  (assoc
									feature_residuals_map
										(call !CalculateFeatureResiduals (assoc
											features (append local_context_features residual_feature)
											target_residual_feature residual_feature
											case_ids local_case_ids
											regional_data_only .true
											robust_residuals .false
											focal_case ignore_case
											;use the same hyperparameters that were used to make the original prediction
											custom_hyperparam_map hyperparam_map
											compute_null_uncertainties .false
										))
								))
								["residual_map" residual_feature]
							)
						))
						action_features_map
					)
					case_residuals_map
				)
		))

		(accum (assoc
			output
				(assoc
					"feature_full_residual_convictions_for_case"
						(append local_convictions_map (map 1 inactive_features_zeros_map))
				)
		))
	)

	;compute the LK Metric for a Laplace distribution given a difference and a deviation
	;difference and deviation should be positive already (this method won't take the absolute value)
	#!LK_metric_laplace
	(+
		difference
		(/
			(*
				(exp
					(/
						(- difference)
						deviation
					)
				)
				(+
					(* 3 deviation)
					difference
				)
			)
			2
		)
	)

	;exponential distribution LK metric given a difference and a deviation
	;Describes the difference between a random exponentially distributed variable and an exact value.
	; diff + (2 * dev^2) / (diff + 2 * dev)
	; source: http://lkmetric.patent.nazwa.pl/PROBABILITY_METRIC_doctoral_dissertation.pdf Appendix A.3 pg 135
	; Derivation of PM for exponential distribution
	#!LK_metric_exp
	(+
		difference
		(/
			(* 2 deviation deviation)
			(+ difference deviation deviation)
		)
	)
)