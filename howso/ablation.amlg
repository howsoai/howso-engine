;Contains methods for ablation flows.
(null

	;compute the entropy of the influence weights of the context's influential cases
	; features: list of features to react to
	; feature_values: optional list of feature values to react to
	; case_id: optional case id in the model to react to
	; use_case_weights: optional flag default true. if false, case weights will not be used during the react
	; weight_feature: optional, default '.case_weight'. name of feature whose values to use as case weights
	#!ComputeInfluenceWeightEntropy
	(declare
		(assoc
			features (list)
			feature_values (null)
			case_id (null)
			use_case_weights (true)
			weight_feature !autoAblationWeightFeature

			;internal only
			react_kwargs (assoc)
		)

        (if (not use_case_weights)
            (assign (assoc weight_feature ".none"))
        )

        (assign (assoc
            react_kwargs
                (assoc
                    context_features features
                    use_case_weights use_case_weights
                    weight_feature weight_feature
                    details (assoc influential_cases (true) )
                )
        ))

        (if
            ;if context_values are not null, we are reacting to a new case
            (!= feature_values (null))
			(accum "react_kwargs" (assoc context_values feature_values) )
			;elif case_id is not null, we are reacting to an existing case
			(!= case_id (null))
			(accum "react_kwargs" (assoc
				case_indices (retrieve_from_entity case_id (list ".session" ".session_training_index") )
				preserve_feature_values features
				leave_case_out (true)
			))
		)

		(declare (assoc
			influential_cases (get (call !SingleReact react_kwargs) "influential_cases")
		))

        (if
            ;if feature_values are not null, we are reacting to a new case. We ablate duplicate identical cases.
            (!= feature_values (null))
			(if (= feature_values (unzip (first influential_cases) features))
				;this concludes out through #ShouldNewCaseBeAblated directly into #TrainCreateCases.
				(conclude (conclude (false)))
			)
		)

		;compute the entropy of the influence weights as retrieved by react
		(entropy (map
			(lambda (get (current_value) ".influence_weight") )
			influential_cases
		))
	)

	;used to compute and store the influence weight entropies for all cases contained in the Trainee in #Analyze
	; features: list of features to use when determining influential cases.
	; label_name: optional name of the feature to store influence weight entropies in.
	#!ComputeAndStoreInfluenceWeightEntropies
	(let
		(assoc
			influence_weight_entropy_map
				||(map
					(lambda
						(call !ComputeInfluenceWeightEntropy (assoc
							case_id (current_index 1)
							features features
							use_case_weights use_case_weights
							weight_feature weight_feature
						))
					)
					(zip (call !AllCases))
				)
		)

		(call !StoreCaseValues (assoc
			case_values_map influence_weight_entropy_map
			label_name (or label_name !internalLabelInfluenceWeightEntropy)
		))

		(call !RecomputeAndCacheMaxInfluenceWeightEntropy)

		(accum_to_entities (assoc !revision 1))
		(assign_to_entities (assoc !hasInfluenceWeightEntropies (true)))
	)

	;initialize parameters and internal features related to auto ablation
	; weight_feature: optional, default '.case_weight'. name of feature whose values to use as case weights
	#!InitializeAutoAblation
	(declare
		(assoc weight_feature !autoAblationWeightFeature)

		(assign_to_entities (assoc !hasPopulatedCaseWeight (true)) )
		(accum_to_entities (assoc !revision 1) )
		(call !CreateCaseWeights (assoc feature_name weight_feature) )
	)

	;check the relative threshold map against the the current prediction stats map.
	;
	;parameters:
	; abs_threshold_map: a map of measure to a map of feature name to absolute score
	; prediction_stats_map: the prediction stats map.
	#!CheckAbsThresholds
	(declare
		(assoc
			abs_threshold_map (assoc)
			prediction_stats_map (assoc)
		)
		(map
			(lambda (map
				(lambda
					;If we are computing for rmse or r2 we check if we're over the threshold.
					; Otherwise, check that we're under.

					;(current_index 1) is the top-level index of abs_threshold_map, which is
					; comprised of the different measures (accuracy, precision, recall, rsmse... etc.)
					; that have thresholds defined.
					(if (contains_value (list "rmse" "r2") (current_index 1))
						;Use (current_index 2) and (current_index 1) to access the values in the prediction stats
						; maps, which have the same structure as the threshold map.

						;(current_value) is the numerical value of the threshold. Exceeding this should satisfy the
						; threshold and stop reduction.
						(>
							(get prediction_stats_map (list (current_index 2) (current_index 1)))
							(current_value)
						)
						(<
							(get prediction_stats_map (list (current_index 2) (current_index 1)))
							(current_value)
						)
					)
				)
				;(current_value) contains the threshold map for a specific measure, e.g. for accuracy {target 0.75}
				; would indicate an accuracy value of less than 0.75 would satisfy the threshold and stop reduction.
				(current_value)
			))
			abs_threshold_map
		)
	)

	;check the relative threshold map against the the current and previous prediction stats maps.
	;
	;parameters:
	; delta_threshold_map: a map of measure to a map of feature name to relative score
	; prev_prediction_stats_map: the previous prediction stats map.
	; new_prediction_stats_map: the new prediction stats map.
	#!CheckDeltaThresholds
	(declare
		(assoc
			delta_threshold_map (assoc)
			prev_prediction_stats_map (assoc)
			new_prediction_stats_map (assoc)
		)
		(map
			(lambda (map
				(lambda
					(>
						;If we are computing the delta on rmse or r2, subtract the prev from the new
						; and vice versa if we are not to ensure a positive value to trigger any thresholds.

						;(current_index 1) is the top-level index of delta_threshold_map, which is
						; comprised of the different measures (accuracy, precision, recall, rsmse... etc.)
						; that have thresholds defined.
						(if (contains_value (list "rmse" "r2") (current_index 1))
							;Use (current_index 2) and (current_index 1) to access the values in the prediction stats
							; maps, which have the same structure as the threshold map.
							(-
								(get new_prediction_stats_map (list (current_index 2) (current_index 1)))
								(get prev_prediction_stats_map (list (current_index 2) (current_index 1)))
							)
							(-
								(get prev_prediction_stats_map (list (current_index 2) (current_index 1)))
								(get new_prediction_stats_map (list (current_index 2) (current_index 1)))
							)
						)
						;(current_value) is the numerical value of the threshold. Exceeding this should satisfy the
						; threshold and stop reduction.
						(current_value)
					)
				)
				;(current_value) contains the threshold map for a specific measure, e.g. for accuracy {target 0.05}
				; would indicate a delta of greater than 0.05 would satisfy the threshold and stop reduction.
				(current_value)
			))
			delta_threshold_map
		)
	)

	;check the relative threshold map against the the current and previous prediction stats maps.
	;
	;parameters:
	; rel_threshold_map: a map of measure to a map of feature name to relative score
	; prev_prediction_stats_map: the previous prediction stats map.
	; new_prediction_stats_map: the new prediction stats map.
	#!CheckRelThresholds
	(declare
		(assoc
			rel_threshold_map (assoc)
			prev_prediction_stats_map (assoc)
			new_prediction_stats_map (assoc)
		)
		(map
			(lambda
				(map
					(lambda
						(>
							;If we are computing relative change in rmse or r2, then compute the
							; change as-is. If not, then we multiply the resulting % change by -1
							; since a negative  % change needs to trigger the threshold.

							;(current_index 1) is the top-level index of rel_threshold_map, which is
							; comprised of the different measures (accuracy, precision, recall, rsmse... etc.)
							; that have thresholds defined.
							(if (contains_value (list "rmse" "r2") (current_index 1))
								;Use (current_index 2) and (current_index 1) to access the values in the prediction stats
								; maps, which have the same structure as the threshold map.
								(/
									(- 
										(get new_prediction_stats_map (list (current_index 2) (current_index 1)))
										(get prev_prediction_stats_map (list (current_index 2) (current_index 1)))
									)
									(get prev_prediction_stats_map (list (current_index 2) (current_index 1)))
								)
								(- (/
									(- 
										(get new_prediction_stats_map (list (current_index 2) (current_index 1)))
										(get prev_prediction_stats_map (list (current_index 2) (current_index 1)))
									)
									(get prev_prediction_stats_map (list (current_index 2) (current_index 1)))
								))
							)
							;(current_value) is the numerical value of the threshold. Exceeding this should satisfy the
							; threshold and stop reduction.
							(current_value)
						)
					)
					;(current_value) contains the threshold map for a specific measure, e.g. for accuracy {target 0.05}
					; would indicate a % change of greater than 5% would satisfy the threshold and stop reduction.
					(current_value)
				)
			)
			rel_threshold_map
		)
	)

	;helper method which flattens the result of one of the !Check*Thresholds methods
	; to determine whether at least one of the thresholds was violated (true) or not (false).
	#!FlattenThresholdResultMap
	(declare
		(assoc
			threshold_result_map (assoc)
		)
		(apply "or"
			(values (map
				(lambda
					(apply "or" (values (current_value)))
				)
				threshold_result_map
			))
		)
	)

	;check all of the threshold maps against the current prediction stats map or the current
	; and previous prediction stats maps. Returns the threshold map that failed.
	;
	;parameters:
	; abs_threshold_map: a map of a measure to a map of feature name to absolute score threshold
	; delta_threshold_map: a map of measure to a map of feature name to delta score threshold
	; rel_threshold_map: a map of measure to a map of feature name to relative score threshold
	; prev_prediction_stats_map: the previous prediction stats map.
	; new_prediction_stats_map: the new prediction stats map.
	#!CheckThresholds
	(declare
		(assoc
			abs_threshold_map (assoc)
			delta_threshold_map (assoc)
			rel_threshold_map (assoc)
			prev_prediction_stats_map (assoc)
			new_prediction_stats_map (assoc)

			;internal
			abs_threshold_result_map (null)
			delta_threshold_result_map (null)
			output (assoc)
		)

		(assign (assoc
			abs_threshold_result_map
				(call !CheckAbsThresholds (assoc
					abs_threshold_map abs_threshold_map
					prediction_stats_map new_prediction_stats_map
				))
			delta_threshold_result_map
				(call !CheckDeltaThresholds (assoc
					delta_threshold_map delta_threshold_map
					prev_prediction_stats_map prev_prediction_stats_map
					new_prediction_stats_map new_prediction_stats_map
				))
			rel_threshold_result_map
				(call !CheckRelThresholds (assoc
					rel_threshold_map rel_threshold_map
					prev_prediction_stats_map prev_prediction_stats_map
					new_prediction_stats_map new_prediction_stats_map
				))
		))

		(if (call !FlattenThresholdResultMap (assoc threshold_result_map abs_threshold_result_map))
			(accum "output" ["abs"] abs_threshold_result_map)
		)
		(if (call !FlattenThresholdResultMap (assoc threshold_result_map delta_threshold_result_map))
			(accum "output" ["delta"] delta_threshold_result_map)
		)
		(if (call !FlattenThresholdResultMap (assoc threshold_result_map rel_threshold_result_map))
			(accum "output" ["rel"] rel_threshold_result_map)
		)

		output
	)

	;reduce the trained data by removing cases which have an influence weight entropy that falls above
	; a threshold.
	;
	;parameters:
	; distribute_weight_feature: optional, default ".case_weight". Name of feature whose values to use
	;   as case weights. Defaults to the set auto-ablation weight feature.
	; features: default all trained features. A list of features to use when computing influence weight entropies
	; influence_weight_entropy_threshold: optional, default 0.15. Cases with influence weight entropy above
	;   this quantile will be removed. This defaults to the auto-ablation default influence weight entropy threshold.
	; abs_threshold_map: A map of measure names (any of the prediction stats) to a map of feature name to threhsold
	;   value. Absolute thresholds will cause data reduction to stop when the any of the measure values for any of
	;   the features for which a threshold is defined go above the threshold (in the case of r2 and rmse) or below
	;   the threshold (in any other case).
	; delta_threshold_map: A map of measure names (any of the prediction stats) to a map of feature name to threhsold
	;   value. Delta thresholds will cause data reduction to stop when the delta between any of the measure values
	;   for any of the features for which a threshold is defined and its previous value go above the threshold.
	; rel_threshold_map: A map of measure names (any of the prediction stats) to a map of feature name to threhsold
	;   value. Relative thresholds will cause data reduction to stop when the relative change between any of the
	;   measure values for any of the features for which a threshold is defined and its previous value go above
	;   the threshold.
	; skip_auto_analyze: default false. Whether to skip auto analyzing as cases are removed.
	; batch_size: default 2000. The batch size to use when removing cases. The maximum influence weight entropy
	;   cases to keep is updated in between batches.
	; 
	#reduce_data
	(declare
		(assoc
			;{type "string"}
			distribute_weight_feature !autoAblationWeightFeature
			;{type "list" values "string"}
			features !trainedFeatures
			;{type "number"}
			influence_weight_entropy_threshold !autoAblationInfluenceWeightEntropyThreshold
			;{type "assoc"}
			abs_threshold_map (assoc)
			;{type "assoc"}
			delta_threshold_map (assoc)
			;{type "assoc"}
			rel_threshold_map (assoc)
			;{type "boolean"}
			skip_auto_analyze (false)
			;{type "number"}
			batch_size !ablationBatchSize
		)
		(call !ValidateParameters)

		;Declare variables for internal use.
		(declare (assoc
			max_influence_weight_entropy_to_keep .infinity
			cases (list)
			prev_prediction_stats_map (assoc)
			thresholds_enabled (or (size abs_threshold_map) (size delta_threshold_map) (size rel_threshold_map) )
			output (assoc)
		))

		;Ensure that ablation is initialized before we begin.
		(if (not !hasPopulatedCaseWeight)
			(call !InitializeAutoAblation (assoc
				weight_feature distribute_weight_feature
			))
		)

		;Also ensure that we have influence weight entropies.
		(if (not !hasInfluenceWeightEntropies)
			(call !ComputeAndStoreInfluenceWeightEntropies (assoc
				features features
				weight_feature distribute_weight_feature
				use_case_weights (true)
			))
		)

		(if thresholds_enabled
			(assign (assoc
				prev_prediction_stats_map
					(get (call !CalculateFeatureResiduals (assoc
						weight_feature distribute_weight_feature
						use_case_weights (true)
						compute_all_statistics (true)
						store_values (false)
					)) "prediction_stats")
			))
		)

		;Begin looping on data removal. The ultimate end condition is if the model gets too small
		; to continue removing cases.
		(while (< !autoAblationMinModelSize (call !GetNumTrainingCases))
			(assign (assoc
				cases
					(call !GetCasesByCondition (assoc
						condition
							(associate
								!internalLabelInfluenceWeightEntropy 
									(list
										(call !RecomputeAndCacheMaxInfluenceWeightEntropy (assoc
											influence_weight_entropy_threshold influence_weight_entropy_threshold
											weight_feature distribute_weight_feature
											cache_value (false)
										))
										.infinity
									)
							)
						num_cases
							(min batch_size (- (call !GetNumTrainingCases) !autoAblationMinModelSize))
					))
			))

			;if there are no cases which satisfy the criteria, then break.
			(if (not (size cases)) (conclude))

			(call !RemoveCases (assoc
				cases cases
				distribute_weight_feature distribute_weight_feature
			))

			(call !AutoAnalyzeIfNeeded (assoc
				skip_auto_analyze skip_auto_analyze
			))

			(if thresholds_enabled
				(let
					(assoc
						batch_threshold_info (null)
						new_prediction_stats_map
							(get (call !CalculateFeatureResiduals (assoc
								weight_feature distribute_weight_feature
								use_case_weights (true)
								compute_all_statistics (true)
								store_values (false)
							)) "prediction_stats")
					)
					(assign (assoc
						batch_threshold_info
							(call !CheckThresholds (assoc
								abs_threshold_map abs_threshold_map
								delta_threshold_map delta_threshold_map
								rel_threshold_map rel_threshold_map
								prev_prediction_stats_map prev_prediction_stats_map
								new_prediction_stats_map new_prediction_stats_map
							))
					))
					(if (apply "or" (values batch_threshold_info))
						(seq
							(accum "output" ["threshold_info"] batch_threshold_info)
							(conclude)
						)
						(assign (assoc
							prev_prediction_stats_map new_prediction_stats_map
						))
					)
				)
			)
		)

		(call !RecomputeAndCacheMaxInfluenceWeightEntropy (assoc
			influence_weight_entropy_threshold influence_weight_entropy_threshold
			weight_feature distribute_weight_feature
		))

		(accum_to_entities (assoc !revision 1))
		(call !Return (assoc 
			payload output
		))
	)

	;helper method which queries and returns the specified quantile of influence weight entropies
	; for use in data reduction and auto-ablation.
	; influence_weight_entropy_threshold: optional, default !autoAblationInfluenceWeightEntropyThreshold. cases with
	; 	influence weight entropy above this quantile will be removed
	; weight_feature: optional, default !autoAblationWeightFeature. name of feature whose values to use as case weights
	; cache_value: flag, default true.  when true will cache the computed value
	#!RecomputeAndCacheMaxInfluenceWeightEntropy
	(declare
		(assoc
			influence_weight_entropy_threshold !autoAblationInfluenceWeightEntropyThreshold
			weight_feature !autoAblationWeightFeature
			cache_value (true)
		)

		(declare (assoc
			quantile_value
				(compute_on_contained_entities (list
					(query_exists !internalLabelInfluenceWeightEntropy)
					(query_not_equals !internalLabelInfluenceWeightEntropy 0)
					(query_quantile
						!internalLabelInfluenceWeightEntropy
						influence_weight_entropy_threshold
						weight_feature
					)
				))
		))

		(if cache_value
			(assign_to_entities (assoc !autoAblationMaxInfluenceWeightEntropy quantile_value))
		)

		;output the value
		quantile_value
	)

	;determine whether a new case (one that is not in the Trainee) should be ablated (trained as weights) or kept.
	; a return value of true indicates that a case should be kept and a return value of false indicates that the case should be ablated.
	; features: list of features to react to
	; feature_values: list of feature values to react to
	; num_cases: number of current cases in the model
	#!ShouldNewCaseBeAblated
	(declare
		(assoc
			features (list)
			feature_values (list)

			;internal
			max_influence_weight_entropy_to_keep .infinity
		)

		;If we do not have influence weight entropies stored, ablation cannot happen.
		; So, always return true when that is the case.  The same is true for when there
		; are not enough cases in the model.
		(if
			(or
				(not (and !hasInfluenceWeightEntropies !autoAblationEnabled) )
				(< num_cases !autoAblationMinModelSize )
			)
			;return true, keep case / do not ablate
			(conclude (true))
		)

		(assign (assoc max_influence_weight_entropy_to_keep !autoAblationMaxInfluenceWeightEntropy  ))

		;if there is no influence weight entropy cached yet, do the caching here
		(if (= (null) max_influence_weight_entropy_to_keep)
			(seq
				(call !ComputeAndStoreInfluenceWeightEntropies (assoc features features))

				(assign (assoc max_influence_weight_entropy_to_keep !autoAblationMaxInfluenceWeightEntropy ))
			)
		)

		(+
			(or
				(> max_influence_weight_entropy_to_keep
					(call !ComputeInfluenceWeightEntropy (assoc
						features features
						feature_values feature_values
					))

				)
				; This is probably unnecessary but in case we cannot compute the requested influence weight
				; quantile return 1 as well.
				(= max_influence_weight_entropy_to_keep (null))
			)
		)
	)

	;Helper method called by train to see if ablation can be skipped altogether
	;outputs true if ablation can be skipped
	;parameters:
	; cases: list of cases from train method
	; num_cases: number of currently trained cases in the model
	#!CanTrainAblationBeSkipped
	(and
		(or
			(not (and !hasInfluenceWeightEntropies !autoAblationEnabled) )
			(< num_cases !autoAblationMinModelSize )
		)
		(= (null)
			!autoAblationExactPredictionFeatures
			!autoAblationTolerancePredictionThresholdMap
			!autoAblationRelativePredictionThresholdMap
			!autoAblationResidualPredictionFeatures
			!autoAblationConvictionLowerThreshold
			!autoAblationConvictionUpperThreshold
		)
		;keep any cases that only have null values
		;if there are zero 'null only' cases, can skip ablation since every case should be trained
		(= 0
			(size (filter
				(lambda (and
					(= (null) (first (current_value)))
					(apply "=" (current_value))
				))
				cases
			))
		)
	)

	;Helper method called by train to check whether case values are within thresholds for training or if it should be ablated
	;returns true if case should be kept / not ablated
	;return false if case should be ablated
	#!CaseOutsideThresholds
	(seq
		(if
			(= (null)
				!autoAblationExactPredictionFeatures
				!autoAblationTolerancePredictionThresholdMap
				!autoAblationRelativePredictionThresholdMap
				!autoAblationResidualPredictionFeatures
				!autoAblationConvictionLowerThreshold
				!autoAblationConvictionUpperThreshold
			)
			;return true, keep case / do not ablate
			(conclude (true))
		)

		(declare (assoc
			action_features
				(filter
					(lambda (or
						(contains_value !autoAblationExactPredictionFeatures (current_value))
						(contains_index !autoAblationTolerancePredictionThresholdMap (current_value))
						(contains_index !autoAblationRelativePredictionThresholdMap (current_value))
						(contains_value !autoAblationResidualPredictionFeatures (current_value))
					))
					features
				)
			feature_value_map (zip features feature_values)
		))

		(declare (assoc
			action_values (unzip feature_value_map action_features)
			residual_map (assoc)
		))

		(or ;evaluate in order and return the first true block

			;if the model is too small, skip ablatement, return true to force training
			(< (call !GetNumTrainingCases) !autoAblationMinModelSize)

			;if we have action_features, need to react first
			(if (!= (list) action_features)
				;store the reaction to reuse for both
				(let
					(assoc
						reaction_values
							(map
								(lambda (let
									(assoc
										feature (current_index 1)
										;flag set if this feature uses residual as its threshold type
										ablate_by_feature_residuals
											(contains_index (zip !autoAblationResidualPredictionFeatures) (current_index 1) )
									)
									(declare (assoc
										context_features (filter (lambda (!= feature (current_value))) features)
									))

									;react to each of the action features, using all other features as contexts
									(declare (assoc
										reaction
											(call !ReactDiscriminative (assoc
												return_action_values_only (true)
												context_features context_features
												context_values (unzip feature_value_map context_features)
												action_features (list feature)
												details
													(if ablate_by_feature_residuals
														(assoc "feature_residuals_full" (true))
													)
												substitute_output (false)
												skip_encoding (true)
												skip_decoding (true)
											))
									))

									;output the predicted value
									(if ablate_by_feature_residuals
										(seq
											;store the residual min and max tolerance for this feature
											(accum (assoc
												residual_map
													(associate feature (assoc
														"min" (get reaction (list "feature_residuals_full" feature))
														"max" (get reaction (list "feature_residuals_full" feature))
													))
											))

											(first (get reaction "action_values"))
										)

										(first reaction)
									)

								))
								(zip action_features)
							)
					)

					(or
						;if we filter out any values outside of the defined thresholds (that should be trained on)
						;allow training because these values are not being predicted by the system
						(!=
							(size action_values)
							;if an action_value is same as/within threshold of prediction, it will not be filtered out
							;so if this list is the same size as the original action_values, all action values were predicted correctly
							;but if it's not the same size, the action values are different enough to be trained on
							(size (filter
								(lambda (let
									(assoc
										action_feature (current_index 1)
										action_value (get feature_value_map (current_index 1))
									)
									(declare (assoc
										threshold_type
											(if
												(contains_value !autoAblationExactPredictionFeatures action_feature)
												"exact"
												(contains_index !autoAblationTolerancePredictionThresholdMap action_feature)
												"tolerance"
												(contains_value !autoAblationResidualPredictionFeatures action_feature)
												"residual"
												(contains_index !autoAblationRelativePredictionThresholdMap action_feature)
												"relative"
												(null)
											)
									))

									(if (= threshold_type "exact")
										(= action_value (current_value))

										;for discrete or residual, set the min and max and check if actual value is outside of those bounds
										(or (= threshold_type "tolerance") (= threshold_type "residual") )
										(let
											(assoc
												min
													(if (= threshold_type "tolerance")
														(get !autoAblationTolerancePredictionThresholdMap (list action_feature 0))
														(get residual_map (list (get action_features (current_index 1)) "min"))
													)
												max
													(if (= threshold_type "tolerance")
														(get !autoAblationTolerancePredictionThresholdMap (list action_feature 1))
														(get residual_map (list (get action_features (current_index 1)) "max"))
													)
											)
											(and (>= (current_value) (- action_value min)) (<= (current_value) (+ action_value max)))
										)

										;PERCENT is (last threshold)
										(= threshold_type "relative")
										(<=
											(/ (abs (- (current_value) action_value)) (current_value))
											(get !autoAblationRelativePredictionThresholdMap action_feature)
										)

										;if threshold_type is explicitly undefined, treat it as outside of bounds and filter out the value
										;thus forcing this case to be trained
										(= threshold_type (null))
										(false)
									)
								))
								reaction_values
							))
						)
					)
				)
			)

			;conviction thresholds
			(if
				(or (!= !autoAblationConvictionLowerThreshold (null)) (!= !autoAblationConvictionUpperThreshold (null)))
				(let
					(assoc
						conviction_value
							(get
								(call !SingleReactGroup (assoc
									features features
									new_cases (list feature_values)
									skip_encoding (true)
								))
								"familiarity_conviction_addition"
							)
					)

					(or
						;if both threshold values set, must be within both, otherwise check only the provided one
						(if (and (!= (null) !autoAblationConvictionLowerThreshold) (!= (null) !autoAblationConvictionUpperThreshold))
							(and (< conviction_value !autoAblationConvictionUpperThreshold) (> conviction_value !autoAblationConvictionLowerThreshold))

							(!= (null) !autoAblationConvictionLowerThreshold)
							(> conviction_value !autoAblationConvictionLowerThreshold)

							(< conviction_value !autoAblationConvictionUpperThreshold)
						)

						;if the model is empty, SingleReactGroup returns 0, force training
						(= conviction_value 0)
					)
				)
				;else false, ablate case
				(false)
			)
		)
	)
)