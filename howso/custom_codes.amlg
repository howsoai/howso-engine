;Contains methods for working with custom derived feature codes.
(null

	;derive new features using a custom code string and store into dataset
	;parameters:
	; features: list of features the dataset was trained with originally
	; derived_features : names of feature to create + derive
	; feature_attribute_map: optional, map of auto_derive_on_train attributes specific to the one feature that's being specified as derived_features
	#!CreateCustomFeaturesFromCode
	(declare
		(assoc
			features (list)
			derived_features (list)
			feature_attribute_map (null)
			new_case_ids (list)
		)

		(declare (assoc
			;list of all features referenced by derived_features, needed to derive them
			sourced_features
				(values
					(apply "append" (map
						(lambda
							(get !featureAttributes [(current_value 1) "auto_derive_on_train" "code_features"] )
						)
						derived_features
					))
					.true
				)
			cycle_length (null)

			;list of feature names that specify the series id for which to derive this feature.
			;	If more than one specified, a unique 'series id' is then the conjuction of the specified ids.
			;	E.g., if 'sender' and 'reciever' are specified, a 'series id' is then each unique pair of sender-reciever.
			series_id_features
				(if feature_attribute_map
					(get feature_attribute_map "series_id_features")
					(get !tsFeaturesMap "series_id_features")
				)
			;list of features names by which to sort the series.  Multi-sorts by the specified features if several specified.
			series_ordered_by_features
				(if feature_attribute_map
					(get feature_attribute_map "ordered_by_features")
					[!tsTimeFeature !internalLabelSessionTrainingIndex]
				)
			is_stationary_feature
				(and
					!tsTimeFeature
					(= "custom" (get feature_attribute_map "derive_type"))
					(= (null) (get feature_attribute_map "time_series"))
				)
		))

		;declare all the features that are necessary that are needed to derive this feature,
		;where the first features are the ones that need to be sorted on
		(declare (assoc
			;append series_ordered_by_features with sourced features and ensure no duplicates
			necessary_features
				(append
					(or series_ordered_by_features [])

					;filter out features in sourced_features that already exist in series_ordered_by_features
					;leaving only the ones that are unique to sourced_features
					(filter
						(lambda (not (contains_value series_ordered_by_features (current_value))))
						sourced_features
					)
				)
			ts_series_length_limit (retrieve_from_entity "!tsSeriesLimitLength")
		))

		;process each series individually
		;pull all the values for the necessary_features, sort them, and then derive this feature based on the specified code
		(map
			(lambda (let
				;(current_value) is in the format of (list (query_equals "series_feature_name" value) ... ) for all series_feature_name
				(assoc series_case_ids (contained_entities (current_value 1)) )

				;now that we know how long each new series is, ensure that ts_series_length_limit is e*(longest series)
				(if (> (* 2.718281828459 (size series_case_ids)) ts_series_length_limit)
					(assign (assoc ts_series_length_limit (* 2.718281828459 (size series_case_ids)) ))
				)

				(if has_reduced
					(seq
						(declare (assoc
							num_cases_prev_trained
								(+
									1
									(retrieve_from_entity
										(first (contained_entities
											(query_in_entity_list series_case_ids)
											(query_not_in_entity_list new_case_ids)
											(query_max ".series_index" 1 .true)
										))
										".series_index"
									)
								)
							num_cases_trained
								(+
									1
									(retrieve_from_entity
										(first (contained_entities
											(query_in_entity_list series_case_ids)
											(query_equals ".reverse_series_index" 0 .true)
										))
										".series_index"
									)
								)
						))


						(declare (assoc
							is_missing_cases
								;if the number of old series cases is less
								;than indicated by the largest series index of an old series case
								(and
									;this value will be null if there are no previous cases trained before this derivation
									num_cases_prev_trained
									(!=
										(size (contained_entities
											(query_in_entity_list series_case_ids)
											(query_not_in_entity_list new_case_ids)
										))
										num_cases_prev_trained
									)
								)
						))
					)
				)

				;series_data is all the necessary_features's values along with the training index and case_id appended as the last two columns
				;when the data is sorted, ties will be broken by the training index to assist with consistency
				(declare (assoc
					series_data
						(map
							(lambda
								;append two features: session index and case_id
								(append
									(retrieve_from_entity (current_value) (append necessary_features !internalLabelSessionTrainingIndex))
									(current_value)
								)
							)
							series_case_ids
						)
				))

				;sort the series data according to the specified features if ordering has been provided
				(if (size series_ordered_by_features)
					(assign (assoc
						series_data
							;cases have been removed from the series at some point, we must sort by series index, leaving nulls where appropriate
							(if is_missing_cases
								(let
									(assoc
										series_index_to_data_map
											(zip
												(map (lambda (retrieve_from_entity (current_value) ".series_index")) series_case_ids)
												series_data
											)
									)

									(unzip
										series_index_to_data_map
										(range 0 (- num_cases_trained 1) 1)
									)
								)

								;sort by sorting features
								(call !MultiSortList (assoc
									data series_data
									;specify indices for series_ordered_by_features and the index of !internalLabelSessionTrainingIndex
									column_order_indices
										(append
											(unzip (zip necessary_features (indices necessary_features)) series_ordered_by_features)
											(size necessary_features)
										)
								))
							)
					))
				)

				;store the case ids in the new sorted order of series_data
				(assign (assoc
					series_case_ids
						(map
							(lambda (last (current_value)))
							series_data
						)
				))

				(if is_missing_cases
					(seq
						(declare (assoc
							case_id_to_idx_map
								(zip
									series_case_ids
									(indices series_case_ids)
								)
						))
						(declare (assoc
							new_series_case_ids (indices (keep case_id_to_idx_map new_case_ids))
						))
					)
				)

				(assign (assoc
					series_data
						(map
							;removes the last two columns: case_id and !internalLabelSessionTrainingIndex columns
							(lambda (trunc (current_value) -2))
							series_data
						)
				))

				;overwrite series data with the derived features values
				(assign (assoc
					series_data
						(call !AddDerivedIndependentCodeFeatures (assoc
							derived_features derived_features
							features necessary_features
							series_data series_data
						))
				))

				;since all derived features are being created in bulk, we only need to check if one exists
				;to decide whether they all exist or none exist
				(declare (assoc first_derived_feature (first derived_features) ))

				(map
					(lambda (let
						(assoc case_id (current_index 1) )
						(if (contains_label case_id first_derived_feature)
							(assign_to_entities
								case_id
								(zip derived_features (current_value))
							)
							;else these labels don't exist yet, need to append them to the entity
							(accum_entity_roots
								case_id
								(zip_labels derived_features (current_value))
							)
						)
					))
					(if if_missing_cases
						(map
							(lambda
								(if is_stationary_feature
									;all values are same, store as-is
									(first (last series_data))

									;else get the row, given the index for this new case
									(get series_data (current_value))
								)

							)
							(keep case_id_to_idx_map new_series_case_ids)
						)


						;can do for all cases
						(zip
							series_case_ids

							;if this is a series stationary feature, set all values for this feature to the 'current' (last case) value
							(if is_stationary_feature
								;all values are same, store as-is
								(if (apply "=" (apply "append" series_data))
									series_data

									;else set the entire series to the value of the 'current' case
									(let
										(assoc stationary_value (first (last series_data)))
										(map (lambda [stationary_value]) series_data)
									)
								)

								;else non series stationary data, store as-is
								series_data
							)
						)
					)
				)
			))

			;generates a list of queries for each unique series id (where each series id may be a conjuction of several features)
			(call !GenerateUniqueSeriesQueries (assoc
				series_id_features series_id_features
				case_ids new_case_ids
			))
		)

		;list of derived_features that were inactive
		(declare (assoc
			inactive_derived_features (filter (lambda (contains_index !inactiveFeaturesMap (current_value))) derived_features)
		))

		;if there are inactive derived_features, keep only those that now have values and will need to be removed from inactive list
		(if (size inactive_derived_features)
			(assign (assoc
				inactive_derived_features
					(filter
						(lambda
							(size (contained_entities (query_not_equals (current_value 1) (null))) )
						)
						inactive_derived_features
					)
			))
		)
		;remove these remaining inactive features from the inactives list
		(if (size inactive_derived_features)
			(let
				(assoc updated_inactive_features_map (remove !inactiveFeaturesMap inactive_derived_features) )

				(if (size updated_inactive_features_map)
					(assign_to_entities (assoc !inactiveFeaturesMap updated_inactive_features_map ))

					;else all features have some non-null values
					(assign_to_entities (assoc
						!inactiveFeaturesMap (null)
						!inactiveFeaturesNeedCaching .false
					))
				)

				(call !SetInactiveFeatureWeights (assoc
					features_weights_map (zip inactive_derived_features 1)
				))
			)
		)

		;if ts_series_length_limit has been been updated to a larger value in the loop above, update the dataset with this new value
		(if (> ts_series_length_limit !tsSeriesLimitLength)
			(assign_to_entities (assoc !tsSeriesLimitLength ts_series_length_limit ))
		)
	)

	;helper method to derive the values for the synchronous counter feature for all trained cases/series
	;parameters:
	;  time_feature: the name of the time feature
	;  time_feature_delta: the name of the time feature's delta
	;  series_ordered_by_features: the ordered list of feature names to sort the series data by in increasing order
	;  series_id_features: the ordered list of feature names to identify each unique series
	#!CreateSynchronousCounterFeature
	(declare
		(assoc
			time_feature (null)
			time_feature_delta (null)
			series_ordered_by_features (null)
			series_id_features (null)
			new_case_ids (list)
		)

		(declare (assoc
			sync_counter_lag_name (concat !tsSynchronousCounterFeature "_lag_1")
			necessary_features (values (append series_ordered_by_features [time_feature time_feature_delta !internalLabelSessionTrainingIndex]) .true)
		))

		(declare (assoc
			necessary_feature_index_map (zip necessary_features (indices necessary_features))
		))

		(declare (assoc
			time_delta_index (get necessary_feature_index_map time_feature_delta)
		))

		;process each series individually
		;pull all the values for the necessary_features, sort them, and then derive this feature based on the specified code
		(map
			(lambda (let
				;(current_value) is in the format of (list (query_equals "series_feature_name" value) ... ) for all series_feature_name
				(assoc series_case_ids (contained_entities (current_value 1)) )

				(if has_reduced
					(seq
						(declare (assoc
							num_cases_prev_trained
								(+
									1
									(retrieve_from_entity
										(first (contained_entities
											(query_in_entity_list series_case_ids)
											(query_not_in_entity_list new_case_ids)
											(query_max ".series_index" 1 .true)
										))
										".series_index"
									)
								)
							num_cases_trained
								(+
									1
									(retrieve_from_entity
										(first (contained_entities
											(query_in_entity_list series_case_ids)
											(query_equals ".reverse_series_index" 0 .true)
										))
										".series_index"
									)
								)
						))


						(declare (assoc
							is_missing_cases
								;if the number of old series cases is less
								;than indicated by the largest series index of an old series case
								(and
									;this value will be null if there are no previous cases trained before this derivation
									num_cases_prev_trained
									(!=
										(size (contained_entities
											(query_in_entity_list series_case_ids)
											(query_not_in_entity_list new_case_ids)
										))
										num_cases_prev_trained
									)
								)
						))
					)
				)

				;series_data is all the necessary_features's values along with the training index and case_id appended as the last two columns
				;when the data is sorted, ties will be broken by the training index to assist with consistency
				(declare (assoc
					series_data
						(map
							(lambda
								;append two features: session index and case_id
								(append
									;series_ordered_by_features should include the time feature and the sessionTrainingIndex
									(retrieve_from_entity (current_value) necessary_features)
									(current_value)
								)
							)
							series_case_ids
						)
				))

				;sort the series data according to the specified features if ordering has been provided
				(if (size series_ordered_by_features)
					(assign (assoc
						series_data
							(if is_missing_cases
								;cases have been removed from the series at some point, we must sort by series index, leaving nulls where appropriate
								(let
									(assoc
										series_index_to_data_map
											(zip
												(map (lambda (retrieve_from_entity (current_value) ".series_index")) series_case_ids)
												series_data
											)
									)

									(unzip
										series_index_to_data_map
										(range 0 (- num_cases_trained 1) 1)
									)
								)

								;just sort by the sorting features
								(call !MultiSortList (assoc
									data series_data
									column_order_indices
										(unzip necessary_feature_index_map series_ordered_by_features)
								))
							)
					))
				)

				;store the case ids in the new sorted order of series_data
				(assign (assoc
					series_case_ids
						(map
							(lambda (last (current_value)))
							series_data
						)
				))

				(declare (assoc
					has_synchronous_timesteps
						(>
							(size (contained_entities
								(query_in_entity_list series_case_ids)
								(query_equals time_feature_delta 0)
							))
							0
						)
				))

				(declare (assoc
					synchronous_counter_values
						(if has_synchronous_timesteps
							(let
								(assoc
									prev_counter 0
								)

								(map
									(lambda
										(if (> prev_counter 0)
											;if prev counter is already greater than 0, just decrement
											(seq
												(accum (assoc prev_counter -1))
												prev_counter
											)

											;otherwise the last time value must be "finished" and onto the next
											;must count the number of values until time_delta is positive again
											(if (!=
													(get series_data [(+ (current_index 1) 1) time_delta_index])
													0
												)
												;if the next value is on a different time value, can just return zero
												0

												;if the next case is on the same time value, must count how many cases are also on it.
												(seq
													(assign (assoc
														prev_counter
															;in this while loop (current_index 1) is the index in series_data
															;(current_index) is the (while) index. So (+ (current_index 1) (current_index) 1) is
															;the index of series_data being checked
															(while
																;while the "next" time delta is still zero, continue
																(=
																	(get series_data [(+ (current_index 3) (current_index 1) 1) time_delta_index])
																	0
																)
																(+ 1 (current_index))
															)

													))
													prev_counter
												)
											)
										)
									)
									series_data
								)
							)

							;otherwise all counter values should be zero
							(map (lambda 0) series_case_ids)
						)
				))

				(if (and has_reduced is_missing_cases)
					(declare (assoc
						new_series_case_id_set (keep (zip series_case_ids) new_case_ids)
					))
				)

				(map
					(lambda (let
						(assoc
							case_id (current_value 1)
							sync_counter (get synchronous_counter_values (current_index 1))
							sync_counter_lag
								(if (> (current_index 1) 0)
									(get synchronous_counter_values (- (current_index 1) 1))
								)
						)

						(if (and has_reduced is_missing_cases (not (contains_index new_series_case_id_set case_id)) )
							;if the Trainee has reduced this series previously, should only update values for new cases.
							;so skip cases that are not new
							(conclude)
						)

						(if (contains_label case_id !tsSynchronousCounterFeature)
							(assign_to_entities
								case_id
								(associate
									!tsSynchronousCounterFeature sync_counter
									sync_counter_lag_name sync_counter_lag
								)
							)
							;else these labels don't exist yet, need to append them to the entity
							(accum_entity_roots
								case_id
								(zip_labels
									[!tsSynchronousCounterFeature sync_counter_lag_name]
									[sync_counter sync_counter_lag]
								)
							)
						)
					))
					series_case_ids
				)
			))

			;generates a list of queries for each unique series id (where each series id may be a conjuction of several features)
			;NOTE: this will only return queries for series that have had new cases trained.
			(call !GenerateUniqueSeriesQueries (assoc
				series_id_features series_id_features
				case_ids new_case_ids
			))
		)


	) ;end !CreateSynchronousCounterFeature

	;derives the feature value for the specified feature provided the data to derive from
	;parameters:
	; feature: name of feature being derived
	; features: list of feature names to match the series_data
	; series_data: list of lists, where the inner list is in order of features
	;  where the code can access the series_data via series_data via index series_row_index and values via series_row_values
	;returns a list of lists, where the inner list is a single value for this specified derived feature
	#!AddDerivedCodeFeature
	(declare
		(assoc
			feature ""
			features (list)
			series_data (list)
		)

		(declare (assoc
			feat_index_map (zip features (indices features))
			new_feature_transform (get !featureCustomDerivedMethods (list feature "train"))
			op_limit (* (size series_data) !sandboxedComputeLimit)
		))

		;process and return the generated series data
		(map
			(lambda (let
				(assoc series_row_index (current_index 1) )

				(get_value
					(call_sandboxed new_feature_transform (assoc
						series_data series_data
						series_row_index series_row_index
						feat_index_map feat_index_map
					)  op_limit !sandboxedMemoryLimit !sandboxedOpcodeDepthLimit .false)
				)
			))

			series_data
		)
	)

	;derives multiple feature values for the specified derived features provided the data to derive from
	;parameters:
	; derived_features: list of features to derived
	; features: list of feature names to match the series_data in the same order as the columns of series_data
	; series_data: list of lists, where the inner list is in the order of features
	;  where the code can access the series_data via series_data via index series_row_index and values via series_row_values
	;returns a list of lists of data, where the inner list values are the derived features matching derived_features
	#!AddDerivedIndependentCodeFeatures
	(declare
		(assoc
			derived_features (list)
			features (list)
			series_data (list)
		)

		(declare (assoc
			feat_index_map (zip features (indices features))
			;assoc of derived feature -> code of function for its derivation
			new_feature_transform_map
				(map
					(lambda (get !featureCustomDerivedMethods (list (current_index 1) "train")) )
					(zip derived_features)
				)
			op_limit (* (size series_data) !sandboxedComputeLimit)
		))

		||(map
			(lambda
				(map
					(lambda (get_value
						(call_sandboxed (get new_feature_transform_map (current_value)) (assoc
							series_data series_data
							series_row_index
								;the index of the current row (outer map)
								(current_index 2)
							feat_index_map feat_index_map
						)  op_limit !sandboxedMemoryLimit !sandboxedOpcodeDepthLimit .false)
					))
					derived_features
				)
			)
			series_data
		)
	)

	;rewrites the code in code_string by replacing all instances of (call value {feature <feature> lag <lag> }) with inlined
	;code from the 'value' method, replacing all 'feature' with the actual feature and all 'lag' with the actual lag value
	;e.g.:
	;(call !ParseDerivedFeatureCode (assoc
	;	code_string "(+ (call value {feature \"foo\" lag 2}) (call value {feature \"bar\"}) )"
	;	value (lambda (if (> lag 0) (get my_map feature) -1))
	;))
	; outputs:
	; (+ (if (> 2 0) (get my_map "foo") -1) (if (> 0 0) (get my_map "bar") -1))
	;
	;parameters:
	; code_string: code to parse as a string
	; value: method to inline and replace each instance of (call value ...) in the specified code
	#!ParseDerivedFeatureCode
	(rewrite
		(lambda
			(if (= "call" (get_type_string (current_value)))
				(if (= (lambda value) (first (current_value)))
					;if this node is (call value {feature .. lag ...}), rewrite it
					;by pulling out the actual feature and lag values and inlining the code from the 'value' method
					(let
						(assoc
							feature (get (current_value 1) [1 "feature"])
							lag (+ (or (get (current_value 1) [1 "lag"]) ) )
						)
						(rewrite
							(lambda
								;replace instance of 'feature' with actual string value, not a reference, by concatenating
								(if (= (current_value) (lambda feature))
									(concat feature)

									;replace instance of 'lag' with actual lag value, not a reference, by using get_value
									(= (current_value) (lambda lag))
									(get_value lag)

									(current_value)
								)
							)
							value
						)
					)
					(current_value)
				)
				(current_value)
			)
		)
		(parse code_string)
	)

	;Derive feature values from the provided features and values using either each derived feature's custom code string or predefined operations and output a list of computed values.
	;
	;parameters:
	; derived_features: list of strings, feature name(s) for which values should be derived, in the specified order.
	; features_values_map: assoc of feature -> values used to compute the resulting value.
	#!ComputeDerivedFeatureValues
	(declare
		(assoc
			derived_features (list)
			feature_values_map (assoc)

			;not a parameter
			has_derived_datetime_features .false
			calculated_case_similarity_metrics (assoc)
		)

		;if there are datetime features, make sure to convert them appropriately
		(if !hasDateTimeFeatures
			(seq
				(assign (assoc has_derived_datetime_features (size (intersect (zip derived_features) !featureDateTimeMap)) ))

				;if feature_values_map has datetime features, convert them to epoch
				(if (size (intersect feature_values_map !featureDateTimeMap))
					(assign (assoc
						feature_values_map
							(map
								(lambda
									(if (contains_index !featureDateTimeMap (current_index))
										;encode datetime by converting string date time into seconds since epoch
										(if (!= (null) (current_value))
											(format
												(current_value)
												(get !featureDateTimeMap (list (current_index 1) "date_time_format"))
												"number"
												{
													"locale" (get !featureDateTimeMap [ (current_index 2) "locale" ] )
													"time_zone" (get !featureDateTimeMap [ (current_index 2) "default_time_zone" ] )
												}
												(null)
											)
										)

										;else output original value
										(current_value)
									)
								)
								feature_values_map
							)
					))
				)
			)
		)

		(declare (assoc
			op_limit (* (size feature_values_map) !sandboxedComputeLimit)
		))

		; Replaced computed features with the actual type of computed feature.
		(assign (assoc
			derived_features
				(map
					(lambda (let
						(assoc
							original_metric_name
								(get (zip (values (get !computedFeaturesMap "computed_map")) (indices (get !computedFeaturesMap "computed_map"))) (current_value 1))
						)
						(if original_metric_name
							original_metric_name
							(current_value)
						)
					))
					derived_features
				))
		)

		(if
			(or
				(contains_value derived_features "similarity_conviction")
				(contains_value derived_features "distance_contribution")
			)
			(assign (assoc
				calculated_case_similarity_metrics
					(call !SimilarityConviction (assoc
						features (indices feature_values_map)
						feature_values (values feature_values_map)
						use_case_weights use_case_weights
						weight_feature weight_feature
					))
			))
		)

		(declare (assoc
			derived_values
				;iterate over the list of derived features and compute each feature value from the provided features and feature_values
				(map
					(lambda
						(if (contains_index (get !featureAttributes (current_value)) "derived_feature_code")
							(let
								(assoc
									raw_code_string (get !featureAttributes (list (current_value 2) "derived_feature_code"))
								)

								(declare (assoc
									new_feature_transform_processed  (get !featureCustomDerivedMethods (list (current_value 2) "react"))
									output_value (null)
								))
								(assign (assoc
									output_value
										(get_value
											(call_sandboxed new_feature_transform_processed (assoc feature_values_map feature_values_map) op_limit !sandboxedMemoryLimit !sandboxedOpcodeDepthLimit .false)
										)
								))

								(if (contains_index feature_post_process_code_map (current_value))
									;if custom post process is defined, update feature value with it
									(assign (assoc
										output_value
											(get_value
												(call_sandboxed (get feature_post_process_code_map (current_value 1)) (assoc
													case (append feature_values_map (associate (current_value 3) output_value) )
												) !sandboxedComputeLimit !sandboxedMemoryLimit !sandboxedOpcodeDepthLimit .false)
											)
									))
								)

								;append derived feature and value to the input features and values so that they could be used by the next derived feature
								(accum (assoc feature_values_map (associate (current_value 2) output_value)))

								output_value
							)

							(contains_value ["similarity_conviction" "distance_contribution"] (current_value))
							(get calculated_case_similarity_metrics (current_value))
						)
					)
					derived_features
				)
		))

		;if derived_features has datetime features, convert them to strings
		(if has_derived_datetime_features
			(map
				(lambda (let
					(assoc feature (get derived_features (current_index 1)))

					(if (contains_index !featureDateTimeMap feature)
						;encode datetime by converting seconds since epoch back into a string date
						(if (!= (null) (current_value))
							(format
								(current_value)
								"number"
								(get !featureDateTimeMap (list feature "date_time_format"))
								(null)
								{
									"locale" (get !featureDateTimeMap [ feature "locale" ] )
									"time_zone" (get !featureDateTimeMap [ feature "default_time_zone" ] )
								}
							)
						)

						;else output original value
						(current_value)
					)
				))
				derived_values
			)

			;else just return the values
			derived_values
		)
	)

	#!InitializeFeatureProcessMapsStationary
	(seq
		(if feature_pre_process_code_map
			(assign (assoc
				feature_pre_process_code_map
					(map
						(lambda
							;parse it into code, requires passing case as a map of feature name to value
							(call !ParseDerivedFeatureCode (assoc
								code_string (current_value 1)
								value (lambda (if (= lag 0) (get case feature) ) )
							))
						)
						feature_pre_process_code_map
					)
			))
		)
		(if feature_post_process_code_map
			(assign (assoc
				feature_post_process_code_map
					(map
						(lambda
							;parse it into code, requires passing case as a map of feature name to value
							(call !ParseDerivedFeatureCode (assoc
								code_string (current_value 1)
								value (lambda (if (= lag 0) (get case feature) ) )
							))
						)
						feature_post_process_code_map
					)
			))
		)
	)
)
