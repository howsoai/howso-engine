;Contains methods for computing and storing feature residuals.
(null

	;Updates the given hyperparam_map and returns it with updated parameters based on computed residuals
	;parameters:
	; see #!CalculateFeatureResiduals
	#!CalculateResidualsAndUpdateParameters
	(declare
		(assoc
			features (null)
			context_features (null)
			case_ids (null)
			focal_case (null)
			num_samples (null)
			robust_residuals (false)
			hyperparameter_feature ".targetless"
			use_case_weights (null)
			weight_feature ".case_weight"
			custom_hyperparam_map (null)
			confusion_matrix_min_count 15
			feature_with_nulls (null)
			compute_null_uncertainties (true)
			compute_all_statistics (true)
		)

		(if (= (null) context_features)
			(assign (assoc context_features !trainedFeatures))
		)

		;if features aren't specified, use the set of context_features
		(if (= (null) features)
			(assign (assoc features context_features))
		)
		;if not using case weights, change weight_feature to '.none'
		(if (= (false) use_case_weights)
			(assign (assoc weight_feature ".none"))
		)

		;set the passed in one as the hyperparam map to use if specified
		(declare (assoc
			hyperparam_map
				(if (= (null) custom_hyperparam_map)
					(call !GetHyperparameters (assoc
						feature hyperparameter_feature
						context_features context_features
						mode (if (!= ".targetless" hyperparameter_feature) "full" "robust")
						weight_feature weight_feature
					))

					custom_hyperparam_map
				)
		))
		(call !UpdateCaseWeightParameters (assoc set_valid_weight_feature (false) ))
		(declare (assoc
			param_path
				;if the param_path is missing, create it here
				(if (= (null) (get hyperparam_map "paramPath"))
					(list
						hyperparameter_feature
						(call !BuildContextFeaturesKey (assoc context_features features))
						(if robust_residuals
							"robust"

							;mode stays "full" only if it's there in the !hyperparameterMetadataMap along with the weight_feature
							(contains_index !hyperparameterMetadataMap (list hyperparameter_feature "full" weight_feature))
							"full"

							;defaults back to robust
							"robust"
						)
						weight_feature
					)

					(get hyperparam_map "paramPath")
				)
		))


		;if there are ordinals but the hyperparameter map doesn't have a featureOrdinalDeviations assoc, initialize it
		(if (and
				(size ordinal_features_map)
				(= (null) (get hyperparam_map "featureOrdinalDeviations"))
			)
			(accum (assoc hyperparam_map (assoc "featureOrdinalDeviations" (assoc))))
		)

		;if storing deviations ensure that featureDeviations is an assoc instead of (null) for correct accumulation
		(if (= (null) (get hyperparam_map "featureDeviations" ))
			(assign (assoc hyperparam_map (set hyperparam_map "featureDeviations" (assoc))))
		)

		;if calculating and storing or all features, set the allFeatureResidualsCached flag to true
		(if (= (sort !trainedFeatures) (sort features))
			(accum (assoc hyperparam_map (assoc "allFeatureResidualsCached" (true))))
		)

		(declare (assoc
			output_map
				(call !CalculateFeatureResiduals (assoc
					features features
					context_features context_features
					case_ids case_ids
					focal_case focal_case
					num_samples num_samples
					robust_residuals robust_residuals
					hyperparameter_feature hyperparameter_feature
					use_case_weights use_case_weights
					weight_feature weight_feature
					custom_hyperparam_map hyperparam_map
					compute_all_statistics compute_all_statistics
					confusion_matrix_min_count confusion_matrix_min_count
					compute_null_uncertainties compute_null_uncertainties
				))
		))

		(assign (assoc hyperparam_map (get output_map "hyperparam_map") ))

		;reset the flag if there are no residuals
		(if (and
				(= (sort !trainedFeatures) (sort features))
				(= 0 (size (get output_map "residual_map")))
			)
			(accum (assoc hyperparam_map (assoc "allFeatureResidualsCached" (false))))
		)

		;update hyperparam_map with null uncertainties if present
		(if (size (get output_map "nullUncertainties"))
			(let
				(assoc null_uncertainties_map (get output_map "null_uncertainty_map") )
				(assign
					"hyperparam_map"
					(list "nullUncertainties")
					(map
						(lambda
							;append (null)s in front to match the deviations shape
							(append (null) (current_value))
						)
						null_uncertainties_map
					)
				)

				(assign
					"hyperparam_map"
					(list "featureDeviations")
					(map
						(lambda
							;update deviation value with null uncertainies
							(if (contains_index null_uncertainties_map (current_index))
								(if (~ (list) (current_value))
									;if the deviation is a number, wrap it in a triple
									(if (or (~ 0 (first (current_value))) (= (null) (first (current_value))) )
										(append (first (current_value)) (get null_uncertainties_map (current_index)) )

										;else the deviation must be a SDM, wrap it in a list so that the output is a triple
										;in the format of [sdm, null-value, null-null] instead of appending null uncertaintes to the SDM
										(append
											(list (first (current_value 1)))
											(get null_uncertainties_map (current_index))
										)
									)
									(append (list (current_value 1)) (get null_uncertainties_map (current_index)) )
								)

								;leave deviation value as-is
								(current_value)
							)
						)
						(if (size (get hyperparam_map "featureDeviations"))
							(get hyperparam_map "featureDeviations")
							(zip (indices null_uncertainties_map))
						)
					)
				)
			)
		)

		(assign
			"hyperparam_map"
			(list "featureOrdinalDeviations")
			(get output_map "ordinal_residuals_map")
		)

		;return the output map with capped residual values
		(assign (assoc output_map (call !ExpandResidualValuesToUncertainty  (assoc feature_residuals_map output_map)) ))
		(assign
			"hyperparam_map"
			["featureResiduals"]
			(map
				(lambda
					(if (~ 0 (current_value))
						(current_value)

						;must be a nominal
						(~ (assoc) (current_value))
						(get (current_value) "expected_deviation")

						;else fall back to null, this should never happen
						(null)
					)
				)
				(get output_map "residual_map")
			)
		)

		hyperparam_map
	)

	;calculate feature residual values, i.e. the mae (mean absolute error of predictions on a sample of the model) for each of the specified features
	;returns an assoc containing feature residuals, feature ordinal residuals and the hyperparam_map used for computations
	;
	;parameters:
	; features: optional list of all features to compute residuals for. If not specified will use !trainedFeatures.
	; context_features: list of features to be used as the context. If not specified, will use the value of features.
	; target_residual_feature: optional feature for which to calculate the (MAE) residual. If not specified, will compute for all features.
	; case_ids: optional list of case ids to compute residuals for the action set, will ignore 'action_condition_filter_query' and 'num_samples' if specified
	; action_condition_filter_query: optional list of filtering queries for the action set. If both 'action_condition_filter_query' and 'context_condition_filter_query' are specified,
	;		then all of the action cases selected by the 'action_condition_filter_query' will be excluded from the context set, effectively holding them out.
	;		If only 'action_condition_filter_query' is specified, then only the single predicted case will be left out.
	; num_samples: optional, limit on the number of cases for the action set to use in calculating conditional residuals. Works with or without 'action_condition_filter_query'. If
	; 		'action_condition_filter_query' is not provided, will be ignored if 'case_ids' is provided.
	; context_condition_filter_query: optional list of filtering queries for the context set. Ignored if 'action_condition_filter_query' is not specified.
	;		If both 'action_condition_filter_query' and 'context_condition_filter_query' are specified, then all of the cases selected by the 'action_condition_filter_query'
	;		will be excluded from the context set, effectively holding them out. If only 'action_condition_filter_query' is specified, then only the single predicted case will be left out.
	; focal_case: optional case id of case for which to compute residuals for  is to be ignored during computation
	; regional_model_only: flag, default to false. when set to true will only explicitly use the specified case_ids for computation.
	; robust_residuals: flag, default to false. when true calculates residuals robust with respect to the set of contexts used (across the power set of contexts)
	; hyperparameter_feature: optional  default '.targetless'.  feature whose hyperparameters to use
	; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight. If unspecified,
	;   			case weights will be used if the trainee has them.
	; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
	; custom_hyperparam_map: optional, hyperparameters to use for residuals computation
	; compute_all_statistics: flag, optional. if set to true will compute other statistics (precision, recall, r^2, rmse, etc.) in addition to MAE
	; store_values: flag, optional. if set to true will store the statistics in trainee-level caches, if set to false will return the set of values
	; confusion_matrix_min_count: number, optional, default is 10. Applicable only to confusion matrices, the number of predictions a class should have
	;		(value of a cell in the matrix) for it to remain in the confusion matrix. If the count is less than this value, it will be accumulated
	;		into a single value of all insignificant predictions for the class and removed from the confusion matrix.
	#!CalculateFeatureResiduals
	(declare
		(assoc
			;the features to compute residuals for
			features (null)
			;the features to be used as context
			context_features (null)
			target_residual_feature (null)
			regional_model_only (false)
			focal_case (null)
			robust_residuals (false)

			;ordered by priority for the action set, with the 'case_ids' parameters having the top priority.
			case_ids (list)
			action_condition_filter_query (list)
			context_condition_filter_query (list)
 			num_samples (null)

			hyperparameter_feature ".targetless"
			use_case_weights (null)
			weight_feature ".case_weight"
			custom_hyperparam_map (null)
			compute_all_statistics (false)
			compute_null_uncertainties (true)
			confusion_matrix_min_count 15
			shared_residuals (true)
		)

		(declare (assoc
			k_parameter (null)
			p_parameter (null)
			dt_parameter (null)
			query_feature_attributes_map (null)
			case_features (null)
			ordinal_features_map (zip !ordinalFeatures)
			hyperparam_map (assoc)
			residuals_map (assoc)
			ordinal_residuals_map (assoc)
			;assoc of features to skip computing non-robust residuals for if they don't have enough non-null values
			skip_features_map (assoc)
			;list, length of case_ids, each item will be a list of residual values, one per feature
			case_residuals_lists (list)
			;list, length of features, each item will be a list of residuals, one per case
			feature_residuals_lists (list)

			num_training_cases (call !GetNumTrainingCases)
			valid_weight_feature (false)

			rmse_map (assoc)
			r2_map (assoc)
			spearman_coeff_map (assoc)
			accuracy_map (assoc)
			precision_map (assoc)
			recall_map (assoc)
			mcc_map (assoc)
			confusion_matrix_map (assoc)
			nominal_performance_map (assoc)

			null_uncertainties_map (assoc)
			;list of unique features to populate output at the end
			unique_features_for_populating_output (null)

			provided_case_id_flag (true)
		))

		(call !InitResiduals)

		(if robust_residuals
			(call !RunRobustResiduals)
			;else
			(call !RunFullResiduals)
		)

		(if shared_residuals
			(if (not (size !sharedResidualsMap))
				;if there are no set shared residuals, ignore shared deviations
				(assign (assoc shared_residuals (false)))
				(call !PrepSharedResiduals (assoc
					features_keys_lists (assoc "features" features)
					feature_residuals_keys_lists (assoc " feature_residuals_lists" feature_residuals_lists)
				))
			)
		)

		;if shared deviations, the prediction_stats returned will be expanded,
		; however the features list and feature_residuals_lists will be shortened
		; to where each group of shared residuals will only have one list of values.
		; (assign (assoc compute_all_statistics (false)))
		(declare (assoc
			prediction_stats
				(if compute_all_statistics
					(call !PrepAllStatisticsResidualOutput)

					(call !PrepResidualOutput)
				))
		)

		(if compute_null_uncertainties
			(let
				(assoc
					features_with_nulls
						(indices (filter
							;keep only features that have at least 2 nulls
							(lambda
								(>=
									(compute_on_contained_entities (append
										(query_exists (current_index))
										(query_equals (current_index) (null))
										(query_count)
									))
									2
								)
							)
							(filter
								;only query features that have nulls
								(lambda (get (current_value) "has_nulls"))
								;ignore all inactive features (where all values are nulls)
								(keep
									(remove !featureNullRatiosMap (indices !inactiveFeaturesMap))
									;if shared deviations, the features list needs to be expanded to include features that were dropped for shared deviations calculations
									(if shared_residuals
										(call !ExpandMapForSharedDeviations (assoc shared_map features))
										features
									)
								)
							)
						))
				)
				;compute null deviations and update hyperparam_map with them
				(if (size features_with_nulls)
					(assign (assoc
						null_uncertainties_map
							(call !ComputeNullUncertainties (assoc
								features_with_nulls features_with_nulls
								context_features context_features
								null_cases_map
									(map
										(if regional_model_only
											;if regional model only, just filter which of the case ids have nulls for each feature
											(lambda
												(filter
													(lambda (= (null) (retrieve_from_entity (current_value) (current_index 1))))
													case_ids
												)
											)

											;otherwise sample null feature value cases from the model using queries
											(lambda
												(contained_entities (append
													(query_exists (current_index))
													(query_equals (current_index) (null))
													(query_sample 200)
												))
											)
										)
										(zip features_with_nulls)
									)
							))
					))
				)
			)
		)

		;unique features have a residual of (null)
		(if unique_features_for_populating_output
			(accum (assoc
				residuals_map (zip unique_features_for_populating_output)
			))
		)


		;for shared deviations, only one set of deviations are calculated for each group. At the end of the calculations,
		; the deviations mapping is expanded to add back the other features whose deviations were not calculated and point them at the feature
		; in which their shared deviations are stored under.
		(if shared_residuals
			(map
				(lambda (let
					(assoc
						current_map_name (current_index 1)
						current_map_value (current_value 1)
					)
					(assign (associate
						current_map_name
							(call !ExpandMapForSharedDeviations (assoc
								shared_map current_map_value
							))
					))
				))
				(assoc
					"ordinal_residuals_map" ordinal_residuals_map
					"residuals_map" residuals_map
					"null_uncertainties_map" null_uncertainties_map
				)
			)
		)

		(assoc
			"residual_map" residuals_map
			"ordinal_residual_map" ordinal_residuals_map
			"hyperparam_map" hyperparam_map
			"prediction_stats" prediction_stats
			"null_uncertainty_map" null_uncertainties_map
		)
	)

	;Helper method for CalculateFeatureResiduals to compute and output all basic prediction stats from the residuals
	#!PrepAllStatisticsResidualOutput
	(let
		(assoc
			feature_indices_map (zip features (indices features))
			continuous_features (filter (lambda (not (contains_index !nominalsMap (current_value)))) features)
			continuous_indices (list)
			nominal_features (filter (lambda (contains_index !nominalsMap (current_value))) features)
			nominal_indices (list)
			numeric_continuous_features (null)
			numeric_continuous_indices (null)
		)

		;feature_residuals_lists is in the format of:
		; (list
		; 	(list react1 react2 ... react n) ; feature A reacts
		; 	(list react1 react2 ... react_n) ; feature B reacts
		; 	...
		; 	(list react1 react2 ... react n) ; feature N reacts
		; )
		;
		;where each react is a list of either:
		; [diff, actual_value, categorical_probabilities] for nominals or
		; [diff, ordinal_diff, actual_value, predicted_value] for continuous (ordinal_diff is not there for non-ordinal features)

		(assign (assoc
			continuous_indices (unzip feature_indices_map continuous_features)
			nominal_indices (unzip feature_indices_map nominal_features)
			has_ordinals (> (size ordinal_features_map) 0)
			;default index offset of where the actual case value is in each output react
			actual_offset 1
		))

		;if some of the features are edit distance types, r2 and spearman coefficient don't apply since there's no mean or relative sorting
		;filter out those out of the lists of continuous fetaures and not compute those stats for them
		(if (size !editDistanceFeatureTypesMap)
			(seq
				(assign (assoc
					numeric_continuous_features
						(filter (lambda (not (contains_index !editDistanceFeatureTypesMap (current_value)))) continuous_features)
				))
				(assign (assoc numeric_continuous_indices (unzip feature_indices_map numeric_continuous_features) ))
			)

			(assign (assoc
				numeric_continuous_features continuous_features
				numeric_continuous_indices continuous_indices
			))
		)

		(if has_ordinals
			(assign (assoc
				;for continuous features, each react output is stored as [diff, actual_value, predicted_value]
				;but if there are ordinals, it's stored as [diff, ordinal_diff, actual_value, predicted_value]
				;if there are ardinals, the index offest for actual_value is 2 instead of 1
				actual_offset 2

				ordinal_residuals_map
					(filter (zip
						continuous_features
						(map
							(lambda
								(if (contains_index ordinal_features_map (get continuous_features (current_index)))
									(if (size (current_value))
										;create a list of ordinal_diffs by pulling ordinal_diff from each tuple
										(/
											(apply "+" (map (lambda (get (current_value) 1)) (current_value)) )
											;compute average by dividing by the number of values
											(size (current_value))
										)

										;else if there were no values for this feature, return global feature residual
										(get hyperparam_map (list "featureDeviations" (get continuous_features (current_index 1))))
									)
								)
							)
							(unzip feature_residuals_lists continuous_indices)
						)
					))
			))
		)

		;iterate over each continuous feature's list of reacts and compute the MAE, RMSE, R^2, and spearman coefficient
		(assign (assoc
			;MAE - mean absolute error = sum(|actual-predicted|) / num_cases
			residuals_map
				(zip
					continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							(size (current_value))
							(/
								(apply "+" (map (lambda (first (current_value))) (current_value)) )
								;compute average by dividing by the number of values
								(size (current_value))
							)

							;else if there were no values for this feature, return global feature residual
							(get hyperparam_map (list "featureDeviations" (get continuous_features (current_index 1))))
						))
						(unzip feature_residuals_lists continuous_indices)
					)
				)
			;RMSE - root mean squared error = sqrt( sum( |actual-predicted|^2 ) / num_cases )
			rmse_map
				(zip
					continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							(size (current_value))
							(sqrt (/
								(apply "+" (map (lambda (pow (first (current_value)) 2)) (current_value)) )
								;compute average by dividing by the number of values
								(size (current_value))
							))
						))
						(unzip feature_residuals_lists continuous_indices)
					)
				)
			;spearman coefficient = 1 - 6 * sum(|actual_rank-predicted_rank|^2) / (num_cases^3 - num_cases)
			;where actual_rank and predicted_rank are the 1-based sorted rank of values for each
			spearman_coeff_map
				(zip
					numeric_continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							;must have at least 2 values to compute spearman coefficient
							(> (size (current_value)) 1)
							(let
								(assoc
									actual_ranks_map
										(call !GetRankMapForValues (assoc
											values (map (lambda (get (current_value) actual_offset)) (current_value 2))
										))
									predicted_ranks_map
										(call !GetRankMapForValues (assoc
											values (map (lambda (last (current_value))) (current_value 2))
										))
								)
								(- 1
									(* 6 (/
										(apply "+"
											(map
												(lambda
													(pow
														(-
															(get actual_ranks_map (get (current_value) actual_offset))
															(get predicted_ranks_map (last (current_value)))
														)
														2
													)
												)
												(current_value)
											)
										)

										(- (pow (size (current_value)) 3) (size (current_value)))
									))
								)
							)
						))
						(unzip feature_residuals_lists numeric_continuous_indices)
					)
				)
			;R squared = 1 - sum(|actual-predicted|^2) / sum(|actual-mean|^2)
			r2_map
				(zip
					numeric_continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							;must have at least 2 values to compute r^2
							(> (size (current_value)) 1)
							(let
								(assoc
									mean_value
										;average of all actual values
										(/
											(apply "+" (map (lambda (get (current_value) actual_offset)) (current_value 1)) )
											(size (current_value 1))
										)
									sum_res_squared
										(apply "+" (map (lambda (pow (first (current_value)) 2)) (current_value 1)) )
									sum_tot_squared 0
								)

								(assign (assoc
									sum_tot_squared
										(apply "+"
											(map
												(lambda
													;(mean - actual)^2
													(pow (- mean_value (get (current_value) actual_offset)) 2)
												)
												(current_value 1)
											)
										)
								))

								;output r^2 value:  1 - SSres / SStot
								;cap the smallest allowed r2 value to the float min value of -3.4028234663852886e+38
								(max
									(- 1 (/ sum_res_squared sum_tot_squared))
									-340282346638528859811704183484516925440
								)
							)
						))
						(unzip feature_residuals_lists numeric_continuous_indices)
					)
				)
		))

		(accum (assoc
			residuals_map
				(zip
					nominal_features
					;iterate over nominal features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							(size (current_value))
							(/
								(apply "+" (map (lambda (first (current_value))) (current_value)) )
								;compute average by dividing by the number of values
								(size (current_value))
							)

							;else if there were no values for this feature, return global feature residual
							(replace (get hyperparam_map (list "featureDeviations" (replace (get nominal_features (current_index 1))))))
						))
						(unzip feature_residuals_lists nominal_indices)
					)
				)
		))

		(assign (assoc
			confusion_matrix_map
				(zip
					nominal_features
					;iterate over nominal features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda
							(map
								(lambda
									(zip
										;all collisions will increase the count value
										;e.g. zipping (list small medium small) will create (assoc small 1 medium 1)
										;then accumulate a 1 for the second 'small' in the list since it's a key collision, resulting in (assoc small 2 medium 1)
										(lambda (+ 1 (current_value 1)) )
										;ensure to zip a list of classes by prepending an empty list
										(append (list) (current_value))
										;zip all classes with a value of 1 so that all clases in the predicted list are assigned a value of 1
										(range
											(lambda 1)
											1
											;if there is only one entry for a value, then it's predicted values: (current_value)
											;will be singular (not a list, size=0), so we bound the list of 1's to be at least size=1
											(max 1 (size (current_value)))
											1
										)
									)
								)
								(map
									;filter out the nulls out of the list of predicted values
									(lambda (filter (replace (current_value))))
									(zip
										;iterate over pairs of (actual value, predicted value), this lambda is run when there is a
										;key collision (actual value). In that case append the new predicted value to get an assoc of
										; actual values to the list of values they are predicted as
										(lambda
											(append (replace (current_value 1)) (list (replace (current_value 1))))
										)
										;(get (current_value) 1) refers to the actual case value in each react tuple
										(map (lambda (replace (get (current_value) 1))) (current_value))
										;and (get (current_value) 2) refers to the interpolated/predicted case value in
										;each react tuple
										(map (lambda (replace (get (current_value) 2))) (current_value))
									)
								)
							)
						)
						(unzip feature_residuals_lists nominal_indices)
					)
				)
		))

		;accuracy is: num correct predictions / all predictions
		(assign (assoc
			accuracy_map
				(map
					(lambda
						(let
							;grab the current action feature's confusion matrix
							(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
							(if (size confusion_matrix)
								(/
									;correct predictions count
									(apply "+" (values
										;get correct prediction count for each class
										(map
											(lambda (or (get (current_value) (current_index))))
											confusion_matrix
										)
									))
									;total predictions count
									(apply "+" (values
										;add up all prediction counts for all classes
										(map (lambda (apply "+" (filter (values (current_value))))) confusion_matrix)
									))
								)
							)
						)
					)
					(zip nominal_features)
				)
		))

		;recall for a single class is = TruePositives / (TruePositives + FalseNegatives)
		(assign (assoc
			recall_map
				(map
					(lambda
						(let
							;grab the current action feature's confusion matrix
							(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
							(if (size confusion_matrix)
								;for each row in confusion matrix, average out: correct / total of row
								(/
									(apply "+"
										(values (map
											(lambda (let
												(assoc row_total (apply "+" (values (current_value 1))) )
												;if there were no  predictions at all for this class, prevent divide by zero
												(if (> row_total 0)
													(/ (or (get (current_value) (current_index)) 0) row_total)
													0
												)
											))
											confusion_matrix
										))
									)
									;The 'confusion_matrix' may not be a square matrix. Divides by the length of the rows or columns
									; as if the matrix was square by taking the max of the number of non-empty rows or the number
									; of uniquely predicted column indices.
									(max
										;Number of rows, filter out empty rows
										(size
											(filter (lambda (size (current_value))) confusion_matrix)
										)
										;Number of unique columns
										(size (values
											(apply "append"
												(map
													(lambda (indices (current_value)))
													(values confusion_matrix)
												)
											)
											(true)
										))
									)
								)
							)
					))
					(zip nominal_features)
				)
		))

		;precision for a single class is = TruePositives / (TruePositives + FalsePositives)
		(assign (assoc
			precision_map
				(map
					(lambda
						(let
							;grab the current action feature's confusion matrix
							(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
							(if (size confusion_matrix)
								;for each column in confusion matrix, average out: correct / total of column
								(/
									;correct predictions count
									(apply "+"
										(values (map
											(lambda (let
												(assoc
													class (current_index 1)
													column_total (null)
												)
												(assign (assoc
													column_total
														(apply "+"
															(values (map
																(lambda (or (get (current_value) class) 0) )
																confusion_matrix
															))
														)
												))
												;if there were no guesses for this class at all, prevent divide by zero
												(if (> column_total 0)
													(/ (or (get (current_value) class) 0) column_total)
													0
												)
											))
											confusion_matrix
										))
									)
									;The 'confusion_matrix' may not be a square matrix. Divides by the length of the rows or columns
									; as if the matrix was square by taking the max of the number of non-empty rows or the number
									; of uniquely predicted column indices.
									(max
										;Number of rows, filter out empty rows
										(size
											(filter (lambda (size (current_value))) confusion_matrix)
										)
										;Number of unique columns
										(size (values
											(apply "append"
												(map
													(lambda (indices (current_value)))
													(values confusion_matrix)
												)
											)
											(true)
										))
									)
								)
							)
						)
					)
					(zip nominal_features)
				)
		))

		; Generalized multi-class formula for Matthews Correlation Coefficient (mcc) is located https://en.wikipedia.org/wiki/Phi_coefficient#Multiclass_case
		(assign (assoc
			mcc_map
				(map
					(lambda
						(let
							;grab the current action feature's confusion matrix
							(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
							(if (size confusion_matrix)
								(let
									(assoc
										;get the total correctly predicted counts, variable c in the mcc formula
										total_predicted_correct
											(apply "+" (values
												(map (lambda (or (get (current_value) (current_index))) ) confusion_matrix)
											))
										;get the total number of samples, variable s in the mcc formula
										total_samples
											(apply "+" (values
												(map (lambda (apply "+" (filter (values (current_value))))) confusion_matrix)
											))
										;get a list containing the true counts of each class, vector t in the mcc formula
										true_counts
											(append (values
												(map
													(lambda (apply "+" (filter (values (get confusion_matrix (current_index))))))
													confusion_matrix
												)
											))
										;get a list containing the predicted counts of each class, vector p in the mcc formula
										predicted_counts
											(append (values
												(map
													(lambda
														(apply "+" (values (map
															;current_index 1 is the predicted class that is being aggregated
															(lambda (or (get (current_value) (current_index 1))) 0)
															confusion_matrix
														)))
													)
													confusion_matrix
												)
											))
									)

									;calculates the mcc
									(declare (assoc
										mcc_numerator
											(- (* total_predicted_correct total_samples) (dot_product true_counts predicted_counts))
										mcc_denominator
											(*
												(sqrt (- (pow total_samples 2) (dot_product true_counts true_counts)))
												(sqrt (- (pow total_samples 2) (dot_product predicted_counts predicted_counts)))
											)
									))

									(if (or (= mcc_numerator 0) (= mcc_denominator 0))
										0
										(/ mcc_numerator mcc_denominator)
									)
								)
							)
						)
					)
					(zip nominal_features)
				)
		))

		(if (= (null) param_path)
			(declare (assoc param_path (get hyperparam_map "paramPath")))
		)

		;wrap each confusion matrix in an assoc
		(assign (assoc
			confusion_matrix_map
				;sparsify matrix if confusion_matrix_min_count is specified and there is a confusion matrix to sparsify
				(if (and
						(size confusion_matrix_map)
						(> confusion_matrix_min_count 0)
					)
					(call !SparsifyConfusionMatrices (assoc
						confusion_matrix_min_count confusion_matrix_min_count
						confusion_matrix_map confusion_matrix_map
					))

					(map
						(lambda (assoc
							"matrix" (current_value 1)
							"leftover_correct" 0
							"leftover_incorrect" 0
							"other_counts" 0
						))
						confusion_matrix_map
					)
				)
		))

		;converts back to full
		(map
			(lambda (let
				(assoc
					current_map_name (current_index 1)
					current_map_value (current_value 1)
				)
				(assign (associate
					current_map_name
						(call !ExpandMapForSharedDeviations (assoc
							shared_map current_map_value
						))
				))
			))
			(assoc
				"accuracy_map" accuracy_map
				"precision_map" precision_map
				"recall_map" recall_map
				"mcc_map" mcc_map
				"r2_map" r2_map
				"rmse_map" rmse_map
				"spearman_coeff_map" spearman_coeff_map
				"confusion_matrix_map" confusion_matrix_map
			)
		)

		(if (size unique_features_for_populating_output)
			(let
				(assoc
					unique_feature_map (zip unique_features_for_populating_output)
				)
				(accum (assoc
					accuracy_map unique_feature_map
					precision_map unique_feature_map
					recall_map unique_feature_map
					mcc_map unique_feature_map
				))
			)
		)

		(assoc
			".robust" (= (true) robust_residuals)
			".hyperparam_path"
				(if (and use_case_weights (= param_path (list ".default")) )
					;intentionally storing which case weight feature is used for retrieval
					(list ".default" (null) (null) weight_feature)

					param_path
				)
			"accuracy" accuracy_map
			"precision" precision_map
			"recall" recall_map
			"mcc" mcc_map
			"r2" r2_map
			"rmse" rmse_map
			"spearman_coeff" spearman_coeff_map
			"confusion_matrix" confusion_matrix_map
		)
	)

	;helper method for CalculateFeatureResiduals to average out the list(s) of residual values into individual value(s)
	;and prepare output payloads
	#!PrepResidualOutput
	(seq
		;feature_residuals_lists is in the format of:
		; (list
		; 	(list react1 react2 ... react n) ; feature A reacts
		; 	(list react1 react2 ... react_n) ; feature B reacts
		; 	...
		; 	(list react1 react2 ... react n) ; feature N reacts
		; )
		;
		;where each react is either:
		; the diff value, for nominals and continuous, or a list of [diff, ordinal_diff] for continuous ordinal features

		;for each feature, collapse each list of residuals into a single value by averaging them out
		;for ordinals we need to split out the ordinal residuals from the rest
		(if (size ordinal_features_map)
			(seq
				(assign (assoc
					residuals_map
						(zip
							features
							(map
								(lambda (if
									(size (current_value))
									;feature_residuals_lists is of length of features, and corresponds 1-1 to features
									;thus 'feature' is (get features (current_index))
									(if (contains_index ordinal_features_map (get features (current_index)))
										;ordinal feature, (current_value) is a list of tuples [diff, ordinal_diff]
										;create a list of diffs by pulling diff from each tuple
										(/
											(apply "+" (map (lambda (first (current_value))) (current_value)) )
											;compute average by dividing by the number of values
											(size (current_value))
										)

										;else simply compute avg of all diffs
										(/
											(apply "+" (current_value))
											;compute average by dividing by the number of values
											(size (current_value))
										)
									)

									;else if there were no values for this feature, return global feature residual
									(get hyperparam_map (list "featureDeviations" (get features (current_index 1))))
								))
								feature_residuals_lists
							)
						)
					ordinal_residuals_map
						(filter (zip
							features
							(map
								(lambda
									(if (contains_index ordinal_features_map (get features (current_index)))
										(if (size (current_value))
											;ordinal feature, (current_value) is a list of tuples [diff, ordinal_diff]
											;create a list of ordinal_diffs by pulling ordinal_diff from each tuple
											(/
												(apply "+" (map (lambda (last (current_value))) (current_value)) )
												;compute average by dividing by the number of values
												(size (current_value))
											)

											;else if there were no values for this feature, return global feature residual
											(get hyperparam_map (list "featureDeviations" (get features (current_index 1))))
										)
									)
								)
								feature_residuals_lists
							)
						))
				))
			)

			;else simply compute all residuals
			(assign (assoc
				residuals_map
					(zip
						features
						(map
							(lambda (if
								(size (current_value))
								;compute average by dividing by the number of values
								(/ (apply "+" (current_value)) (size (current_value)) )

								;else if there were no values for this feature, return global feature residual
								;or simply null for inactive features
								(if (contains_index !inactiveFeaturesMap (get features (current_index)))
									(null)
									(get hyperparam_map (list "featureDeviations" (get features (current_index 1))))
								)
							))
							feature_residuals_lists
						)
					)
			))
		)

		;return null prediction_stats
		(null)
	)

	;Helper function that takes a mapping that has been reduced, and expands it by readding the features from the groups that have been dropped.
	#!ExpandMapForSharedDeviations
		(declare
			(assoc
				shared_map (null)
				shared_residuals_map (sort (get !sharedResidualsMap))
			)
			(if shared_residuals_map
				(if (~ (list) shared_map)
					(map
						(lambda
							(if (not (contains_value shared_map (current_value)))
								(accum (assoc shared_map (current_value 1)))
							)
						)
						(indices shared_residuals_map)
					)
					; else an assoc
					(map
						(lambda
							(if
								(= (null) (get shared_map (current_index)))
								(if (!= (null) (get shared_map (get shared_residuals_map (current_index))))
									(accum (assoc
										shared_map
											(associate
												(current_index 2)
												(get shared_map (get shared_residuals_map (current_value 2)))
											)
									))
								)
							)
						)
						shared_residuals_map
					)
				)
			)
			(sort shared_map)
		)

	;Helper function to prep shared feature deviations, by taking in a list of features and their list of residuals,
	; combining all of the residuals under the feature key of the group of the shared deviations, and removing the features
	; from the features list whose residuals have been combined into another features.
	#!PrepSharedResiduals
	(declare
		(assoc
			combined_residuals (assoc)
			;takes in a assoc where the key is the name under which the modified features list will be saved under
			features_keys_lists (assoc)
			feature_residuals_keys_lists (assoc)
		)

		(map
			(lambda (let
				(assoc
					current_feature (current_index 1)
					current_deviations (current_value 1)
				)

				(let
					(assoc shared_deviation_feature_key (get !sharedResidualsMap current_feature))
					(if shared_deviation_feature_key
						;if this feature is part of a shared residual group, add it to the feature key for the group
						(accum (assoc
							combined_residuals
								(associate
									shared_deviation_feature_key
										(append
											(if
												;if null, it means that this is the first of set deviations to be appended for the group, thus append to an empty list.
												(= (null) (get combined_residuals shared_deviation_feature_key) )
												[]
												(get combined_residuals shared_deviation_feature_key)
											)
											current_deviations
										)
								)
						))
						;else add this feature and its deviations directly
						(accum (assoc combined_residuals (associate current_feature current_deviations )))
					)
				)
			))
			(zip (first (values features_keys_lists)) (first (values feature_residuals_keys_lists)))
		)

		(assign
			(associate
				(first (indices features_keys_lists)) (replace (indices combined_residuals))
				(first (indices feature_residuals_keys_lists)) (replace (values combined_residuals))
			)
		)
	)

	#!ValidateSharedDeviations
	(let
		;check to make sure that each feature only shows up once in any shared deviations groups
		(assoc
			invalid_repeated_shared_deviations_features (list)
			invalid_unique_shared_deviations_features (list)
			error_message (list)
		)
		(let
			(assoc shared_deviations_features_flattened (list))
			;flatten all of the values in the groups of shared deviations
			(map
				(lambda (accum (assoc
					shared_deviations_features_flattened (current_value 1)
				)))
				shared_deviations_features
			)
			;sort the flattened list
			(assign (assoc shared_deviations_features_flattened (sort shared_deviations_features_flattened)))
			;see if any value appears twice in a row, indicating a duplicate value
			(map
				(lambda
					(let
						(assoc current_shared_deviation_feature (current_value 1))
						(if
							(=
								current_shared_deviation_feature
								(get shared_deviations_features_flattened (+ (current_index) 1))
							)
							(accum (assoc invalid_repeated_shared_deviations_features current_shared_deviation_feature ))
						)
					)
				)
				shared_deviations_features_flattened
			)
		)
		(map
			(lambda
				(let
					(assoc current_shared_deviation_feature (current_index 1))
					(seq
						(if
							(contains_value (indices !uniqueNominalsSet) current_shared_deviation_feature)
							(accum (assoc invalid_unique_shared_deviations_features current_shared_deviation_feature))
						)
					)
				)
			)
			!sharedResidualsMap
		)
		(if
			(or (size invalid_repeated_shared_deviations_features) (size invalid_unique_shared_deviations_features))
			(seq
				(if invalid_repeated_shared_deviations_features
					(accum (assoc
						error_message
							(list (concat
								"Features can only share deviations with one group, the following features are appear in "
								"more than one shared deviations groups: "
								(apply "concat" (trunc (weave (values invalid_repeated_shared_deviations_features (true)) ", ")))
								"."
							))
					))
				)
				(if invalid_unique_shared_deviations_features
					(accum (assoc
						error_message
							(list (concat
								"Features with shared deviations may not be unique nominals, as they have null deviations. "
								"The following features are in a shared deviations group and is a unique nominal: "
								(apply "concat" (trunc (weave invalid_unique_shared_deviations_features ", ")))
								"."
							))
					))

				)
				(conclude (call !Return (assoc errors error_message)))
			)
		)
	)

	;Helper function, for each shared deviation feature, return its group
	#!GetSharedDeviationGrouping
	(declare
		(assoc feature_group_to_retrieve (null))
		(if feature_group_to_retrieve
			(let
				(assoc
					current_key (get !sharedResidualsMap feature_group_to_retrieve)
					current_feature_grouping (list)
				)
				(map
					(lambda
						(if
							(= (current_value) current_key)
							(accum (assoc current_feature_grouping (current_index 1)))
						)
					)
					!sharedResidualsMap
				)
				current_feature_grouping
			)
		)
	)

	;Helper method to sparsify confusion matrices by removing cells whose counts are less than the specified confusion_matrix_min_count
	;and accumulating those leftovers as their own counts.
	;outputs an assoc of feature -> assoc of
	;	matrix: sparsified confusion matrix
	;	leftover_correct: total number of correct predictions for classes that were not statistically significant
	;	leftover_incorrect: total number of incorrect predictions for classes with any correct but statistically insignificant predictions
	;	other_counts: total number of all other statistically insignificant predictions
	;
	;parameters:
	; confusion_matrix_map: assoc of feature -> confusion matrix assoc
	; confusion_matrix_min_count: smallest number of predictions for a class to leave in the confusion matrix
	#!SparsifyConfusionMatrices
	(map
		(lambda	(let
			(assoc
				confusion_matrix (current_value 1)
				leftover_confusion_matrix (assoc)
			)

			(call !ComputeLeftoverConfusionMatrix)

			;create an assoc of class -> row from leftover_confusion_matrix for any rows that had correct predictions
			(declare (assoc
				satistically_insignificant_rows_map
					(filter
						(lambda (get (current_value) (current_index)) )
						leftover_confusion_matrix
					)
			))
			(declare (assoc
				;total of all statistically insignificant correct predictions
				total_leftover_correct_predictions
					(apply "+" (values
						(map (lambda (get (current_value) (current_index))) satistically_insignificant_rows_map)
					))
				;total of all statistically insignificant incorrect predictions (total row count - correct prediction count)
				total_leftover_incorrect_predictions
					(apply "+" (values
						(map
							(lambda
								;subtract predicted count from total of all counts for the row
								(-
									(apply "+" (values (current_value)))
									(get (current_value) (current_index))
								)
							)
							satistically_insignificant_rows_map
						)
					))
			))

			(assoc
				;sparse confusion matrix
				"matrix"
					;filter out any empty rows
					(filter
						(lambda (size (current_value)))

						;filter out values below threshold count from confusion_matrix
						(map
							(lambda
								;filter out the row, keeping only those values >= confusion_matrix_min_count
								(filter
									(lambda (>= (current_value) confusion_matrix_min_count) )
									(current_value)
								)
							)
							;reduce confusion matrix to only those rows where predicted classes had significant counts
							(remove confusion_matrix (indices satistically_insignificant_rows_map))
						)
					)
				;total count of all correct predictions for classes that did not have a statistically significant amount.
				"leftover_correct" (+ (or total_leftover_correct_predictions))
				;total count of all incorrect predictions for classes that did not have a statistically significant amount.
				"leftover_incorrect" (+ (or total_leftover_incorrect_predictions))
				;total count of all other statistically insignificant predictions for classes that were predicted correctly with significance.
				"other_counts"
					(map
						(lambda (apply "+" (values (current_value))))
						;reduce leftover_confusion matrix to only those rows without predicted class counts
						(remove leftover_confusion_matrix (indices satistically_insignificant_rows_map))
					)
			)
		))
		confusion_matrix_map
	)

)
