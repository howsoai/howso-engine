;Contains methods for computing and storing feature residuals.
(null

	;Updates the given hyperparam_map and returns it with updated parameters based on computed residuals
	;parameters:
	; see #!CalculateFeatureResiduals
	#!CalculateResidualsAndUpdateParameters
	(declare
		(assoc
			features (null)
			context_features (null)
			case_ids (null)
			focal_case (null)
			num_samples (null)
			robust_residuals .false
			hyperparameter_feature (null)
			use_case_weights (null)
			weight_feature ".case_weight"
			custom_hyperparam_map (null)
			confusion_matrix_min_count 15
			feature_with_nulls (null)
			compute_null_uncertainties .true
			compute_all_statistics .true
			use_shared_deviations .false
		)

		(if (= (null) context_features)
			(assign (assoc context_features !trainedFeatures))
		)

		;if features aren't specified, use the set of context_features
		(if (= (null) features)
			(assign (assoc features context_features))
		)
		;if not using case weights, change weight_feature to '.none'
		(if (= .false use_case_weights)
			(assign (assoc weight_feature ".none"))
		)

		;set the passed in one as the hyperparam map to use if specified
		(declare (assoc
			hyperparam_map
				(if (= (null) custom_hyperparam_map)
					(call !GetHyperparameters (assoc
						feature hyperparameter_feature
						context_features context_features
						weight_feature weight_feature
					))

					custom_hyperparam_map
				)
		))
		(call !UpdateCaseWeightParameters (assoc set_valid_weight_feature .false ))
		(declare (assoc
			param_path
				;if the param_path is missing, create it here
				(if (= (null) (get hyperparam_map "paramPath"))
					(append
						(if hyperparameter_feature ["targeted" hyperparameter_feature] ["targetless"])
						(call !BuildContextFeaturesKey (assoc context_features features))
						weight_feature
					)

					(get hyperparam_map "paramPath")
				)
		))


		;if there are ordinals but the hyperparameter map doesn't have a featureOrdinalDeviations assoc, initialize it
		(if (and
				(size ordinal_features_map)
				(= (null) (get hyperparam_map "featureOrdinalDeviations"))
			)
			(accum (assoc hyperparam_map (assoc "featureOrdinalDeviations" (assoc))))
		)

		;if storing deviations ensure that featureDeviations is an assoc instead of (null) for correct accumulation
		(if (= (null) (get hyperparam_map "featureDeviations" ))
			(assign (assoc hyperparam_map (set hyperparam_map "featureDeviations" (assoc))))
		)

		(declare (assoc
			output_map
				(call !CalculateFeatureResiduals (assoc
					features features
					context_features context_features
					case_ids case_ids
					focal_case focal_case
					num_samples num_samples
					robust_residuals robust_residuals
					hyperparameter_feature hyperparameter_feature
					use_case_weights use_case_weights
					weight_feature weight_feature
					custom_hyperparam_map hyperparam_map
					compute_all_statistics compute_all_statistics
					confusion_matrix_min_count confusion_matrix_min_count
					compute_null_uncertainties compute_null_uncertainties
					use_shared_deviations use_shared_deviations
				))
		))

		(assign (assoc hyperparam_map (get output_map "hyperparam_map") ))

		;update hyperparam_map with null uncertainties if present
		(if (size (get output_map "nullUncertainties"))
			(let
				(assoc null_uncertainties_map (get output_map "null_uncertainty_map") )
				(assign
					"hyperparam_map"
					(list "nullUncertainties")
					(map
						(lambda
							;append (null)s in front to match the deviations shape
							(append (null) (current_value))
						)
						null_uncertainties_map
					)
				)

				(assign
					"hyperparam_map"
					(list "featureDeviations")
					(map
						(lambda
							;update deviation value with null uncertainies
							(if (contains_index null_uncertainties_map (current_index))
								(if (~ (list) (current_value))
									;if the deviation is a number, wrap it in a triple
									(if (or (~ 0 (first (current_value))) (= (null) (first (current_value))) )
										(append (first (current_value)) (get null_uncertainties_map (current_index)) )

										;else the deviation must be a SDM, wrap it in a list so that the output is a triple
										;in the format of [sdm, null-value, null-null] instead of appending null uncertaintes to the SDM
										(append
											(list (first (current_value 1)))
											(get null_uncertainties_map (current_index))
										)
									)
									(append (list (current_value 1)) (get null_uncertainties_map (current_index)) )
								)

								;leave deviation value as-is
								(current_value)
							)
						)
						(if (size (get hyperparam_map "featureDeviations"))
							(get hyperparam_map "featureDeviations")
							(zip (indices null_uncertainties_map))
						)
					)
				)
			)
		)

		(assign
			"hyperparam_map"
			(list "featureOrdinalDeviations")
			(get output_map "ordinal_residuals_map")
		)

		;return the output map with capped residual values
		(assign (assoc
			output_map
				(call !ExpandResidualValuesToUncertainty  (assoc
					feature_residuals_map output_map
					using_shared_deviations use_shared_deviations
				))
		))
		(assign
			"hyperparam_map"
			["featureResiduals"]
			(map
				(lambda
					(if (~ 0 (current_value))
						(current_value)

						;must be a nominal
						(~ (assoc) (current_value))
						(get (current_value) "expected_deviation")

						;else fall back to null, this should never happen
						(null)
					)
				)
				(get output_map "residual_map")
			)
		)

		hyperparam_map
	)

	;calculate feature residual values, i.e. the mae (mean absolute error of predictions on a sample of the dataset) for each of the specified features
	;returns an assoc containing feature residuals, feature ordinal residuals and the hyperparam_map used for computations
	;
	;parameters:
	; features: optional list of all features to compute residuals for. If not specified will use !trainedFeatures.
	; context_features: list of features to be used as the context. If not specified, will use the value of features.
	; target_residual_feature: optional feature for which to calculate the (MAE) residual. If not specified, will compute for all features.
	; case_ids: optional list of case ids to compute residuals for the action set, will ignore 'action_condition_filter_query' and 'num_samples' if specified
	; local_feature_case_id_map: optional map of feature -> list of case ids, used for computing local full residuals where each feature may use a different list of case ids
	; num_samples: optional, limit on the number of cases for the action set to use in calculating conditional residuals.
	; context_condition_filter_query: optional list of filtering queries for the context set.
	; strict_case_ids: flag, default to false. If true, then any augmentations to case ids is prohibited (selecting additional non-null cases, more null cases, etc.)
	; focal_case: optional case id of case for which to compute residuals for  is to be ignored during computation
	; regional_data_only: flag, default to false. when set to true will only explicitly use the specified case_ids for computation.
	; robust_residuals: string, default to (null). when "deviations" calculates accurate local residuals, otherwise computes residuals robust with respect to the set of contexts used
	;		(across the power set of contexts).  when "robust_mda" will only compute and output MDA using robust residuals. when "missing_information" will compute and average the estimated
	;		missing information for each feature.
	; hyperparameter_feature: optional  default (null).  feature whose hyperparameters to use
	; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight. If unspecified,
	;   			case weights will be used if the trainee has them.
	; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
	; custom_hyperparam_map: optional, hyperparameters to use for residuals computation
	; compute_all_statistics: flag, optional. if set to true will compute other statistics (precision, recall, r^2, rmse, etc.) in addition to MAE
	; confusion_matrix_min_count: number, optional, default is 10. Applicable only to confusion matrices, the number of predictions a class should have
	;		(value of a cell in the matrix) for it to remain in the confusion matrix. If the count is less than this value, it will be accumulated
	;		into a single value of all insignificant predictions for the class and removed from the confusion matrix.
	; use_shared_deviations: flag, optional, default false. If set to true, will return the residuals grouped by shared deviations group, otherwise will return the residuals
	;		calculated on a per feature basis.
	; expand_confusion_matrices: flag, optional, default true. When use_shared_deviations is true, if there are confusion matrices for shared features, they will be copied over
	;		for all non-primary shared features. When false, confusion matrices will not be copied and remain only for the primary features.
	; features_to_derive: a list of features whose values should be derived rather than interpolated
	; forecast_window_length: a length of time to evaluate forecasts over (in seconds when the time feature is a datetime).
	;		When specified (only for full residuals/prediction_stats), computes forecasts and evaluates error at the end of the forecasts
	; output_raw_mda: flag, optional, default false. When robust_residuals is "robust_mda" and this flag is true, will output raw MDA values in 'feature_mda_map'
	; mda_action_feature: string, optional.  When robust_residuals is "robust_mda" and this is set, will output only this specified feature's MDA values
	; convergence_threshold: number, percent threshold used to dynamically limit the number of samples used to determine robust_mda
	; 			Defaults to 0.5, when set to 0 will use all num_feature_probability_samples or all case_ids
	; convergence_samples_growth_rate: number, Rate of increasing the size of each subsequent sample used to dynamically limit the total number of samples used to determine
	;			robust_mda. Defaults to 1.05, increasing by 5% until the delta between residuals is less than 'convergence_threshold'.
	; convergence_min_size: number, the minimum size of the first batch of cases used when dynamically sampling robust residuals for robust_mda. Default of 5000
	#!CalculateFeatureResiduals
	(declare
		(assoc
			;the features to compute residuals for
			features (null)
			;the features to be used as context
			context_features (null)
			target_residual_feature (null)
			regional_data_only .false
			focal_case (null)
			robust_residuals (null)
			strict_case_ids .false

			;ordered by priority for the action set, with the 'case_ids' parameters having the top priority.
			case_ids (list)
			context_condition_filter_query (list)
 			num_samples (null)
			;map of feature -> list of case ids, used for computing local full residuals where each feature may have a different
			;list of case ids for computing its residual, i.e., local data has many nulls for a feature, that feature may have
			;extra cases with non-null values appended to its list to be able to compute a residual value
			local_feature_case_id_map (null)

			hyperparameter_feature (null)
			use_case_weights (null)
			weight_feature ".case_weight"
			custom_hyperparam_map (null)
			compute_all_statistics .false
			compute_null_uncertainties .true
			confusion_matrix_min_count 15
			use_shared_deviations .false
			expand_confusion_matrices .true
			features_to_derive (list)
			forecast_window_length (null)

			output_raw_mda .false
			mda_action_feature (null)
			convergence_threshold 0.005
			convergence_samples_growth_rate  1.05
			convergence_min_size 5000
		)

		(declare (assoc
			k_parameter (null)
			p_parameter (null)
			dt_parameter (null)
			query_feature_attributes_map (null)
			case_features (null)
			ordinal_features_map !ordinalFeaturesSet
			hyperparam_map (assoc)
			residuals_map (assoc)
			ordinal_residuals_map (assoc)
			;assoc of features to skip computing non-robust residuals for if they don't have enough non-null values
			skip_features_map (assoc)
			;list, length of features, each item will be a list of residuals, one per case
			feature_residuals_lists (list)

			num_training_cases (call !GetNumTrainingCases)
			valid_weight_feature .false

			rmse_map (assoc)
			r2_map (assoc)
			spearman_coeff_map (assoc)
			accuracy_map (assoc)
			precision_map (assoc)
			recall_map (assoc)
			adjusted_smape_map (assoc)
			smape_map (assoc)
			mcc_map (assoc)
			confusion_matrix_map (assoc)
			nominal_performance_map (assoc)

			null_uncertainties_map (assoc)
			null_accuracies_map (assoc)
			;list of unique features to populate output at the end
			unique_features_for_populating_output (null)

			;store an assoc of lag/rate/delta feature -> lag/order amount for time series flows
			ts_feature_lag_amount_map (null)
			max_lag_index_value (null)
			feature_mda_map (null)
			features_for_derivation_map (assoc)

			;map of inactive features that were excluded from computations but should be added back in for output
			;with preset values of 0 or 1 as applicable depending on the metric, eg., residual=0, accuracy=1
			excluded_inactive_features_map {}
		))


		;if computing robust accuracy contributions from react_aggregate, num_samples will be null, overwrite num_samples
		;with the number of specified case_ids that are passed in from react_aggregate
		(if (and
				(= "robust_mda" robust_residuals)
				output_raw_mda
				(= (null) num_samples)
				(> convergence_threshold 0)
			)
			(assign (assoc
				num_samples (size case_ids)
				num_feature_probability_samples (size case_ids)
			))
		)

		;when dynamic sampling for computing robust_mda, start with 'convergence_min_size'
		;unless user explicitly specified `num_feature_probability_samples` <= convergence_min_size, in that case don't use dynamic sampling
		(if (and
				(= "robust_mda" robust_residuals)
				(> num_samples convergence_min_size)
				(= num_samples num_feature_probability_samples)
				(> convergence_threshold 0)
			)
			;set the number of samples in the first of the dynamic batches to `convergence_min_size`
			(assign (assoc num_samples convergence_min_size))
		)

		(call !InitResiduals)

		(if (= "deviations" robust_residuals)
			(call !ComputeDeviations)

			;else robust residuals for mda/robut AC
			(= "robust_mda" robust_residuals)
			(if (and (> num_feature_probability_samples convergence_min_size) (> convergence_threshold 0))
				(call !AutoConvergeRobustResiduals)

				;else <= convergence_min_size samples requested, just run them all
				;leave nulls in results during analyze flow so they can be used to compute feature mda later
				(call !RunRobustResiduals (assoc leave_nulls_in_results .true ))
			)

			(= "missing_information" robust_residuals)
			(call !RunMissingInformation)

			;else just robust residuals
			robust_residuals
			(call !RunRobustResiduals (assoc leave_nulls_in_results .false  ))

			;else
			(if forecast_window_length
				;do the forecasting evaluation
				(call !RunForecastResiduals)

				(call !RunFullResiduals)
			)
		)

		;for computing the feature mda matrix, only robust residuals were needed, the rest of the flow below
		;is not necessary since this only needs to output the feature_mda_map
		(if (and (= "robust_mda" robust_residuals) (= (null) target_residual_feature))
			(conclude
				(assoc
					"feature_mda_map"
						(call !ComputeRobustTargetlessMDA (assoc
							features
								(if (size excluded_inactive_features_map)
									(append features (indices excluded_inactive_features_map))

									features
								)
							output_raw_mda output_raw_mda
							mda_action_feature mda_action_feature
						))
				)
			)
		)

		(if use_shared_deviations
			(if (size !sharedDeviationsMap)
				(seq
					(assign (assoc feature_residuals_lists (call !PrepSharedDeviations) ))
					(assign (assoc
						features (filter (lambda (not (contains_value !sharedDeviationsNonPrimaryFeatures (current_value)))) features)
					))
				)

				;else there are no set shared residuals, ignore shared deviations
				(assign (assoc use_shared_deviations .false))
			)
		)

		;if shared deviations, the prediction_stats returned will a fully expanded assoc of prediction stats,
		; however the features list and feature_residuals_lists will be shortened to only features that do not belong
		; to a shared deviations group, or are the primary key for a group of shared deviations.
		(declare (assoc
			prediction_stats
				(if compute_all_statistics
					(call !PrepAllStatisticsResidualOutput)

					(call !PrepResidualOutput)
				))
		)

		(if compute_null_uncertainties
			(let
				(assoc
					features_with_nulls
						(indices (filter
							;keep only features that have at least 2 nulls
							(lambda
								(>=
									(size (contained_entities
										(query_exists (current_index))
										(query_equals (current_index) (null))
									))
									2
								)
							)
							(filter
								;only query features that have nulls
								(lambda (get (current_value) "has_nulls"))
								;ignore all inactive features (where all values are nulls)
								(keep
									(remove !featureNullRatiosMap (indices !inactiveFeaturesMap))
									;if shared deviations, the features list needs to be expanded to include features that were dropped for shared deviations calculations
									(if use_shared_deviations
										(call !ExpandForSharedDeviations (assoc compressed_values features))
										features
									)
								)
							)
						))
					;store an assoc of lag/rate/delta feature -> lag/order amount for time series flows
					ts_feature_lag_amount_map (if !tsTimeFeature (call !BuildTSFeatureLagAmountMap))
				)

				;compute null deviations and update hyperparam_map with them
				(if (size features_with_nulls)
					(call !ComputeNullUncertainties (assoc
						features_with_nulls features_with_nulls
						context_features context_features
						null_cases_map
							(map
								(if (or
										regional_data_only
										(< (size case_ids) 200)
									)
									;if regional data only or small dataset/sample, just filter which of the case ids have nulls for each feature
									(lambda
										(filter
											(lambda (= (null) (retrieve_from_entity (current_value) (current_index 1))))
											case_ids
										)
									)

									;otherwise sample null feature value cases from the dataset using queries
									(lambda
										(contained_entities
											(query_exists (current_index))
											(query_equals (current_index) (null))

											;time series derived features only consider cases outside the null triangle at the start of a series
											;e.g., a lag of 2 feature, will only consider nulls from cases with index >= 2
											(if (and !tsTimeFeature (contains_index ts_feature_lag_amount_map (current_index)))
												(query_greater_or_equal_to ".series_index" (get ts_feature_lag_amount_map (current_index)) )

												;else don't constrain
												(null)
											)

											(query_sample 200)
										)
									)
								)
								(zip features_with_nulls)
							)
					))
				)
			)
		)

		;unique features have a residual of (null)
		(if unique_features_for_populating_output
			(accum (assoc
				residuals_map (zip unique_features_for_populating_output)
			))
		)

		;during analyze reduce residual
		;TODO: fix this so it's not simply set residual to half its value (approximate average between this computed and theoretical smallest)
		(if in_analyze
			(assign (assoc
				residuals_map (map (lambda (/ (current_value) 2)) residuals_map)
			))
		)

		;put excluded inactive features back into residuals_map with 0s
		(if (size excluded_inactive_features_map)
			(accum (assoc residuals_map (map 0 excluded_inactive_features_map) ))
		)

		;for shared deviations, only one set of deviations are calculated for each group. At the end of the calculations,
		; the deviations mapping is expanded to add back the other features whose deviations were not calculated and point them at the feature
		; in which their shared deviations are stored under.
		(if use_shared_deviations
			(map
				(lambda (let
					(assoc
						current_map_name (current_index 1)
						current_map_value (current_value 1)
					)
					(assign (associate
						current_map_name
							(call !ExpandForSharedDeviations (assoc compressed_values current_map_value))
					))
				))
				(assoc
					"ordinal_residuals_map" ordinal_residuals_map
					"residuals_map" residuals_map
					"null_uncertainties_map" null_uncertainties_map
				)
			)
		)

		;if there are time series features where the nulls are only in the lag null-triangle, set their uncertainties to
		;the MAD and feature residual so that the deltas to these features in these triangle cases aren't extreme (neither too far nor too close)
		(if (and compute_null_uncertainties (size ts_feature_lag_amount_map))
			(assign (assoc
				null_uncertainties_map
					(map
						(lambda
							;(current_index) is the feature
							;(current_value) is a pair of [ ts lag amount, null uncertainty pair], where the uncertainty pair is [null-value, null-null]
							(if (first (current_value))
								;if there was a computed null uncertainty, use a weighted average of the computed uncertainty and the MAD/residual
								(if (last (current_value))
									(let
										(assoc
											;nulls resulting from the explicit nulls in the original data
											num_natural_nulls
												(size (contained_entities
													(query_exists (current_index 1))
													(query_equals (current_index 1) (null))
													;time series derived features only consider cases outside the null triangle at the start of a series
													;e.g., a lag of 2 feature, will only consider nulls from cases with index >= 2
													(query_greater_or_equal_to ".series_index" (first (current_value 1)) )
												))

											computed_null_uncertainty_pair (last (current_value 1))
											;double value to store the computed residual (undo the halfing done above)
											expected_uncertainty (* 2 (get residuals_map (current_index 1)))
										)
										(declare (assoc
											;nulls at the start of every series due to lags not having values defined
											num_triangle_nulls
												(-
													(size (contained_entities
														(query_exists (current_index 1))
														(query_equals (current_index 1) (null))
													))
													num_natural_nulls
												)
										))

										(declare (assoc
											triangle_null_weight (/ num_triangle_nulls (+ num_triangle_nulls num_natural_nulls))
											natural_null_weight (/ num_natural_nulls (+ num_triangle_nulls num_natural_nulls))
										))

										;store the uncertainty as a weighted average, reasoning is that the stored uncertainty should more closely
										;reflect the value of the uncertainties of nulls that are the majority of the dataset
										[
											;null-value uncertainty is weighted average of MAD and computed uncertainty
											(+
												(* triangle_null_weight (get !expectedValuesMap [weight_feature (current_index 2) "mean_absolute_deviation"]) )
												(* natural_null_weight (first computed_null_uncertainty_pair))
											)
											;null-null uncertainty is weighted average of residual and computed uncertainty
											(+
												(* triangle_null_weight expected_uncertainty)
												(* natural_null_weight (last computed_null_uncertainty_pair))
											)
										]
									)

									;else set the uncertainties to the feature residual [null-value, null-null]
									[
										;null-value is the MAD
										(get !expectedValuesMap [weight_feature (current_index 2) "mean_absolute_deviation"])
										;null-null, double deviation value to store the computed residual (undo the halfing done above)
										(* 2 (get residuals_map (current_index 1)))
									]
								)

								;else not a time series feature with lags, keep the computed null uncertainties as-is
								(last (current_value))
							)
						)
						ts_feature_lag_amount_map
						null_uncertainties_map
					)
			))
		)

		(assoc
			"residual_map" residuals_map
			"ordinal_residual_map" ordinal_residuals_map
			"hyperparam_map" hyperparam_map
			"prediction_stats" prediction_stats
			"null_uncertainty_map" null_uncertainties_map
			"null_accuracy_map" null_accuracies_map
			"feature_mda_map" feature_mda_map
		)
	)

	;Helper method for CalculateFeatureResiduals to compute and output all basic prediction stats from the residuals
	#!PrepAllStatisticsResidualOutput
	(let
		(assoc
			feature_indices_map (zip features (indices features))
			continuous_features (filter (lambda (not (contains_index !nominalsMap (current_value)))) features)
			continuous_indices (list)
			nominal_features (filter (lambda (contains_index !nominalsMap (current_value))) features)
			nominal_indices (list)
			numeric_continuous_features (null)
			numeric_continuous_indices (null)
		)

		;feature_residuals_lists is in the format of:
		; (list
		; 	(list react1 react2 ... react n) ; feature A reacts
		; 	(list react1 react2 ... react_n) ; feature B reacts
		; 	...
		; 	(list react1 react2 ... react n) ; feature N reacts
		; )
		;
		;where each react is a list of tuples of either:
		; [diff, actual_value, predicted] for nominals or
		; [diff, ordinal_diff, actual_value, predicted_value] for continuous (ordinal_diff is not there for non-ordinal features)

		(assign (assoc
			continuous_indices (unzip feature_indices_map continuous_features)
			nominal_indices (unzip feature_indices_map nominal_features)
			has_ordinals (> (size ordinal_features_map) 0)
			;default index offset of where the actual case value is in each output react
			actual_offset 1
			predicted_offset 2
			actual_nom_offset (if compute_all_statistics 2 1)
			predicted_nom_offset (if compute_all_statistics 3 2)
			cap_offset 1
		))

		;if some of the features are edit distance types, r2 and spearman coefficient don't apply since there's no mean or relative sorting
		;filter out those out of the lists of continuous fetaures and not compute those stats for them
		(if (size !editDistanceFeatureTypesMap)
			(seq
				(assign (assoc
					numeric_continuous_features
						(filter (lambda (not (contains_index !editDistanceFeatureTypesMap (current_value)))) continuous_features)
				))
				(assign (assoc numeric_continuous_indices (unzip feature_indices_map numeric_continuous_features) ))
			)

			(assign (assoc
				numeric_continuous_features continuous_features
				numeric_continuous_indices continuous_indices
			))
		)

		(if has_ordinals
			(assign (assoc
				;for continuous features, each react output is stored as [diff, actual_value, predicted_value]
				;but if there are ordinals, it's stored as [diff, ordinal_diff, actual_value, predicted_value]
				;if there are ardinals, the index offest for actual_value is 2 instead of 1
				actual_offset 2
				predicted_offset 3

				ordinal_residuals_map
					(filter (zip
						continuous_features
						(map
							(lambda
								(if (contains_index ordinal_features_map (get continuous_features (current_index)))
									(if (size (current_value))
										;create a list of ordinal_diffs by pulling ordinal_diff from each tuple
										(generalized_mean (map (lambda (get (current_value) 1)) (current_value)) )

										;else if there were no values for this feature, return global feature residual
										(get hyperparam_map (list "featureResiduals" (get continuous_features (current_index 1))))
									)
								)
							)
							(unzip feature_residuals_lists continuous_indices)
						)
					))
			))
		)

		;iterate over each continuous feature's list of reacts and compute the MAE, RMSE, R^2, and spearman coefficient
		(declare (assoc
			continuous_stats_maps
				(zip
					continuous_features
					||(map
						(lambda (assoc
							;(current_value 1) is a list of react tuples for each feature

							;MAE - mean absolute error = sum(|actual-predicted|) / num_cases
							residuals
								(if (size (current_value 1))
									(generalized_mean (map (lambda (first (current_value))) (current_value 1)) )

									;else if there were no values for this feature, return global feature residual
									(get hyperparam_map [ "featureResiduals" (get continuous_features (current_index 2)) ] )
								)

							;RMSE - root mean squared error = sqrt( sum( |actual-predicted|^2 ) / num_cases )
							rmse
								(if (size (current_value 1))
									;generalized mean with p=2 computes root mean squared
									(generalized_mean
										(map (lambda (first (current_value)) ) (current_value 1))
										2
									)
								)
						))
						(unzip feature_residuals_lists continuous_indices)
					)
				)
		))

		(assign (assoc
			residuals_map (map (lambda (get (current_value) "residuals")) continuous_stats_maps)
			rmse_map (map (lambda (get (current_value) "rmse")) continuous_stats_maps)
		))

		(declare (assoc
			numeric_stats_maps
				(zip
					numeric_continuous_features
					||(map
						(lambda (if
							(size (current_value))
							(assoc
								;spearman coefficient = 1 - 6 * sum(|actual_rank-predicted_rank|^2) / (num_cases^3 - num_cases)
								;where actual_rank and predicted_rank are the 1-based sorted rank of values for each
								spearman_coeff
									;must have at least 2 values to compute spearman coefficient
									(if (> (size (current_value 1)) 1)
										(let
											(assoc
												actual_ranks_map
													(call !GetRankMapForValues (assoc
														values (map (lambda (get (current_value) actual_offset)) (current_value 3))
													))
												predicted_ranks_map
													(call !GetRankMapForValues (assoc
														values (map (lambda (last (current_value))) (current_value 3))
													))
											)
											(- 1
												(* 6 (/
													(apply "+" (map
														(lambda
															(pow
																(-
																	(get actual_ranks_map (get (current_value) actual_offset))
																	(get predicted_ranks_map (last (current_value)))
																)
																2
															)
														)
														(current_value 1)
													))

													(- (pow (size (current_value 1)) 3) (size (current_value 1)))
												))
											)
										)
									)

								;R squared = 1 - sum(|actual-predicted|^2) / sum(|actual-mean|^2)
								r_squared
									(let
										(assoc
											mean_value
												;average of all actual values
												(generalized_mean (map (lambda (get (current_value) actual_offset)) (current_value 2)) )
											sum_res_squared
												(apply "+" (map (lambda (pow (first (current_value)) 2)) (current_value 2)) )
											sum_tot_squared 0
										)

										(assign (assoc
											sum_tot_squared
												(apply "+"
													(map
														(lambda
															;(mean - actual)^2
															(pow (- mean_value (get (current_value) actual_offset)) 2)
														)
														(current_value 2)
													)
												)
										))

										;output r^2 value:  1 - SSres / SStot
										;cap the smallest allowed r2 value to the float min value of -3.4028234663852886e+38
										(max
											(- 1 (/ sum_res_squared sum_tot_squared))
											-340282346638528859811704183484516925440
										)
									)

								;smape = |predicted - actual| / ((|actual| + |predicted|) / 2) * 100
								smape
									(*
										(generalized_mean
											(map
												(lambda (let
													(assoc
														smape_numerator
															(abs (-
																(get (current_value 1) predicted_offset)
																(get (current_value 1) actual_offset)
															))
														smape_denominator
															(/
																(+
																	(abs (get (current_value 1) actual_offset))
																	(abs (get (current_value 1) predicted_offset))
																)
																2
															)
													)
													(if (= smape_denominator 0)
														;if the denominator is 0, that means actual and predicted are both 0
														; which should have a error of 0
														0
														(/ smape_numerator smape_denominator)
													)
												))
												(current_value 1)
											)
										)
										100
									)

								;adjusted_smape = |predicted - actual| / ((|actual| + |predicted|) / 2) * 100 where min gap / 2 is added to both the actual and predicted values.
								adjusted_smape
									(let
										(assoc
											half_min_gap (get !cachedFeatureHalfMinGapMap (get numeric_continuous_features (current_index 2)))
										)
										(*
											(generalized_mean
												(map
													(lambda (let
														(assoc
															adjusted_smape_numerator
																(abs (-
																	(+ (get (current_value 1) predicted_offset) half_min_gap)
																	(+ (get (current_value 1) actual_offset) half_min_gap)
																))
															adjusted_smape_denominator
																(/
																	(+
																		(+ (abs (get (current_value 1) actual_offset)) half_min_gap)
																		(+ (abs (get (current_value 1) predicted_offset)) half_min_gap)
																	)
																	2
																)
														)
														(if (= adjusted_smape_denominator 0)
															;if the denominator is 0, that means actual and predictd are both 0
															; which should have a error of 0
															0
															(/ adjusted_smape_numerator adjusted_smape_denominator)
														)
													))
													(current_value 1)
												)
											)
											100
										)
									)

							)
						))
						(unzip feature_residuals_lists numeric_continuous_indices)
					)
				)
		))

		(assign (assoc
			spearman_coeff_map (map (lambda (get (current_value) "spearman_coeff")) numeric_stats_maps)
			r2_map (map (lambda (get (current_value) "r_squared")) numeric_stats_maps)
			smape_map (map (lambda (get (current_value) "smape")) numeric_stats_maps)
			adjusted_smape_map (map (lambda (get (current_value) "adjusted_smape")) numeric_stats_maps)

		))

		(accum (assoc
			residuals_map
				(zip
					nominal_features
					;iterate over nominal features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							(size (current_value))
							(generalized_mean (map (lambda (first (current_value))) (current_value)) )

							;else if there were no values for this feature, return global feature residual
							(replace (get hyperparam_map (list "featureResiduals" (replace (get nominal_features (current_index 1))))))
						))
						(unzip feature_residuals_lists nominal_indices)
					)
				)
		))

		(assign (assoc
			confusion_matrix_map
				;analyze uses confusion matrix to compute SDM, use Categorical Action Probabilities for higher fidelity of nominal residuals
				(if in_analyze
					(zip
						nominal_features
						||(map
							(lambda
								(zip
									(lambda
										(map
											(lambda
												(apply "+" (filter (current_value)))
											)
											(current_value 1)
											(current_value)
										)
									)
									(map (lambda (get (current_value) actual_nom_offset) ) (current_value))
									(map (lambda (get (current_value) cap_offset) ) (current_value))
								)
							)
							(unzip feature_residuals_lists nominal_indices)
						)
					)

					;else compute confusion matrix using counts of correct guesses for each class
					(zip
						nominal_features
						;iterate over nominal features, where (current_value) is a list of react tuples for each feature
						||(map
							(lambda
								(map
									(lambda
										(zip
											;all collisions will increase the count value
											;e.g. zipping ["small" "medium" "small"] will create { small 1 medium 1 } then accumulate a 1
											;for the second "small" in the list since it's a key collision, resulting in { small 2 medium 1 }
											(lambda (+ 1 (current_value 1)) )
											;ensure to zip a list of classes instead of single value by converting it to a list if it isn't a list already
											(if (~ [] (current_value))
												(current_value)
												[(current_value 1)]
											)
											;zip all classes with a value of 1 so that all clases in the predicted list are assigned a value of 1
											(range
												(lambda 1)
												1
												;if there is only one entry for a value, then it's predicted values: (current_value)
												;will be singular (not a list, size=0), so we bound the list of 1's to be at least size=1
												(max 1 (size (current_value)))
												1
											)
										)
									)
									;keep only those class values that had non-null counts
									(filter
										(lambda (size (current_value)))
										;nominal prediction tuples are in the format of [diff, actual, predicted]
										;thus this iterates over the two corresponding lists of [actual] and [predicted] values
										;accruing into an assoc of lists of predicted classes for every provided actual class, e.g.,
										;given actual ["a" "a" "x" "x" "x"] and predicted ["a" "a" "x" "a" "x"] results in:
										; {
										;	"a" [ "a" a" ]
										;	"x" [ "x "a" "x"]
										; }
										(map
											;filter out the nulls out of the list of predicted values
											(lambda (filter (replace (current_value))))
											(zip
												;iterate over pairs of (actual value, predicted value), this lambda is run when there is a
												;key collision (actual value). In that case append the new predicted value to get an assoc of
												; actual values to the list of values they are predicted as
												(lambda
													(append (replace (current_value 1)) (list (replace (current_value 1))))
												)
												;(get (current_value) 1) refers to the actual case value in each react tuple
												(map (lambda (replace (get (current_value) actual_nom_offset))) (current_value))
												;and (get (current_value) 2) refers to the interpolated/predicted case value in
												;each react tuple
												(map (lambda (replace (get (current_value) predicted_nom_offset))) (current_value))
											)
										)
									)
								)
							)
							(unzip feature_residuals_lists nominal_indices)
						)
					)
				)
		))

		;accumulate nominal feature stats (accuracy, precision, recall, mcc) in one pass
		(declare (assoc
			nominal_stats_maps
				||(map
					(lambda (let
						;grab the current action feature's confusion matrix
						(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
						(if (size confusion_matrix)
							(assoc
								;accuracy is: num correct predictions / all predictions
								accuracy
									(/
										;correct predictions count
										(apply "+" (values
											;get correct prediction count for each class
											(map
												(lambda (or (get (current_value) (current_index))))
												confusion_matrix
											)
										))
										;total predictions count
										(apply "+" (values
											;add up all prediction counts for all classes
											(map (lambda (apply "+" (filter (values (current_value))))) confusion_matrix)
										))
									)

								;recall for a single class is = TruePositives / (TruePositives + FalseNegatives)
								recall
									;for each row in confusion matrix, average out: correct / total of row
									(/
										(apply "+"
											(values (map
												(lambda (let
													(assoc row_total (apply "+" (values (current_value 1))) )
													;if there were no  predictions at all for this class, prevent divide by zero
													(if (> row_total 0)
														(/ (or (get (current_value) (current_index)) 0) row_total)
														0
													)
												))
												confusion_matrix
											))
										)
										;The 'confusion_matrix' may not be a square matrix. Divides by the length of the rows or columns
										; as if the matrix was square by taking the max of the number of non-empty rows or the number
										; of uniquely predicted column indices.
										(max
											;Number of rows, filter out empty rows
											(size
												(filter (lambda (size (current_value))) confusion_matrix)
											)
											;Number of unique columns
											(size (values
												(apply "append"
													(map
														(lambda (indices (current_value)))
														(values confusion_matrix)
													)
												)
												.true
											))
										)
									)

								;precision for a single class is = TruePositives / (TruePositives + FalsePositives)
								precision
									;for each column in confusion matrix, average out: correct / total of column
									(/
										;correct predictions count
										(apply "+"
											(values (map
												(lambda (let
													(assoc
														class (current_index 1)
														column_total (null)
													)
													(assign (assoc
														column_total
															(apply "+"
																(values (map
																	(lambda (or (get (current_value) class) 0) )
																	confusion_matrix
																))
															)
													))
													;if there were no guesses for this class at all, prevent divide by zero
													(if (> column_total 0)
														(/ (or (get (current_value) class) 0) column_total)
														0
													)
												))
												confusion_matrix
											))
										)
										;The 'confusion_matrix' may not be a square matrix. Divides by the length of the rows or columns
										; as if the matrix was square by taking the max of the number of non-empty rows or the number
										; of uniquely predicted column indices.
										(max
											;Number of rows, filter out empty rows
											(size
												(filter (lambda (size (current_value))) confusion_matrix)
											)
											;Number of unique columns
											(size (values
												(apply "append"
													(map
														(lambda (indices (current_value)))
														(values confusion_matrix)
													)
												)
												.true
											))
										)
									)

								;generalized multi-class formula for Matthews Correlation Coefficient (mcc) is located https://en.wikipedia.org/wiki/Phi_coefficient#Multiclass_case
								mcc
									(let
										(assoc
											;get the total correctly predicted counts, variable c in the mcc formula
											total_predicted_correct
												(apply "+" (values
													(map (lambda (or (get (current_value) (current_index))) ) confusion_matrix)
												))
											;get the total number of samples, variable s in the mcc formula
											total_samples
												(apply "+" (values
													(map (lambda (apply "+" (filter (values (current_value))))) confusion_matrix)
												))
											;get a list containing the true counts of each class, vector t in the mcc formula
											true_counts
												(append (values
													(map
														(lambda (apply "+" (filter (values (get confusion_matrix (current_index))))))
														confusion_matrix
													)
												))
											;get a list containing the predicted counts of each class, vector p in the mcc formula
											predicted_counts
												(append (values
													(map
														(lambda
															(apply "+" (values (map
																;current_index 1 is the predicted class that is being aggregated
																(lambda (or (get (current_value) (current_index 1))) 0)
																confusion_matrix
															)))
														)
														confusion_matrix
													)
												))
										)

										;calculates the mcc
										(declare (assoc
											mcc_numerator
												(- (* total_predicted_correct total_samples) (dot_product true_counts predicted_counts))
											mcc_denominator
												(*
													(sqrt (- (pow total_samples 2) (dot_product true_counts true_counts)))
													(sqrt (- (pow total_samples 2) (dot_product predicted_counts predicted_counts)))
												)
										))

										(if (or (= mcc_numerator 0) (= mcc_denominator 0))
											0
											(/ mcc_numerator mcc_denominator)
										)
									)
							)
						)
					))
					(zip nominal_features)
				)
		))

		(assign (assoc
			accuracy_map (map (lambda (get (current_value) "accuracy")) nominal_stats_maps)
			precision_map (map (lambda (get (current_value) "precision")) nominal_stats_maps)
			recall_map (map (lambda (get (current_value) "recall")) nominal_stats_maps)
			mcc_map (map (lambda (get (current_value) "mcc")) nominal_stats_maps)
		))

		(if (= (null) param_path)
			(declare (assoc param_path (get hyperparam_map "paramPath")))
		)

		;create a map to balance counts in confusion_matrix_map based on class masses
		(if (size confusion_matrix_map)
			(assign (assoc
				confusion_matrix_map
					(map
						(lambda (let
							(assoc
								count_balance_map (get !expectedValuesMap [weight_feature (current_index 2) "count_balance"] )
							)
							;for every class in the matrix, fix the class's counts such that the total count remains the same
							;but individual class counts are scaled relative to each class's mass
							(map
								(lambda
									;if there's only one value in the row, leave it as-is
									(if (= 1 (size (current_value)))
										(current_value)

										(let
											(assoc
												total_row_count (apply "+" (values (current_value 1)))
												balanced_row
													(map
														(lambda (* (first (current_value)) (last (current_value))))
														(current_value 1)
														(keep count_balance_map (indices (current_value 1)))
													)
											)

											(declare (assoc
												scale_back_to_original_row_count (/ total_row_count (apply "+" (values balanced_row)) )
											))

											;output balanced row that has been scaled to same total as the original row
											(map
												(lambda (* scale_back_to_original_row_count (current_value)))
												balanced_row
											)
										)
									)
								)
								(current_value)
							)
						))
						confusion_matrix_map
					)
			))
		)

		;wrap each confusion matrix in an assoc
		(assign (assoc
			confusion_matrix_map
				;sparsify matrix if confusion_matrix_min_count is specified and there is a confusion matrix to sparsify
				(if (and
						(size confusion_matrix_map)
						(> confusion_matrix_min_count 0)
					)
					(call !SparsifyConfusionMatrices (assoc
						confusion_matrix_min_count confusion_matrix_min_count
						confusion_matrix_map confusion_matrix_map
					))

					(map
						(lambda (assoc
							"matrix" (current_value 1)
							"leftover_correct" 0
							"leftover_incorrect" 0
							"other_counts" 0
						))
						confusion_matrix_map
					)
				)
		))

		;copy over all the stats for non-primary shared features
		(if use_shared_deviations
			(map
				(lambda (let
					(assoc
						current_map_name (current_index 1)
						current_map_value (current_value 1)
					)
					;only expand shared devitaions that are not confusion_matrix_map
					;if expand_confusion_matrices flag is true, will also expand confusion_matrix_map
					(if (or
							(!= "confusion_matrix_map" current_map_name)
							expand_confusion_matrices
						)
						(assign (associate
							current_map_name
								(call !ExpandForSharedDeviations (assoc compressed_values current_map_value))
						))
					)
				))
				(assoc
					"accuracy_map" accuracy_map
					"precision_map" precision_map
					"recall_map" recall_map
					"mcc_map" mcc_map
					"r2_map" r2_map
					"rmse_map" rmse_map
					"spearman_coeff_map" spearman_coeff_map
					"confusion_matrix_map" confusion_matrix_map
				)
			)
		)

		;null out stats for unique features that don't apply
		(if (size unique_features_for_populating_output)
			(let
				(assoc
					unique_feature_map (zip unique_features_for_populating_output)
				)
				(accum (assoc
					accuracy_map unique_feature_map
					precision_map unique_feature_map
					recall_map unique_feature_map
					mcc_map unique_feature_map
				))
			)
		)

		(if (size excluded_inactive_features_map)
			(seq
				;put nominal inactive features back in
				(if (size (keep excluded_inactive_features_map (indices !nominalsMap)))
					(let
						(assoc
							nominal_inactives_map (map 1 (keep excluded_inactive_features_map (indices !nominalsMap)) )
						)
						(accum (assoc
							accuracy_map nominal_inactives_map
							precision_map nominal_inactives_map
							recall_map nominal_inactives_map
							mcc_map nominal_inactives_map
						))
					)
				)

				;put continuous inactive features back in
				(if (size (remove excluded_inactive_features_map (indices !nominalsMap)))
					(let
						(assoc
							continuous_inactives_1_map (map 1 (remove excluded_inactive_features_map (indices !nominalsMap)) )
							continuous_inactives_0_map (map 0 (remove excluded_inactive_features_map (indices !nominalsMap)) )
						)
						(accum (assoc
							r2_map continuous_inactives_1_map
							spearman_coeff_map continuous_inactives_1_map
							rmse_map continuous_inactives_0_map
							adjusted_smape_map continuous_inactives_0_map
							smape_map continuous_inactives_0_map
						))
					)
				)
			)
		)

		(assoc
			".robust" (and robust_residuals (!= "deviations" robust_residuals))
			".hyperparam_path"
				(if (and use_case_weights (= param_path (list ".default")) )
					;intentionally storing which case weight feature is used for retrieval
					(list ".default" (null) (null) weight_feature)

					param_path
				)
			"accuracy" accuracy_map
			"precision" precision_map
			"recall" recall_map
			"mcc" mcc_map
			"r2" r2_map
			"rmse" rmse_map
			"smape" smape_map
			"adjusted_smape" adjusted_smape_map
			"spearman_coeff" spearman_coeff_map
			"confusion_matrix" confusion_matrix_map
		)
	)

	;helper method for CalculateFeatureResiduals to average out the list(s) of residual values into individual value(s)
	;and prepare output payloads
	#!PrepResidualOutput
	(seq
		;feature_residuals_lists is in the format of:
		; (list
		; 	(list react1 react2 ... react n) ; feature A reacts
		; 	(list react1 react2 ... react_n) ; feature B reacts
		; 	...
		; 	(list react1 react2 ... react n) ; feature N reacts
		; )
		;
		;where each react is either:
		; the diff value, for nominals and continuous, or a list of [diff, ordinal_diff] for continuous ordinal features

		;for each feature, collapse each list of residuals into a single value by averaging them out
		;for ordinals we need to split out the ordinal residuals from the rest
		(if (size ordinal_features_map)
			(seq
				(assign (assoc
					residuals_map
						(zip
							features
							(map
								(lambda (if
									(size (current_value))
									;feature_residuals_lists is of length of features, and corresponds 1-1 to features
									;thus 'feature' is (get features (current_index))
									(if (contains_index ordinal_features_map (get features (current_index)))
										;ordinal feature, (current_value) is a list of tuples [diff, ordinal_diff]
										;create a list of diffs by pulling diff from each tuple
										(generalized_mean (map (lambda (first (current_value))) (current_value)) )

										;else simply compute avg of all diffs
										(generalized_mean (current_value))
									)

									;else if there were no values for this feature, return global feature residual
									(get hyperparam_map (list "featureDeviations" (get features (current_index 1))))
								))
								feature_residuals_lists
							)
						)
					ordinal_residuals_map
						(filter (zip
							features
							(map
								(lambda
									(if (contains_index ordinal_features_map (get features (current_index)))
										(if (size (current_value))
											;ordinal feature, (current_value) is a list of tuples [diff, ordinal_diff]
											;create a list of ordinal_diffs by pulling ordinal_diff from each tuple
											(generalized_mean (map (lambda (last (current_value))) (current_value)) )

											;else if there were no values for this feature, return global feature residual
											(get hyperparam_map (list "featureDeviations" (get features (current_index 1))))
										)
									)
								)
								feature_residuals_lists
							)
						))
				))
			)

			;else simply compute all residuals
			(assign (assoc
				residuals_map
					(zip
						features
						(map
							(lambda (if
								(size (current_value))
								;compute average by dividing by the number of values
								(generalized_mean (current_value))

								;else if there were no values for this feature, return global feature residual
								;or simply null for inactive features
								(if (contains_index !inactiveFeaturesMap (get features (current_index)))
									(null)
									(get hyperparam_map (list "featureResiduals" (get features (current_index 1))))
								)
							))
							feature_residuals_lists
						)
					)
			))
		)

		;return null prediction_stats
		(null)
	)

	;Helper method to sparsify confusion matrices by removing cells whose counts are less than the specified confusion_matrix_min_count
	;and accumulating those leftovers as their own counts.
	;outputs an assoc of feature -> assoc of
	;	matrix: sparsified confusion matrix
	;	leftover_correct: total number of correct predictions for classes that were not statistically significant
	;	leftover_incorrect: total number of incorrect predictions for classes with any correct but statistically insignificant predictions
	;	other_counts: total number of all other statistically insignificant predictions
	;
	;parameters:
	; confusion_matrix_map: assoc of feature -> confusion matrix assoc
	; confusion_matrix_min_count: smallest number of predictions for a class to leave in the confusion matrix
	#!SparsifyConfusionMatrices
	(map
		(lambda	(let
			(assoc
				confusion_matrix (current_value 1)
				leftover_confusion_matrix (assoc)
			)

			(call !ComputeLeftoverConfusionMatrix)

			;create an assoc of class -> row from leftover_confusion_matrix for any rows that had correct predictions
			(declare (assoc
				satistically_insignificant_rows_map
					(filter
						(lambda (get (current_value) (current_index)) )
						leftover_confusion_matrix
					)
			))
			(declare (assoc
				;total of all statistically insignificant correct predictions
				total_leftover_correct_predictions
					(apply "+" (values
						(map (lambda (get (current_value) (current_index))) satistically_insignificant_rows_map)
					))
				;total of all statistically insignificant incorrect predictions (total row count - correct prediction count)
				total_leftover_incorrect_predictions
					(apply "+" (values
						(map
							(lambda
								;subtract predicted count from total of all counts for the row
								(-
									(apply "+" (values (current_value)))
									(get (current_value) (current_index))
								)
							)
							satistically_insignificant_rows_map
						)
					))
			))

			(assoc
				;sparse confusion matrix
				"matrix"
					;filter out any empty rows
					(filter
						(lambda (size (current_value)))

						;filter out values below threshold count from confusion_matrix
						(map
							(lambda
								;filter out the row, keeping only those values >= confusion_matrix_min_count
								(filter
									(lambda (>= (current_value) confusion_matrix_min_count) )
									(current_value)
								)
							)
							;reduce confusion matrix to only those rows where predicted classes had significant counts
							(remove confusion_matrix (indices satistically_insignificant_rows_map))
						)
					)
				;total count of all correct predictions for classes that did not have a statistically significant amount.
				"leftover_correct" (+ (or total_leftover_correct_predictions))
				;total count of all incorrect predictions for classes that did not have a statistically significant amount.
				"leftover_incorrect" (+ (or total_leftover_incorrect_predictions))
				;total count of all other statistically insignificant predictions for classes that were predicted correctly with significance.
				"other_counts"
					(map
						(lambda (apply "+" (values (current_value))))
						;reduce leftover_confusion matrix to only those rows without predicted class counts
						(remove leftover_confusion_matrix (indices satistically_insignificant_rows_map))
					)
			)
		))
		confusion_matrix_map
	)

	;run a series of forecasts from each case in case_ids and evaluate the error in predicting each feature
	;at the end of the forecast of length specified by forecast_window_length
	#!RunForecastResiduals
	(seq
		(declare (assoc
			series_id_features (get !tsFeaturesMap "series_id_features")
			;find and store the largest referenced lag value among derived_context_features
			largest_max_row_lag
				;or with 0 to prevent null
				(or 0 (apply "max"
					(values (map
						(lambda (get (current_value ) "max_row_lag"))
						!featureAttributes
					))
				))
			all_features (values (append features context_features) .true)
			action_features features
		))

		(declare (assoc
			feature_index_map (zip all_features (indices all_features))
			;parameters needed within ReactSeries
			derived_context_features
				(filter
					(lambda (contains_value all_features (get !derivedFeaturesMap (current_value))))
					(get !tsFeaturesMap "lag_features")
				)
			derived_action_features
				(append
					(filter
						(lambda (contains_value all_features (get !derivedFeaturesMap (current_value))))
						(get !tsFeaturesMap "derived_order_features")
					)
					(filter
						(lambda (not (contains_index series_id_features_set (current_value))))
						;list of original features (ones not starting with a '.') that have derived_feature_code should be derived for output
						(filter
							(lambda
								(and
									(!= "." (first (current_value)))
									(get !featureAttributes (list (current_value 1) "derived_feature_code"))
								)
							)
							all_features
						)
					)
				)
		))

		;Another param needed in ReactSeries
		(declare (assoc
			series_action_features
				(append
					(filter
						(lambda
							(or
								;categorical features are in the "delta_features" list...
								(!= "continuous" (get !featureAttributes [(current_value 1) "type"]))
								(contains_value derived_action_features (get !derivedFeaturesMap (current_value)))
							)
						)
						(get !tsFeaturesMap "delta_features")
					)
					(filter
						(lambda (contains_value derived_action_features (get !derivedFeaturesMap (current_value))))
						(get !tsFeaturesMap "rate_features")
					)
				)
			;list, length of case_ids, each item will be a list of residual values, one per feature
			case_residuals_lists (list)
		))

		(assign (assoc
			case_residuals_lists
				||(map
					(lambda
						;For each case, forecast until the window-length is elapsed and interpolate both
						;the forecast and the trained series to get find the error at the end of the window
						(let
							(assoc
								case_id (current_value 1)
								series_id_values (retrieve_from_entity (current_value 1) series_id_features)
								case_time_value (retrieve_from_entity (current_value 1) !tsTimeFeature)
							)

							(declare (assoc
								end_time (+ case_time_value forecast_window_length)
							))

							(declare (assoc
								forecast_result
									(call !ReactSeries (assoc
										continue_series .true
										leave_series_out .true
										desired_conviction (null)
										details (assoc categorical_action_probabilities .true)
										generate_new_cases "no"
										max_series_length (null)
										series_stop_map (associate !tsTimeFeature {"max" end_time} )
										series_id_features series_id_features
										series_id_values series_id_values
										include_start_time_case .true
										output_new_series_ids .false

										output_features all_features
										action_features series_action_features
										derived_context_features derived_context_features
										derived_action_features derived_action_features

										initial_features [!tsTimeFeature]
										initial_values
											(if (contains_index !featureDateTimeMap !tsTimeFeature)
												[(format
													case_time_value
													"number"
													(get !featureDateTimeMap (list !tsTimeFeature "date_time_format"))
													(null)
													{
														"locale" (get !featureDateTimeMap [ !tsTimeFeature "locale" ] )
														"time_zone" (get !featureDateTimeMap [ !tsTimeFeature "default_time_zone" ] )
													}
												)]

												[case_time_value]
											)
									))
								trained_series_cases
									(values (map
										(lambda (unzip (current_value) all_features))
										(compute_on_contained_entities
											(map
												(lambda (query_equals (get series_id_features (current_index)) (current_value)))
												series_id_values
											)
											(query_greater_or_equal_to !tsTimeFeature case_time_value)
											(map (lambda (query_exists (current_value))) all_features)
										)
									))
							))
							;convert the forecast cases back to encoded values to compare to trained cases
							(declare (assoc
								forecast_cases
									(map
										(lambda
											(call !ConvertFromInput (assoc
												features all_features
												feature_values (current_value 1)
											))
										)
										(get forecast_result ["payload" "action_values"])
									)
							))
							(declare (assoc
								forecast_time_values
									(map
										(lambda (get (current_value) (get feature_index_map !tsTimeFeature)) )
										forecast_cases
									)
							))

							(assign (assoc
								trained_series_cases
									(sort
										(lambda (>
											(get (current_value) (get feature_index_map !tsTimeFeature))
											(get (current_value 1) (get feature_index_map !tsTimeFeature))
										))
										trained_series_cases
									)
							))
							;Deliberately pull out the time column as it will be needed for each feature
							(declare (assoc
								trained_time_values
									(map
										(lambda (get (current_value) (get feature_index_map !tsTimeFeature)) )
										trained_series_cases
									)
							))

							(map
								(lambda
									;for each feature, interpolate both the forecast and trained series at the end time
									;and compute the tuple needed for downstream calculations
									(let
										(assoc
											feat_to_diff (current_value 1)
											feat_index (get feature_index_map (current_value 1))
										)

										(if (= "continuous" (get !featureAttributes [feat_to_diff "type"]))
											(call !ComputeDiffTuple (assoc
												interpolated_value
													;interpolated value for forecast
													(call !InterpolateSeriesValuesContinuous (assoc
														time_values forecast_time_values
														feature_values
															(map
																(lambda (get (current_value) feat_index))
																forecast_cases
															)
														time end_time

														;hopefully don't need these
														pre_domain_value (get forecast_cases [0 feat_index])
														post_domain_value (get forecast_cases [-1 feat_index])
													))
												case_feature_value
													;interpolated value for trained data
													(call !InterpolateSeriesValuesContinuous (assoc
														time_values trained_time_values
														feature_values
															(map
																(lambda (get (current_value) feat_index))
																trained_series_cases
															)
														time end_time

														;these definitely should not be needed
														pre_domain_value (null)
														post_domain_value (null)
													))

											))

											(= "nominal" (get !featureAttributes [feat_to_diff "type"]))
											(call !ComputeDiffTuple (assoc
												feature_is_nominal .true
												feature feat_to_diff
												interpolated_value
													;interpolated value for forecast
													(call !InterpolateSeriesValuesNominal (assoc
														time_values forecast_time_values
														feature_values
															(map
																(lambda (get (current_value) feat_index))
																forecast_cases
															)
														time end_time

														;hopefully don't need these
														pre_domain_value (get forecast_cases [0 feat_index])
														post_domain_value (get forecast_cases [-1 feat_index])
													))
												case_feature_value
													;interpolated value for trained data
													(call !InterpolateSeriesValuesNominal (assoc
														time_values trained_time_values
														feature_values
															(map
																(lambda (get (current_value) feat_index))
																trained_series_cases
															)
														time end_time

														;these definitely should not be needed
														pre_domain_value (null)
														post_domain_value (null)
													))
												candidate_cases_lists [[1]]
												categorical_action_probabilities_map
													(associate
														feat_to_diff
															(call !InterpolateSeriesCAPs (assoc
																time_values forecast_time_values
																caps_values
																	(map
																		(lambda (get (current_value) feat_to_diff))
																		(get forecast_result ["payload" "categorical_action_probabilities"])
																	)
																time end_time

																pre_domain_value (get forecast_result ["payload" "categorical_action_probabilities" 0 feat_to_diff])
																post_domain_value (get forecast_result ["payload" "categorical_action_probabilities" -1 feat_to_diffs])
															))
													)
											))

											;otherwise null, not supported for edit-distance/other types
											(null)
										)

									)
								)
								features
							)
						)
					)
					case_ids
				)
		))

		(assign (assoc
			feature_residuals_lists (call !TransposeResidualLists)
		))
	)

)
