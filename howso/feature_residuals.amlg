;Contains methods for computing and storing feature residuals.
(null

	;Updates the given hyperparam_map and returns it with updated parameters based on computed residuals
	;parameters:
	; see #!CalculateFeatureResiduals
	#!CalculateResidualsAndUpdateParameters
	(declare
		(assoc
			features (null)
			context_features (null)
			case_ids (null)
			focal_case (null)
			num_samples (null)
			robust_residuals (false)
			hyperparameter_feature (null)
			use_case_weights (null)
			weight_feature ".case_weight"
			custom_hyperparam_map (null)
			confusion_matrix_min_count 15
			feature_with_nulls (null)
			compute_null_uncertainties (true)
			compute_all_statistics (true)
			use_shared_deviations (false)
		)

		(if (= (null) context_features)
			(assign (assoc context_features !trainedFeatures))
		)

		;if features aren't specified, use the set of context_features
		(if (= (null) features)
			(assign (assoc features context_features))
		)
		;if not using case weights, change weight_feature to '.none'
		(if (= (false) use_case_weights)
			(assign (assoc weight_feature ".none"))
		)

		;set the passed in one as the hyperparam map to use if specified
		(declare (assoc
			hyperparam_map
				(if (= (null) custom_hyperparam_map)
					(call !GetHyperparameters (assoc
						feature hyperparameter_feature
						context_features context_features
						weight_feature weight_feature
					))

					custom_hyperparam_map
				)
		))
		(call !UpdateCaseWeightParameters (assoc set_valid_weight_feature (false) ))
		(declare (assoc
			param_path
				;if the param_path is missing, create it here
				(if (= (null) (get hyperparam_map "paramPath"))
					(append
						(if hyperparameter_feature ["targeted" hyperparameter_feature] ["targetless"])
						(call !BuildContextFeaturesKey (assoc context_features features))
						weight_feature
					)

					(get hyperparam_map "paramPath")
				)
		))


		;if there are ordinals but the hyperparameter map doesn't have a featureOrdinalDeviations assoc, initialize it
		(if (and
				(size ordinal_features_map)
				(= (null) (get hyperparam_map "featureOrdinalDeviations"))
			)
			(accum (assoc hyperparam_map (assoc "featureOrdinalDeviations" (assoc))))
		)

		;if storing deviations ensure that featureDeviations is an assoc instead of (null) for correct accumulation
		(if (= (null) (get hyperparam_map "featureDeviations" ))
			(assign (assoc hyperparam_map (set hyperparam_map "featureDeviations" (assoc))))
		)

		(declare (assoc
			output_map
				(call !CalculateFeatureResiduals (assoc
					features features
					context_features context_features
					case_ids case_ids
					focal_case focal_case
					num_samples num_samples
					robust_residuals robust_residuals
					hyperparameter_feature hyperparameter_feature
					use_case_weights use_case_weights
					weight_feature weight_feature
					custom_hyperparam_map hyperparam_map
					compute_all_statistics compute_all_statistics
					confusion_matrix_min_count confusion_matrix_min_count
					compute_null_uncertainties compute_null_uncertainties
					use_shared_deviations use_shared_deviations
				))
		))

		(assign (assoc hyperparam_map (get output_map "hyperparam_map") ))

		;update hyperparam_map with null uncertainties if present
		(if (size (get output_map "nullUncertainties"))
			(let
				(assoc null_uncertainties_map (get output_map "null_uncertainty_map") )
				(assign
					"hyperparam_map"
					(list "nullUncertainties")
					(map
						(lambda
							;append (null)s in front to match the deviations shape
							(append (null) (current_value))
						)
						null_uncertainties_map
					)
				)

				(assign
					"hyperparam_map"
					(list "featureDeviations")
					(map
						(lambda
							;update deviation value with null uncertainies
							(if (contains_index null_uncertainties_map (current_index))
								(if (~ (list) (current_value))
									;if the deviation is a number, wrap it in a triple
									(if (or (~ 0 (first (current_value))) (= (null) (first (current_value))) )
										(append (first (current_value)) (get null_uncertainties_map (current_index)) )

										;else the deviation must be a SDM, wrap it in a list so that the output is a triple
										;in the format of [sdm, null-value, null-null] instead of appending null uncertaintes to the SDM
										(append
											(list (first (current_value 1)))
											(get null_uncertainties_map (current_index))
										)
									)
									(append (list (current_value 1)) (get null_uncertainties_map (current_index)) )
								)

								;leave deviation value as-is
								(current_value)
							)
						)
						(if (size (get hyperparam_map "featureDeviations"))
							(get hyperparam_map "featureDeviations")
							(zip (indices null_uncertainties_map))
						)
					)
				)
			)
		)

		(assign
			"hyperparam_map"
			(list "featureOrdinalDeviations")
			(get output_map "ordinal_residuals_map")
		)

		;return the output map with capped residual values
		(assign (assoc
			output_map
				(call !ExpandResidualValuesToUncertainty  (assoc
					feature_residuals_map output_map
					using_shared_deviations use_shared_deviations
				))
		))
		(assign
			"hyperparam_map"
			["featureResiduals"]
			(map
				(lambda
					(if (~ 0 (current_value))
						(current_value)

						;must be a nominal
						(~ (assoc) (current_value))
						(get (current_value) "expected_deviation")

						;else fall back to null, this should never happen
						(null)
					)
				)
				(get output_map "residual_map")
			)
		)

		hyperparam_map
	)

	;calculate feature residual values, i.e. the mae (mean absolute error of predictions on a sample of the model) for each of the specified features
	;returns an assoc containing feature residuals, feature ordinal residuals and the hyperparam_map used for computations
	;
	;parameters:
	; features: optional list of all features to compute residuals for. If not specified will use !trainedFeatures.
	; context_features: list of features to be used as the context. If not specified, will use the value of features.
	; target_residual_feature: optional feature for which to calculate the (MAE) residual. If not specified, will compute for all features.
	; case_ids: optional list of case ids to compute residuals for the action set, will ignore 'action_condition_filter_query' and 'num_samples' if specified
	; num_samples: optional, limit on the number of cases for the action set to use in calculating conditional residuals.
	; context_condition_filter_query: optional list of filtering queries for the context set.
	; strict_case_ids: flag, default to false. If true, then any augmentations to case ids is prohibited (selecting additional non-null cases, more null cases, etc.)
	; focal_case: optional case id of case for which to compute residuals for  is to be ignored during computation
	; regional_model_only: flag, default to false. when set to true will only explicitly use the specified case_ids for computation.
	; robust_residuals: string, default to (null). when "deviations" calculates accurate local residuals, otherwise computes residuals robust with respect to the set of contexts used
	;		(across the power set of contexts).  when "robust_mda" will additionally compute and output MDA using robust residuals.
	; hyperparameter_feature: optional  default (null).  feature whose hyperparameters to use
	; use_case_weights: flag, if set to true will scale influence weights by each case's weight_feature weight. If unspecified,
	;   			case weights will be used if the trainee has them.
	; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
	; custom_hyperparam_map: optional, hyperparameters to use for residuals computation
	; compute_all_statistics: flag, optional. if set to true will compute other statistics (precision, recall, r^2, rmse, etc.) in addition to MAE
	; confusion_matrix_min_count: number, optional, default is 10. Applicable only to confusion matrices, the number of predictions a class should have
	;		(value of a cell in the matrix) for it to remain in the confusion matrix. If the count is less than this value, it will be accumulated
	;		into a single value of all insignificant predictions for the class and removed from the confusion matrix.
	; use_shared_deviations: flag, optional, default false. If set to true, will return the residuals grouped by shared deviations group, otherwise will return the residuals
	;		calculated on a per feature basis.
	; expand_confusion_matrices: flag, optional, default true. When use_shared_deviations is true, if there are confusion matrices for shared features, they will be copied over
	;		for all non-primary shared features. When false, confusion matrices will not be copied and remain only for the primary features.
	#!CalculateFeatureResiduals
	(declare
		(assoc
			;the features to compute residuals for
			features (null)
			;the features to be used as context
			context_features (null)
			target_residual_feature (null)
			regional_model_only (false)
			focal_case (null)
			robust_residuals (null)
			strict_case_ids (false)

			;ordered by priority for the action set, with the 'case_ids' parameters having the top priority.
			case_ids (list)
			context_condition_filter_query (list)
 			num_samples (null)

			hyperparameter_feature (null)
			use_case_weights (null)
			weight_feature ".case_weight"
			custom_hyperparam_map (null)
			compute_all_statistics (false)
			compute_null_uncertainties (true)
			confusion_matrix_min_count 15
			use_shared_deviations (false)
			expand_confusion_matrices (true)
		)

		(declare (assoc
			k_parameter (null)
			p_parameter (null)
			dt_parameter (null)
			query_feature_attributes_map (null)
			case_features (null)
			ordinal_features_map (zip !ordinalFeatures)
			hyperparam_map (assoc)
			residuals_map (assoc)
			ordinal_residuals_map (assoc)
			;assoc of features to skip computing non-robust residuals for if they don't have enough non-null values
			skip_features_map (assoc)
			;list, length of case_ids, each item will be a list of residual values, one per feature
			case_residuals_lists (list)
			;list, length of features, each item will be a list of residuals, one per case
			feature_residuals_lists (list)

			num_training_cases (call !GetNumTrainingCases)
			valid_weight_feature (false)

			rmse_map (assoc)
			r2_map (assoc)
			spearman_coeff_map (assoc)
			accuracy_map (assoc)
			precision_map (assoc)
			recall_map (assoc)
			adjusted_smape_map (assoc)
			smape_map (assoc)
			mcc_map (assoc)
			confusion_matrix_map (assoc)
			nominal_performance_map (assoc)

			null_uncertainties_map (assoc)
			null_accuracies_map (assoc)
			;list of unique features to populate output at the end
			unique_features_for_populating_output (null)

			;store an assoc of lag/rate/delta feature -> lag/order amount for time series flows
			ts_feature_lag_amount_map (null)
			max_lag_index_value (null)
			feature_mda_map (null)
			original_features (replace features)
		))

		(call !InitResiduals)

		(if (= "deviations" robust_residuals)
			(call !ComputeDeviations)

			robust_residuals
			(call !RunRobustResiduals)

			;else
			(call !RunFullResiduals)
		)

		(if use_shared_deviations
			(if (size !sharedDeviationsMap)
				(seq
					(assign (assoc feature_residuals_lists (call !PrepSharedDeviations) ))
					(assign (assoc
						features (filter (lambda (not (contains_value !sharedDeviationsNonPrimaryFeatures (current_value)))) features)
					))
				)

				;else there are no set shared residuals, ignore shared deviations
				(assign (assoc use_shared_deviations (false)))
			)
		)

		;if shared deviations, the prediction_stats returned will a fully expanded assoc of prediction stats,
		; however the features list and feature_residuals_lists will be shortened to only features that do not belong
		; to a shared deviations group, or are the primary key for a group of shared deviations.
		(declare (assoc
			prediction_stats
				(if compute_all_statistics
					(call !PrepAllStatisticsResidualOutput)

					(call !PrepResidualOutput)
				))
		)

		(if compute_null_uncertainties
			(let
				(assoc
					features_with_nulls
						(indices (filter
							;keep only features that have at least 2 nulls
							(lambda
								(>=
									(size (contained_entities
										(append
											(query_exists (current_index))
											(query_equals (current_index) (null))
										)
									))
									2
								)
							)
							(filter
								;only query features that have nulls
								(lambda (get (current_value) "has_nulls"))
								;ignore all inactive features (where all values are nulls)
								(keep
									(remove !featureNullRatiosMap (indices !inactiveFeaturesMap))
									;if shared deviations, the features list needs to be expanded to include features that were dropped for shared deviations calculations
									(if use_shared_deviations
										(call !ExpandForSharedDeviations (assoc compressed_values features))
										features
									)
								)
							)
						))
					;store an assoc of lag/rate/delta feature -> lag/order amount for time series flows
					ts_feature_lag_amount_map
						(if !tsTimeFeature
							(map
								(lambda (or
									;store value of 'max_row_lag' for lag features and 'ts_order' for delta or rate features
									(get (current_value) "max_row_lag")
									(get (current_value) "ts_order")
								))
								;only lag, delta and rate features have a ts_type defined
								(filter
									(lambda (get (current_value) "ts_type") )
									!featureAttributes
								)
							)
						)
				)

				;compute null deviations and update hyperparam_map with them
				(if (size features_with_nulls)
					(call !ComputeNullUncertainties (assoc
						features_with_nulls features_with_nulls
						context_features context_features
						null_cases_map
							(map
								(if (or
										regional_model_only
										(< (size case_ids) 200)
									)
									;if regional model only or small dataset/sample, just filter which of the case ids have nulls for each feature
									(lambda
										(filter
											(lambda (= (null) (retrieve_from_entity (current_value) (current_index 1))))
											case_ids
										)
									)

									;otherwise sample null feature value cases from the model using queries
									(lambda
										(contained_entities (append
											(query_exists (current_index))
											(query_equals (current_index) (null))

											;time series derived features only consider cases outside the null triangle at the start of a series
											;e.g., a lag of 2 feature, will only consider nulls from cases with index >= 2
											(if (and !tsTimeFeature (contains_index ts_feature_lag_amount_map (current_index)))
												(query_greater_or_equal_to ".series_index" (get ts_feature_lag_amount_map (current_index)) )

												;else don't append anything
												[]
											)

											(query_sample 200)
										))
									)
								)
								(zip features_with_nulls)
							)
					))
				)
			)
		)

		;unique features have a residual of (null)
		(if unique_features_for_populating_output
			(accum (assoc
				residuals_map (zip unique_features_for_populating_output)
			))
		)

		;compute mda if necessary
		(if (and (= "robust_mda" robust_residuals) (= (null) target_residual_feature))
			(assign (assoc
				feature_mda_map
					(call !ComputeRobustTargetlessMDA (assoc
						features original_features
						case_residuals_lists case_residuals_lists
					))
			))
		)

		;for shared deviations, only one set of deviations are calculated for each group. At the end of the calculations,
		; the deviations mapping is expanded to add back the other features whose deviations were not calculated and point them at the feature
		; in which their shared deviations are stored under.
		(if use_shared_deviations
			(map
				(lambda (let
					(assoc
						current_map_name (current_index 1)
						current_map_value (current_value 1)
					)
					(assign (associate
						current_map_name
							(call !ExpandForSharedDeviations (assoc compressed_values current_map_value))
					))
				))
				(assoc
					"ordinal_residuals_map" ordinal_residuals_map
					"residuals_map" residuals_map
					"null_uncertainties_map" null_uncertainties_map
				)
			)
		)

		(assoc
			"residual_map" residuals_map
			"ordinal_residual_map" ordinal_residuals_map
			"hyperparam_map" hyperparam_map
			"prediction_stats" prediction_stats
			"null_uncertainty_map" null_uncertainties_map
			"null_accuracy_map" null_accuracies_map
			"feature_mda_map" feature_mda_map
		)
	)

	;Helper method for CalculateFeatureResiduals to compute and output all basic prediction stats from the residuals
	#!PrepAllStatisticsResidualOutput
	(let
		(assoc
			feature_indices_map (zip features (indices features))
			continuous_features (filter (lambda (not (contains_index !nominalsMap (current_value)))) features)
			continuous_indices (list)
			nominal_features (filter (lambda (contains_index !nominalsMap (current_value))) features)
			nominal_indices (list)
			numeric_continuous_features (null)
			numeric_continuous_indices (null)
		)

		;feature_residuals_lists is in the format of:
		; (list
		; 	(list react1 react2 ... react n) ; feature A reacts
		; 	(list react1 react2 ... react_n) ; feature B reacts
		; 	...
		; 	(list react1 react2 ... react n) ; feature N reacts
		; )
		;
		;where each react is a list of tuples of either:
		; [diff, actual_value, predicted] for nominals or
		; [diff, ordinal_diff, actual_value, predicted_value] for continuous (ordinal_diff is not there for non-ordinal features)

		(assign (assoc
			continuous_indices (unzip feature_indices_map continuous_features)
			nominal_indices (unzip feature_indices_map nominal_features)
			has_ordinals (> (size ordinal_features_map) 0)
			;default index offset of where the actual case value is in each output react
			actual_offset 1
			predicted_offset 2
			actual_nom_offset (if compute_all_statistics 2 1)
			predicted_nom_offset (if compute_all_statistics 3 2)
			cap_offset 1
		))

		;if some of the features are edit distance types, r2 and spearman coefficient don't apply since there's no mean or relative sorting
		;filter out those out of the lists of continuous fetaures and not compute those stats for them
		(if (size !editDistanceFeatureTypesMap)
			(seq
				(assign (assoc
					numeric_continuous_features
						(filter (lambda (not (contains_index !editDistanceFeatureTypesMap (current_value)))) continuous_features)
				))
				(assign (assoc numeric_continuous_indices (unzip feature_indices_map numeric_continuous_features) ))
			)

			(assign (assoc
				numeric_continuous_features continuous_features
				numeric_continuous_indices continuous_indices
			))
		)

		(if has_ordinals
			(assign (assoc
				;for continuous features, each react output is stored as [diff, actual_value, predicted_value]
				;but if there are ordinals, it's stored as [diff, ordinal_diff, actual_value, predicted_value]
				;if there are ardinals, the index offest for actual_value is 2 instead of 1
				actual_offset 2
				predicted_offset 3

				ordinal_residuals_map
					(filter (zip
						continuous_features
						(map
							(lambda
								(if (contains_index ordinal_features_map (get continuous_features (current_index)))
									(if (size (current_value))
										;create a list of ordinal_diffs by pulling ordinal_diff from each tuple
										(/
											(apply "+" (map (lambda (get (current_value) 1)) (current_value)) )
											;compute average by dividing by the number of values
											(size (current_value))
										)

										;else if there were no values for this feature, return global feature residual
										(get hyperparam_map (list "featureDeviations" (get continuous_features (current_index 1))))
									)
								)
							)
							(unzip feature_residuals_lists continuous_indices)
						)
					))
			))
		)

		;iterate over each continuous feature's list of reacts and compute the MAE, RMSE, R^2, and spearman coefficient
		(assign (assoc
			;MAE - mean absolute error = sum(|actual-predicted|) / num_cases
			residuals_map
				(zip
					continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							(size (current_value))
							(/
								(apply "+" (map (lambda (first (current_value))) (current_value)) )
								;compute average by dividing by the number of values
								(size (current_value))
							)

							;else if there were no values for this feature, return global feature residual
							(get hyperparam_map (list "featureDeviations" (get continuous_features (current_index 1))))
						))
						(unzip feature_residuals_lists continuous_indices)
					)
				)
			;RMSE - root mean squared error = sqrt( sum( |actual-predicted|^2 ) / num_cases )
			rmse_map
				(zip
					continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							(size (current_value))
							(sqrt (/
								(apply "+" (map (lambda (pow (first (current_value)) 2)) (current_value)) )
								;compute average by dividing by the number of values
								(size (current_value))
							))
						))
						(unzip feature_residuals_lists continuous_indices)
					)
				)
			;spearman coefficient = 1 - 6 * sum(|actual_rank-predicted_rank|^2) / (num_cases^3 - num_cases)
			;where actual_rank and predicted_rank are the 1-based sorted rank of values for each
			spearman_coeff_map
				(zip
					numeric_continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							;must have at least 2 values to compute spearman coefficient
							(> (size (current_value)) 1)
							(let
								(assoc
									actual_ranks_map
										(call !GetRankMapForValues (assoc
											values (map (lambda (get (current_value) actual_offset)) (current_value 2))
										))
									predicted_ranks_map
										(call !GetRankMapForValues (assoc
											values (map (lambda (last (current_value))) (current_value 2))
										))
								)
								(- 1
									(* 6 (/
										(apply "+"
											(map
												(lambda
													(pow
														(-
															(get actual_ranks_map (get (current_value) actual_offset))
															(get predicted_ranks_map (last (current_value)))
														)
														2
													)
												)
												(current_value)
											)
										)

										(- (pow (size (current_value)) 3) (size (current_value)))
									))
								)
							)
						))
						(unzip feature_residuals_lists numeric_continuous_indices)
					)
				)
			;R squared = 1 - sum(|actual-predicted|^2) / sum(|actual-mean|^2)
			r2_map
				(zip
					numeric_continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							;must have at least 2 values to compute r^2
							(> (size (current_value)) 1)
							(let
								(assoc
									mean_value
										;average of all actual values
										(/
											(apply "+" (map (lambda (get (current_value) actual_offset)) (current_value 1)) )
											(size (current_value 1))
										)
									sum_res_squared
										(apply "+" (map (lambda (pow (first (current_value)) 2)) (current_value 1)) )
									sum_tot_squared 0
								)

								(assign (assoc
									sum_tot_squared
										(apply "+"
											(map
												(lambda
													;(mean - actual)^2
													(pow (- mean_value (get (current_value) actual_offset)) 2)
												)
												(current_value 1)
											)
										)
								))

								;output r^2 value:  1 - SSres / SStot
								;cap the smallest allowed r2 value to the float min value of -3.4028234663852886e+38
								(max
									(- 1 (/ sum_res_squared sum_tot_squared))
									-340282346638528859811704183484516925440
								)
							)
						))
						(unzip feature_residuals_lists numeric_continuous_indices)
					)
				)
			;smape = |predicted - actual| / ((|actual| + |predicted|) / 2) * 100
			smape_map
				(zip
					numeric_continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda
							(if (size (current_value))
								(*
									(/
										;sum of the absolute percent errors
										(apply "+"
											(map
												(lambda
													(let
														(assoc
															smape_numerator
																(abs (-
																	(get (current_value 1) predicted_offset)
																	(get (current_value 1) actual_offset)
																))
															smape_denominator
																(/
																	(+
																		(abs (get (current_value 1) actual_offset))
																		(abs (get (current_value 1) predicted_offset))
																	)
																	2
																)
														)
														(if (= smape_denominator 0)
															;if the denominator is 0, that means actual and predictd are both 0
															; which should have a error of 0
															0
															(/ smape_numerator smape_denominator)
														)
													)
												)
												(current_value)
											)
										)
										(size (current_value))
									)
									100
								)
							)
						)
						(unzip feature_residuals_lists numeric_continuous_indices)
					)
				)
			;adjusted_smape = |predicted - actual| / ((|actual| + |predicted|) / 2) * 100 where min gap / 2 is added to both the actual and predicted values.
			adjusted_smape_map
				(zip
					numeric_continuous_features
					;iterate over continuous features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda
							(if (size (current_value))
								(let
									(assoc
										half_min_gap
											(get !cachedFeatureHalfMinGapMap (get numeric_continuous_features (current_index 1)))
									)
									(*
										(/
											;sum of the absolute percent errors
											(apply "+"
												(map
													(lambda
														(let
															(assoc
																adjusted_smape_numerator
																	(abs (-
																		(+ (get (current_value 1) predicted_offset) half_min_gap)
																		(+ (get (current_value 1) actual_offset) half_min_gap)
																	))
																adjusted_smape_denominator
																	(/
																		(+
																			(+ (abs (get (current_value 1) actual_offset)) half_min_gap)
																			(+ (abs (get (current_value 1) predicted_offset)) half_min_gap)
																		)
																		2
																	)
															)
															(if (= adjusted_smape_denominator 0)
																;if the denominator is 0, that means actual and predictd are both 0
																; which should have a error of 0
																0
																(/ adjusted_smape_numerator adjusted_smape_denominator)
															)
														)
													)
													(current_value)
												)
											)
											(size (current_value))
										)
										100
									)
								)
							)
						)
						(unzip feature_residuals_lists numeric_continuous_indices)
					)
				)
		))

		(accum (assoc
			residuals_map
				(zip
					nominal_features
					;iterate over nominal features, where (current_value) is a list of react tuples for each feature
					(map
						(lambda (if
							(size (current_value))
							(/
								(apply "+" (map (lambda (first (current_value))) (current_value)) )
								;compute average by dividing by the number of values
								(size (current_value))
							)

							;else if there were no values for this feature, return global feature residual
							(replace (get hyperparam_map (list "featureDeviations" (replace (get nominal_features (current_index 1))))))
						))
						(unzip feature_residuals_lists nominal_indices)
					)
				)
		))

		(assign (assoc
			confusion_matrix_map
				;analyze uses confusion matrix to compute SDM, use Categorical Action Probabilities for higher fidelity of nominal residuals
				(if in_analyze
					(zip
						nominal_features
						(map
							(lambda
								(zip
									(lambda
										(map
											(lambda
												(apply "+" (filter (current_value)))
											)
											(current_value 1)
											(current_value)
										)
									)
									(map (lambda (get (current_value) actual_nom_offset) ) (current_value))
									(map (lambda (get (current_value) cap_offset) ) (current_value))
								)
							)
							(unzip feature_residuals_lists nominal_indices)
						)
					)

					;else compute confusion matrix using counts of correct guesses for each class
					(zip
						nominal_features
						;iterate over nominal features, where (current_value) is a list of react tuples for each feature
						(map
							(lambda
								(map
									(lambda
										(zip
											;all collisions will increase the count value
											;e.g. zipping ["small" "medium" "small"] will create { small 1 medium 1 } then accumulate a 1
											;for the second "small" in the list since it's a key collision, resulting in { small 2 medium 1 }
											(lambda (+ 1 (current_value 1)) )
											;ensure to zip a list of classes instead of single value by converting it to a list if it isn't a list already
											(if (~ [] (current_value))
												(current_value)
												[(current_value 1)]
											)
											;zip all classes with a value of 1 so that all clases in the predicted list are assigned a value of 1
											(range
												(lambda 1)
												1
												;if there is only one entry for a value, then it's predicted values: (current_value)
												;will be singular (not a list, size=0), so we bound the list of 1's to be at least size=1
												(max 1 (size (current_value)))
												1
											)
										)
									)
									;keep only those class values that had non-null counts
									(filter
										(lambda (size (current_value)))
										;nominal prediction tuples are in the format of [diff, actual, predicted]
										;thus this iterates over the two corresponding lists of [actual] and [predicted] values
										;accruing into an assoc of lists of predicted classes for every provided actual class, e.g.,
										;given actual ["a" "a" "x" "x" "x"] and predicted ["a" "a" "x" "a" "x"] results in:
										; {
										;	"a" [ "a" a" ]
										;	"x" [ "x "a" "x"]
										; }
										(map
											;filter out the nulls out of the list of predicted values
											(lambda (filter (replace (current_value))))
											(zip
												;iterate over pairs of (actual value, predicted value), this lambda is run when there is a
												;key collision (actual value). In that case append the new predicted value to get an assoc of
												; actual values to the list of values they are predicted as
												(lambda
													(append (replace (current_value 1)) (list (replace (current_value 1))))
												)
												;(get (current_value) 1) refers to the actual case value in each react tuple
												(map (lambda (replace (get (current_value) actual_nom_offset))) (current_value))
												;and (get (current_value) 2) refers to the interpolated/predicted case value in
												;each react tuple
												(map (lambda (replace (get (current_value) predicted_nom_offset))) (current_value))
											)
										)
									)
								)
							)
							(unzip feature_residuals_lists nominal_indices)
						)
					)
				)
		))

		;accuracy is: num correct predictions / all predictions
		(assign (assoc
			accuracy_map
				(map
					(lambda
						(let
							;grab the current action feature's confusion matrix
							(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
							(if (size confusion_matrix)
								(/
									;correct predictions count
									(apply "+" (values
										;get correct prediction count for each class
										(map
											(lambda (or (get (current_value) (current_index))))
											confusion_matrix
										)
									))
									;total predictions count
									(apply "+" (values
										;add up all prediction counts for all classes
										(map (lambda (apply "+" (filter (values (current_value))))) confusion_matrix)
									))
								)
							)
						)
					)
					(zip nominal_features)
				)
		))

		;recall for a single class is = TruePositives / (TruePositives + FalseNegatives)
		(assign (assoc
			recall_map
				(map
					(lambda
						(let
							;grab the current action feature's confusion matrix
							(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
							(if (size confusion_matrix)
								;for each row in confusion matrix, average out: correct / total of row
								(/
									(apply "+"
										(values (map
											(lambda (let
												(assoc row_total (apply "+" (values (current_value 1))) )
												;if there were no  predictions at all for this class, prevent divide by zero
												(if (> row_total 0)
													(/ (or (get (current_value) (current_index)) 0) row_total)
													0
												)
											))
											confusion_matrix
										))
									)
									;The 'confusion_matrix' may not be a square matrix. Divides by the length of the rows or columns
									; as if the matrix was square by taking the max of the number of non-empty rows or the number
									; of uniquely predicted column indices.
									(max
										;Number of rows, filter out empty rows
										(size
											(filter (lambda (size (current_value))) confusion_matrix)
										)
										;Number of unique columns
										(size (values
											(apply "append"
												(map
													(lambda (indices (current_value)))
													(values confusion_matrix)
												)
											)
											(true)
										))
									)
								)
							)
					))
					(zip nominal_features)
				)
		))

		;precision for a single class is = TruePositives / (TruePositives + FalsePositives)
		(assign (assoc
			precision_map
				(map
					(lambda
						(let
							;grab the current action feature's confusion matrix
							(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
							(if (size confusion_matrix)
								;for each column in confusion matrix, average out: correct / total of column
								(/
									;correct predictions count
									(apply "+"
										(values (map
											(lambda (let
												(assoc
													class (current_index 1)
													column_total (null)
												)
												(assign (assoc
													column_total
														(apply "+"
															(values (map
																(lambda (or (get (current_value) class) 0) )
																confusion_matrix
															))
														)
												))
												;if there were no guesses for this class at all, prevent divide by zero
												(if (> column_total 0)
													(/ (or (get (current_value) class) 0) column_total)
													0
												)
											))
											confusion_matrix
										))
									)
									;The 'confusion_matrix' may not be a square matrix. Divides by the length of the rows or columns
									; as if the matrix was square by taking the max of the number of non-empty rows or the number
									; of uniquely predicted column indices.
									(max
										;Number of rows, filter out empty rows
										(size
											(filter (lambda (size (current_value))) confusion_matrix)
										)
										;Number of unique columns
										(size (values
											(apply "append"
												(map
													(lambda (indices (current_value)))
													(values confusion_matrix)
												)
											)
											(true)
										))
									)
								)
							)
						)
					)
					(zip nominal_features)
				)
		))

		; Generalized multi-class formula for Matthews Correlation Coefficient (mcc) is located https://en.wikipedia.org/wiki/Phi_coefficient#Multiclass_case
		(assign (assoc
			mcc_map
				(map
					(lambda
						(let
							;grab the current action feature's confusion matrix
							(assoc confusion_matrix (get confusion_matrix_map (current_index 1)))
							(if (size confusion_matrix)
								(let
									(assoc
										;get the total correctly predicted counts, variable c in the mcc formula
										total_predicted_correct
											(apply "+" (values
												(map (lambda (or (get (current_value) (current_index))) ) confusion_matrix)
											))
										;get the total number of samples, variable s in the mcc formula
										total_samples
											(apply "+" (values
												(map (lambda (apply "+" (filter (values (current_value))))) confusion_matrix)
											))
										;get a list containing the true counts of each class, vector t in the mcc formula
										true_counts
											(append (values
												(map
													(lambda (apply "+" (filter (values (get confusion_matrix (current_index))))))
													confusion_matrix
												)
											))
										;get a list containing the predicted counts of each class, vector p in the mcc formula
										predicted_counts
											(append (values
												(map
													(lambda
														(apply "+" (values (map
															;current_index 1 is the predicted class that is being aggregated
															(lambda (or (get (current_value) (current_index 1))) 0)
															confusion_matrix
														)))
													)
													confusion_matrix
												)
											))
									)

									;calculates the mcc
									(declare (assoc
										mcc_numerator
											(- (* total_predicted_correct total_samples) (dot_product true_counts predicted_counts))
										mcc_denominator
											(*
												(sqrt (- (pow total_samples 2) (dot_product true_counts true_counts)))
												(sqrt (- (pow total_samples 2) (dot_product predicted_counts predicted_counts)))
											)
									))

									(if (or (= mcc_numerator 0) (= mcc_denominator 0))
										0
										(/ mcc_numerator mcc_denominator)
									)
								)
							)
						)
					)
					(zip nominal_features)
				)
		))

		(if (= (null) param_path)
			(declare (assoc param_path (get hyperparam_map "paramPath")))
		)

		;wrap each confusion matrix in an assoc
		(assign (assoc
			confusion_matrix_map
				;sparsify matrix if confusion_matrix_min_count is specified and there is a confusion matrix to sparsify
				(if (and
						(size confusion_matrix_map)
						(> confusion_matrix_min_count 0)
					)
					(call !SparsifyConfusionMatrices (assoc
						confusion_matrix_min_count confusion_matrix_min_count
						confusion_matrix_map confusion_matrix_map
					))

					(map
						(lambda (assoc
							"matrix" (current_value 1)
							"leftover_correct" 0
							"leftover_incorrect" 0
							"other_counts" 0
						))
						confusion_matrix_map
					)
				)
		))


		;copy over all the stats for non-primary shared features
		(if use_shared_deviations
			(map
				(lambda (let
					(assoc
						current_map_name (current_index 1)
						current_map_value (current_value 1)
					)
					;only expand shared devitaions that are not confusion_matrix_map
					;if expand_confusion_matrices flag is true, will also expand confusion_matrix_map
					(if (or
							(!= "confusion_matrix_map" current_map_name)
							expand_confusion_matrices
						)
						(assign (associate
							current_map_name
								(call !ExpandForSharedDeviations (assoc compressed_values current_map_value))
						))
					)
				))
				(assoc
					"accuracy_map" accuracy_map
					"precision_map" precision_map
					"recall_map" recall_map
					"mcc_map" mcc_map
					"r2_map" r2_map
					"rmse_map" rmse_map
					"spearman_coeff_map" spearman_coeff_map
					"confusion_matrix_map" confusion_matrix_map
				)
			)
		)

		;null out stats for unique features that don't apply
		(if (size unique_features_for_populating_output)
			(let
				(assoc
					unique_feature_map (zip unique_features_for_populating_output)
				)
				(accum (assoc
					accuracy_map unique_feature_map
					precision_map unique_feature_map
					recall_map unique_feature_map
					mcc_map unique_feature_map
				))
			)
		)

		(assoc
			".robust" (and robust_residuals (!= "deviations" robust_residuals))
			".hyperparam_path"
				(if (and use_case_weights (= param_path (list ".default")) )
					;intentionally storing which case weight feature is used for retrieval
					(list ".default" (null) (null) weight_feature)

					param_path
				)
			"accuracy" accuracy_map
			"precision" precision_map
			"recall" recall_map
			"mcc" mcc_map
			"r2" r2_map
			"rmse" rmse_map
			"smape" smape_map
			"adjusted_smape" adjusted_smape_map
			"spearman_coeff" spearman_coeff_map
			"confusion_matrix" confusion_matrix_map
		)
	)

	;helper method for CalculateFeatureResiduals to average out the list(s) of residual values into individual value(s)
	;and prepare output payloads
	#!PrepResidualOutput
	(seq
		;feature_residuals_lists is in the format of:
		; (list
		; 	(list react1 react2 ... react n) ; feature A reacts
		; 	(list react1 react2 ... react_n) ; feature B reacts
		; 	...
		; 	(list react1 react2 ... react n) ; feature N reacts
		; )
		;
		;where each react is either:
		; the diff value, for nominals and continuous, or a list of [diff, ordinal_diff] for continuous ordinal features

		;for each feature, collapse each list of residuals into a single value by averaging them out
		;for ordinals we need to split out the ordinal residuals from the rest
		(if (size ordinal_features_map)
			(seq
				(assign (assoc
					residuals_map
						(zip
							features
							(map
								(lambda (if
									(size (current_value))
									;feature_residuals_lists is of length of features, and corresponds 1-1 to features
									;thus 'feature' is (get features (current_index))
									(if (contains_index ordinal_features_map (get features (current_index)))
										;ordinal feature, (current_value) is a list of tuples [diff, ordinal_diff]
										;create a list of diffs by pulling diff from each tuple
										(/
											(apply "+" (map (lambda (first (current_value))) (current_value)) )
											;compute average by dividing by the number of values
											(size (current_value))
										)

										;else simply compute avg of all diffs
										(/
											(apply "+" (current_value))
											;compute average by dividing by the number of values
											(size (current_value))
										)
									)

									;else if there were no values for this feature, return global feature residual
									(get hyperparam_map (list "featureDeviations" (get features (current_index 1))))
								))
								feature_residuals_lists
							)
						)
					ordinal_residuals_map
						(filter (zip
							features
							(map
								(lambda
									(if (contains_index ordinal_features_map (get features (current_index)))
										(if (size (current_value))
											;ordinal feature, (current_value) is a list of tuples [diff, ordinal_diff]
											;create a list of ordinal_diffs by pulling ordinal_diff from each tuple
											(/
												(apply "+" (map (lambda (last (current_value))) (current_value)) )
												;compute average by dividing by the number of values
												(size (current_value))
											)

											;else if there were no values for this feature, return global feature residual
											(get hyperparam_map (list "featureDeviations" (get features (current_index 1))))
										)
									)
								)
								feature_residuals_lists
							)
						))
				))
			)

			;else simply compute all residuals
			(assign (assoc
				residuals_map
					(zip
						features
						(map
							(lambda (if
								(size (current_value))
								;compute average by dividing by the number of values
								(/ (apply "+" (current_value)) (size (current_value)) )

								;else if there were no values for this feature, return global feature residual
								;or simply null for inactive features
								(if (contains_index !inactiveFeaturesMap (get features (current_index)))
									(null)
									(get hyperparam_map (list "featureDeviations" (get features (current_index 1))))
								)
							))
							feature_residuals_lists
						)
					)
			))
		)

		;return null prediction_stats
		(null)
	)

	;Helper method to sparsify confusion matrices by removing cells whose counts are less than the specified confusion_matrix_min_count
	;and accumulating those leftovers as their own counts.
	;outputs an assoc of feature -> assoc of
	;	matrix: sparsified confusion matrix
	;	leftover_correct: total number of correct predictions for classes that were not statistically significant
	;	leftover_incorrect: total number of incorrect predictions for classes with any correct but statistically insignificant predictions
	;	other_counts: total number of all other statistically insignificant predictions
	;
	;parameters:
	; confusion_matrix_map: assoc of feature -> confusion matrix assoc
	; confusion_matrix_min_count: smallest number of predictions for a class to leave in the confusion matrix
	#!SparsifyConfusionMatrices
	(map
		(lambda	(let
			(assoc
				confusion_matrix (current_value 1)
				leftover_confusion_matrix (assoc)
			)

			(call !ComputeLeftoverConfusionMatrix)

			;create an assoc of class -> row from leftover_confusion_matrix for any rows that had correct predictions
			(declare (assoc
				satistically_insignificant_rows_map
					(filter
						(lambda (get (current_value) (current_index)) )
						leftover_confusion_matrix
					)
			))
			(declare (assoc
				;total of all statistically insignificant correct predictions
				total_leftover_correct_predictions
					(apply "+" (values
						(map (lambda (get (current_value) (current_index))) satistically_insignificant_rows_map)
					))
				;total of all statistically insignificant incorrect predictions (total row count - correct prediction count)
				total_leftover_incorrect_predictions
					(apply "+" (values
						(map
							(lambda
								;subtract predicted count from total of all counts for the row
								(-
									(apply "+" (values (current_value)))
									(get (current_value) (current_index))
								)
							)
							satistically_insignificant_rows_map
						)
					))
			))

			(assoc
				;sparse confusion matrix
				"matrix"
					;filter out any empty rows
					(filter
						(lambda (size (current_value)))

						;filter out values below threshold count from confusion_matrix
						(map
							(lambda
								;filter out the row, keeping only those values >= confusion_matrix_min_count
								(filter
									(lambda (>= (current_value) confusion_matrix_min_count) )
									(current_value)
								)
							)
							;reduce confusion matrix to only those rows where predicted classes had significant counts
							(remove confusion_matrix (indices satistically_insignificant_rows_map))
						)
					)
				;total count of all correct predictions for classes that did not have a statistically significant amount.
				"leftover_correct" (+ (or total_leftover_correct_predictions))
				;total count of all incorrect predictions for classes that did not have a statistically significant amount.
				"leftover_incorrect" (+ (or total_leftover_incorrect_predictions))
				;total count of all other statistically insignificant predictions for classes that were predicted correctly with significance.
				"other_counts"
					(map
						(lambda (apply "+" (values (current_value))))
						;reduce leftover_confusion matrix to only those rows without predicted class counts
						(remove leftover_confusion_matrix (indices satistically_insignificant_rows_map))
					)
			)
		))
		confusion_matrix_map
	)

)
