;Contains helper methods for validating user-defined parameters
(null

	;helper method to validate specified batch react parameters are either length of num_reacts or 1
	; if the aren't, sets the variable invalid_react_parameters to (true)
	#!ValidateBatchReactParameter
	(if (and
			(> (size param) 0)
			(!= 1 (size param))
			(!= num_reacts (size param))
		)
		(assign (assoc invalid_react_parameters (true)))
	)

	#!ValidateFeatures
	(let
		(assoc
			errors
				(call !CheckForUntrainedFeatures (assoc
					context_features context_features
					action_features action_features
					action_feature action_feature
				))
		)
		(if (size errors)
			(conclude (call !Return (assoc errors errors)) )
		)
	)


	;Verifies that feature parameters do not contain untrained features
	; this method checks context_features, action_features, and action feature
	; returns a list of strings, one for each invalid parameter
	#!CheckForUntrainedFeatures
	(declare
		(assoc
			errors (list)
			context_features (list)
			action_features (list)
			action_feature (null)

			;not parameters
			valid_features (append !trainedFeatures !reactIntoFeaturesList)
			invalid_feature_set (assoc)
		)

		(if
			(size
				(remove
					(zip (append context_features action_features action_feature))
					valid_features
				)
			)
			;if there is an untrained feature in the any specified features, check each parameter
			;to give the correct error
			(seq
				(if (size context_features)
					(seq
						(assign (assoc invalid_feature_set (remove (zip context_features) valid_features) ))
						(if (size invalid_feature_set)
							(accum (assoc
								errors
									(concat
										"context_features contains features that are neither trained nor "
										"defined in the feature attributes: "
										(apply "concat" (trunc (weave (indices invalid_feature_set) ", ")))
									)
							))
						)
					)
				)

				(if (size action_features)
					(seq
						(assign (assoc invalid_feature_set (remove (zip action_features) valid_features) ))
						(if (size invalid_feature_set)
							(accum (assoc
								errors
									(concat
										"action_features contains features that are neither trained nor "
										"defined in the feature attributes: "
										(apply "concat" (trunc (weave (indices invalid_feature_set) ", ")))
									)
							))
						)
					)
				)

				(if (and (!= (null) action_feature) (!= action_feature ".targetless"))
					(if (not (contains_value valid_features action_feature))
						(accum (assoc
							errors
								(concat
									"action_feature is a feature that is neither trained nor "
									"defined in the feature attributes: "
									action_feature
								)
						))
					)
				)
			)
		)

		errors
	)

	;Validates parameter inputs for features that are in datetime format
	;verifies that the datetime format matches what is set in feature attributes
	; this method checks the following parameters:
	; - initial_values
	; - series_stop_map(s)
	; - init_time_steps
	; - final_time_steps
	;
	;parameters:
	; single_series: indicates if the method is called for a single series (from #react_series) or for multiple series (from #batch_react_series)
	#!ValidateDateTimeInputs
	(let
		(assoc
			single_series (false)

			;not parameters
			epoch_value (null)
			datetime_value (null)
			invalid_value_message (false)
		)

		(if initial_features
			(map
				(lambda
					(map
						(lambda
							(if (contains_index !featureDateTimeMap (current_index))
								(call !CheckDateTimeFormat (assoc
									datetime_feature (current_index 1)
									datetime_string (current_value 1)
									parameter_name "initial_values"
								))
							)
						)
						;zip features to each list of values
						(zip initial_features (current_value))
					)
				)
				(if single_series (list initial_values) initial_values)
			)
		)
		(if invalid_value_message
			(conclude (conclude
				(call !Return (assoc errors (list invalid_value_message) ))
			))
		)

		(if init_time_steps
			(call !CheckDateTimeFormat (assoc
				datetime_feature !tsTimeFeature
				datetime_string (first init_time_steps)
				parameter_name "init_time_steps"
			))
		)
		(if invalid_value_message
			(conclude (conclude
				(call !Return (assoc errors (list invalid_value_message) ))
			))
		)

		(if final_time_steps
			(call !CheckDateTimeFormat (assoc
				datetime_feature !tsTimeFeature
				datetime_string (first final_time_steps)
				parameter_name "final_time_steps"
			))
		)
		(if invalid_value_message
			(conclude (conclude
				(call !Return (assoc errors (list invalid_value_message) ))
			))
		)

		(map
			(lambda
				(map
					(lambda
						(if (contains_index !featureDateTimeMap (current_index))
							(map
								(lambda
									(call !CheckDateTimeFormat (assoc
										datetime_feature (current_index 2)
										datetime_string (current_value 1)
										parameter_name "series_stop_maps"
									))
								)
								;individual stop map: (assoc max __ min __)
								(current_value)
							)
						)
					)
					;each series_stop_map
					(current_value)
				)
			)
			;will iterate over nulls if they are unspecified
			(if series_stop_map (list series_stop_map) series_stop_maps)
		)
		(if invalid_value_message
			(conclude (conclude
				(call !Return (assoc errors (list invalid_value_message) ))
			))
		)
	)

	;helper method that converts a datetime string to epoch and back to datetime in an
	; attempt to verify that the value matches the date_time_format specified in the feature attributes.
	; If the value is invalid, invalid_value_found will be assigned an error message as a string
	; assumes the following parameters are available on the stack:
	; - epoch_value
	; - datetime_value
	; - invalid_value_message
	;
	;parameters:
	; datetime_feature: the name of the feature being checked
	; datetime_string: the string datetime value whose format is being verified
	; parameter_name: the name of the parameter whose value is being checked, used in the error message
	#!CheckDateTimeFormat
	(seq
		(assign (assoc
			epoch_value
				(format
					datetime_string
					(get !featureDateTimeMap (list datetime_feature "date_time_format"))
					"number"
					(assoc "locale" (get !featureDateTimeMap (list datetime_feature "locale")))
					(null)
				)
		))

		(assign (assoc
			datetime_value
				(format
					epoch_value
					"number"
					(get !featureDateTimeMap (list datetime_feature "date_time_format"))
					(null)
					(assoc "locale" (get !featureDateTimeMap (list datetime_feature "locale")))
				)
		))

		(if (!= datetime_value datetime_string)
			(assign (assoc invalid_value_message (concat "Incorrect datetime format used in " parameter_name ".") ))
		)
	)

	#!BuildParameterValidationMap
	(declare
		(assoc
			api (get (call get_api) (list 1 "payload" "labels"))
		)

		(assign_to_entities (assoc
			!parameterValidationMap
				(map
					(lambda (get (current_value) "parameters"))
					api
				)
		))
	)

	#!ValidateParameters
	(declare
		(assoc
			;this automatically determines the label/method that this method is being called within
			label_name (first (get_labels (get (opcode_stack) -8)))
		)

		(declare (assoc
			parameter_validity_map
				(map
					(lambda
						(let
							(assoc
								parameter_name (current_index 1)
								specification (current_value 1)
								exp_type (get (current_value 1) "type")
								given_value (get (args 1) (current_index 1))
								optional (or (get (current_value 1) "optional") (true)) ;assume optional if unspecified
							)

							(if (contains_index specification "ref")
								(seq
									;gotta do these in order so specification doesn't get written after exp_type
									(assign (assoc
										specification (get !CustomTypes (get specification "ref"))
									))
									(assign (assoc
										exp_type (get specification "type")
									))
								)
							)

							(if (and optional (= (null) given_value))
								(true)

								(~ exp_type (list))
								;list of possible types logic
								(apply "or"
									(map
										(lambda
											(call !SingleTypeCheck (assoc
												exp_type (current_value 1)
												given_value given_value
											))
										)
										exp_type
									)
								)

								;requires exp_type to be the string type. One of number, string, boolean, list, assoc, or any
								;also requires specification and given_value
								#!SingleTypeCheck
								(if (= exp_type "number")
									(and
										(~ 0 given_value)
										(if (contains_index specification "max")
											(<= given_value (get specification "max"))
											(true)
										)
										(if (contains_index specification "min")
											(>= given_value (get specification "min"))
											(true)
										)
									)

									(= exp_type "string")
									(if (contains_index specification "enum")
										(contains_value
											(get specification "enum")
											given_value
										)

										;else just check if string
										(~ "" given_value)
									)

									(= exp_type "boolean")
									(contains_value (list (true) (false)) given_value)

									(= exp_type "list")
									(and
										(~ (list) given_value)
										(if (and (contains_index specification "values") (size given_value))
											;each type of the list must match the type defined by values
											(apply "and"
												(map
													(lambda
														(call !SingleTypeCheck (append
															(assoc given_value (current_value 1))
															(if (~ (assoc) (get specification "values"))
																(assoc
																	specification (get specification "values")
																	exp_type (get specification (list "values" "type"))
																)

																;otherwise, "values" should just be a string
																(assoc
																	specification (assoc)
																	exp_type (get specification "values")
																)
															)
														))
													)
													given_value
												)
											)
											(true)
										)
										(if (contains_index specification "max_size")
											(<= (size given_value) (get specification "max_size"))
											(true)
										)
										(if (contains_index specification "min_size")
											(>= (size given_value) (get specification "min_size"))
											(true)
										)
									)

									(= exp_type "assoc")
									(and
										(~ (assoc) given_value)
										(if (and (contains_index specification "values") (size given_value))
											(apply "and"
												(map
													(lambda
														(call !SingleTypeCheck (append
															(assoc given_value (current_value 1))
															(if (~ (assoc) (get specification "values"))
																(assoc
																	specification (get specification "values")
																	exp_type (get specification (list "values" "type"))
																)

																;otherwise, "values" should just be a string
																(assoc
																	specification (assoc)
																	exp_type (get specification "values")
																)
															)
														))
													)
													(values given_value)
												)
											)

											;else
											(true)
										)
										(if (and (contains_index specification "indices") (size given_value))
											(apply "and"
												(values (map
													(lambda
														(if (contains_index given_value (current_index))
															(call !SingleTypeCheck (append
																(assoc given_value (get given_value (current_index 1)))
																(if (~ (assoc) (current_value))
																	(assoc
																		specification (current_value 1)
																		exp_type (get (current_value 1) "type")
																	)

																	;otherwise, "values" should just be a string
																	(assoc
																		specification (assoc)
																		exp_type (current_value 1)
																	)
																)
															))

															(true)
														)
													)
													(get specification "indices")
												))
											)

											;else
											(true)
										)
										(if (and
												(size given_value)
												(contains_index specification "indices")
												(not (contains_index specification "additional_indices"))
											)
											;if indices and no additional_indices, there should be no other indices
											(=
												0
												(size (remove given_value (indices (get specification "indices"))))
											)

											(true)
										)
										(if (contains_index specification "max_size")
											(<= (size given_value) (get specification "max_size"))
											(true)
										)
										(if (contains_index specification "min_size")
											(>= (size given_value) (get specification "min_size"))
											(true)
										)
									)

									(= exp_type "any")
									(true)
								)
							)

						)
					)
					(get !parameterValidationMap label_name)
				)
		))

		(declare (assoc
			invalid_params (filter (lambda (not (get parameter_validity_map (current_value)))) (indices parameter_validity_map))
		))

		(if (size invalid_params)
			(conclude
				(call !Return (assoc
					errors
						(list (concat
							"The following parameters contain invalid values: "
							(apply "concat" (trunc (weave invalid_params ", ")))
							"."
						))
				))
			)
		)
	)
)