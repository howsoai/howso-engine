;Contains methods for series reacting.
(null

	;React in a series until a series_stop_map condition is met. Aggregates rows of data corresponding to the specified context, action,
	;derived_context and derived_action features, utilizing previous rows to derive values as necessary. Outputs an assoc of "action_features" and
	;corresponding "series" where "series" is the completed 'matrix' for the corresponding action_features and derived_action_features.
	;{long_running (true) statistically_idempotent (true) read_only (true)}
	#single_react_series
	(declare
		(assoc
			;{type "list" values "string"}
			;list of series ID features used to uniquely select a trained series.
			;	This list should contain all ID features, but the order can vary depending on the order of the
			;	features values given in series_id_values.
			series_id_features (list)
			;{type "list" min_size 1 values "any"}
			;list of values whose order corresponds to the list of features defined in series_id_features, used to identify trained series.
			series_id_values (null)
			;{type "assoc"}
			;assoc of feature -> stop conditions:
			;	for continuous features:  { feature:  { "min" : val,  "max": val } } - stops series when feature value exceeds max or is smaller than min
			;	for nominal features:  { feature:  { "values" : ['val1', 'val2' ]} }  - stops series when feature value matches any of the values listed
			;	specifying ".series_progress" with a value between 0 and 1.0 corresponding to percent completion e.g., { ".series_progress" : .95 } -
			;		stops series when it progresses at or beyond 95%.
			series_stop_map (assoc)
			;{type "boolean"}
			;flag, default to True. If true, series ids are replaced with unique values on output.
			;	If False, will maintain or replace ids with existing trained values, but also allows output of series with duplicate existing ids.Â 
			output_new_series_ids (true)
			;{type "string" enum ["fixed" "dynamic" "no"]}
			;Controls how closely generated series should follow existing series (plural).
			;	Choices are: "fixed", "dynamic" or "no". If "fixed", tracks the particular relevant series ID. If "dynamic", tracks the particular
			;	relevant series ID, but is allowed to change the series ID that it tracks based on its current context. If "no", does not track any particular series ID.
			series_id_tracking "fixed"
			;{type "boolean"}
			;flag, default is false.  When true, react_series will do a forecast of a series.
			;	When true, either series_id_values or series_context_values must be specified.
			continue_series (false)
			;{type "list" values "string"}
			;list of feature names corresponding to values in each row of action_values
			action_features (list)
			;{type "list" values "string"}
			;list of action features whose values should be computed from the resulting last row in series, in the specified
			;	order. Must be a subset of action_features.
			;	Note: both of these derived feature lists rely on the features' "derived_feature_code" attribute to compute the values.
			;	If 'derived_feature_code' attribute is undefined or references non-existing feature indices, the derived value will be null.
			derived_action_features (list)
			;{type "list" values "string"}
			;list of context features whose values should be computed from the entire series in the specified order.
			;	Must be different than context_features.
			derived_context_features (list)
			;{type "list" values "string"}
			;list of features corresponding to series_context_values
			series_context_features (list)
			;{type "list" values {type "list" min_size 1} }
			;2d-list of values, context value for each feature for each row of the series. series_context_features must be specified if this parameter
			;is specified. If continue_series is true, then this data is forecasted. Otherwise this data conditions each row of the generated series.
			;	If specified and not using continue_series, then max_series_lengths are ignored.
			series_context_values (list)
			;{type "list" values "string"}
			;list of additional features to return with audit data from details
			extra_features (list)
			;{ref "UseCaseWeights"}
			;flag, whether to use case weights or not. If unspecified will automatically select based on cached parameters
			use_case_weights (null)
			;{type "string"}
			;name of the feature that stores case weights
			weight_feature ".case_weight"
			;{ref "DesiredConviction"}
			;If null, will do a discriminative react. If specified, will do a generative react
			;	For Generative React, value of desired avg conviction of generated cases, in the range of (0,infinity] with 1 as standard
			;	larger values will increase the variance (or creativity) of the generated case from the existing model
			;	smaller values will decrease the variance (or creativity) of the generated case from the existing model
			desired_conviction (null)
			;{type "number"}
			;maximum size a series is allowed to be.  Default is 3 * dataset_size, a 0 or less is no limit.
			;	If forecasting with 'continue_series', this defines the maximum length of the forecast.
			max_series_length (null)
			;{type "boolean"}
			;flag, if true will internally generate values for all trained features and derived features while generating a series.
			;if false, will only generate values for the features specified as action features and the features necessary to derive them, reducing
			;the expected runtime but possibly reducing accuracy.
			use_all_features (true)
			;{type "boolean"}
			;flag, if true will use differentially private approach to adding noise during generative reacts. Default is false.
			;Only used when desired_conviction is specified.
			use_differential_privacy (false)
			;{type "assoc" additional_indices {ref "FeatureBounds"}}
			;assoc of :
			;	{ feature : { "min": a, "max": b, "allow_null": false/true } }
			;	to ensure that specified features' generated values stay in bounds
			;	for nominal features instead of min/max it's a set of allowed values, ie:
			;	{ feature: { "allowed" : [ "value1", "value2" ... ] }, "allow_null": false/true }
			;	allow_null - default is true, if true nulls may be generated per their distribution in the data
			feature_bounds_map (assoc)
			;{ref "Condition"}
			;A mapping of conditions for features that will be used to constrain the queries used to find the most similar
			;trained cases to the given contexts.
			;assoc of feature->value(s).
			;	  no value or (null) = select cases where that feature is (null)/missing
			;	- for continuous or numeric ordinal features:
			;	  one value = must equal exactly the value or be close to it for fuzzy match
			;	  two values = inclusive between, supports (null) on either side for less than/greater than conditions
			;	  [(null) (null)] = select all non-null cases
			;	- for nominal or string ordinal features:
			;	  n values = must match any of these values exactly
			constraints (null)
			;{type "assoc" additional_indices {ref "GoalFeatures"}}
			; assoc of :
			;		{ feature : { "goal" : "min"/"max", "value" : value }}
			;		A mapping of feature name to the goals for the feature, which will cause the react to achieve the goals as appropriate
			;		for the context.  This is useful for conditioning responses when it is challenging or impossible to know appropriate
			;		values ahead of time, such as maximizing the reward or minimizing cost for reinforcement learning, or conditioning a
			;		forecast based on attempting to achieve some value.  Goal features will reevaluate the inference for the given context
			;		optimizing for the specified goals. Valid keys in the map are:
			;		"goal": "min" or "max", will make a prediction while minimizing or maximizing the value for the feature or
			;		"value" : value, will make a prediction while approaching the specified value
			;	note: nominal features only support 'value', 'goal' is ignored.
			;		  for non-nominals, if both are provided, only 'goal' is considered.
			goal_features_map (assoc)
			;{type "assoc" additional_indices "string"}
			;A mapping of feature name to custom code strings that will be evaluated to update the value of the feature they are mapped from after inference/derivation.
			;In the time-series synthesis, these custom codes are executed just after the original feature value is derived or synthed, but before
			;any other features would be derived or generated from the value. This means that the result of this custom code may be used as the
			;context in the generation or derivation of other feature values within a single timestep. Custom code will be able to access feature
			;values of the current time step as well as previously generated timesteps.
			feature_post_process_code_map (null)
			;{type "list" values "string"}
			;list of features that will preserve their values from the case specified by case_indices, appending and
			;	overwriting the specified context and context features as necessary.  For generative reacts, if case_indices isn't specified,
			;	will preserve feature values of a random case.
			preserve_feature_values (list)
			;{type "string"}
			;distance to determine privacy cutoff. Used to query the local minimum distance used in the distance ratio
			; 	accepted values:
			; 		'max': the maximum local distance
			; 		'min': the minimum local distance
			; 		'most_similar': the closest distance of the most similar case
			; 		null: the minimum local distance
			new_case_threshold "min"
			;{ref "NewCaseDistanceRatio"}
			;Parameter that adjusts the required distance ratio for a newly generated case to be considered private.
			;	When unspecified, defaults to 1.0 and generated cases with a ratio of 1.0 or greater are considered private.
			; 	Larger values will increase strictness of privacy check.
			; 	Smaller values will loosen the privacy check. Must be a positive number, since 0 would function same as `generate_new_cases='no'`
			new_case_distance_ratio (null)
			;{type "boolean"}
			;flag, default is true, only applicable if a substitution value map has been set. If set to false, will not substitute categorical feature values.
			substitute_output (true)
			;{type "boolean"}
			;flag, if true and series IDs are specified with series_id_values, then that series' cases will be held out of queries made within the
			;react_series call.
			leave_series_out (false)
			;{type "boolean"}
			;flag, if set to true assumes provided categorical (nominal or ordinal) feature values already been substituted.
			input_is_substituted (false)
			;{type "boolean"}
			;flag, if set to true this changes generative output to use aggregation instead of selection before adding noise.
			;By default generative output uses selection.
			use_aggregation_based_differential_privacy (false)
			;{ref "GenerateNewCases"}
			;enum, acceptable values are:
			;	null or 'no' : output any generated case
			;	'always' : only output original cases, outputs null for all feature values if unable to generate a new case
			;	'attempt' : output any generated case only if generation fails all initial attempts to output original cases
			generate_new_cases "no"
		)
		(call !ValidateParameters)
		(call !ValidateFeatures)
		(call !ValidateGoalFeaturesMap)
		(call !ValidateConstraints)

		(declare (assoc
			invalid_react_parameters (null)
			warnings (assoc)
		))

		(if series_stop_map
			(assign (assoc
				invalid_react_parameters
					(call !ValidateSeriesStopMaps (assoc
						series_stop_maps (list series_stop_map)
						feature_bounds_map feature_bounds_map
					))
			))
		)

		(if invalid_react_parameters
			(conclude
				(call !Return (assoc
					errors (list (concat "Failed to react_series: invalid stopping condition specified for " invalid_react_parameters) )
				))
			)
		)

		(let
			(assoc invalid_ts_details (indices (remove (zip requested_details) !tsSupportedDetails) ) )

			(if (size invalid_ts_details)
				(accum (assoc
					warnings
						(associate
							(concat
								"The following details are not officially supported for react series: "
								(apply "concat" (map (lambda (concat (current_value) ",") ) invalid_ts_details) )
								". Behavior is experimental."
							)
						)
				))
			)
		)

		(if (and
				(size series_id_features)
				(!=
					(zip series_id_features)
					(zip (get !tsFeaturesMap "series_id_features"))
				)
			)
			(conclude
				(call !Return (assoc
					errors
						(list (concat
							"When using series_id_features, all ID features must be specified."
						))
				))
			)
		)

		(if (and
				continue_series
				(not (xor
					(size series_id_values)
					(size series_context_values)
				))
			)
			(conclude
				(call !Return (assoc
					errors
						(list (concat
							"When using the continue_series flag, either series_id_values or series_context_values "
							"must be specified, but not both."
						))
				))
			)
		)

		(if (and
				(size series_context_values)
				(not (size series_context_features))
			)
			(conclude
				(call !Return (assoc
					errors (list "series_context_values is provided without series_context_features, please specify series_context_features.")
				))
			)
		)

		(if !hasDateTimeFeatures
			(call !ValidateDateTimeInputs (assoc single_series (true)))
		)

		(call !ValidateDerivedActionFeaturesIsSubset)


		(declare (assoc
			output_features action_features
			hyperparam_map
				(call !GetHyperparameters (assoc
					feature (null)
					context_features series_context_features
					weight_feature weight_feature
				))
		))

		(call !UpdateCaseWeightParameters (assoc set_valid_weight_feature (false) ))

		;check and update caches if necessary
		(call !PreReactCacheChecks)

		;prep time series parameters if it's a time series model
		(if !tsTimeFeature
			(call !PrepTimeSeriesFeatures (assoc
				;singular series
				n_samples 1
				single_series (true)
				series_stop_maps (if (size series_stop_map) [series_stop_map])
			))
		)

		;if user passed in a series for continuing, create a temporary trainee to derive all the necessary values (lags, deltas, etc.)
		;and then overwrite the passed series_context_values with the additional derived feature values
		(if (and continue_series (size series_context_values))
			(seq
				(assign (assoc
					series_context_values
						(call !DeriveUntrainedSeriesData (assoc
							series_data_features series_context_features
							series_data series_context_values
							features_to_retrieve !trainedFeatures
						))
				))
				(assign (assoc series_context_features !trainedFeatures))
			)
		)

		(call !Return
			(call !ReactSeries (assoc
				series_id_features series_id_features
				series_id_values series_id_values
				series_stop_map series_stop_maps
				max_series_length max_series_length
				output_new_series_ids output_new_series_ids
				output_features output_features
				continue_series continue_series

				initial_features initial_features
				initial_values initial_values
				action_features action_features
				derived_action_features derived_action_features
				derived_context_features derived_context_features
				series_context_features series_context_features
				series_context_values series_context_values
				details details
				extra_features extra_features
				substitute_output substitute_output
				input_is_substituted input_is_substituted
				use_case_weights use_case_weights
				leave_series_out leave_series_out
				weight_feature weight_feature
				rand_seed rand_seed

				desired_conviction desired_conviction
				use_differential_privacy use_differential_privacy
				feature_bounds_map feature_bounds_map
				goal_features_map goal_features_map
				ordered_by_specified_features ordered_by_specified_features
				exclude_novel_nominals_from_uniqueness_check exclude_novel_nominals_from_uniqueness_check
				generate_new_cases generate_new_cases
				preserve_feature_values preserve_feature_values
				new_case_threshold new_case_threshold
			))
		)
	)

	;React in a series until a series_stop_map condition is met. Aggregates rows of data corresponding to the specified context, action,
	;derived_context and derived_action features, utilizing previous rows to derive values as necessary. Outputs an assoc of "action_features" and
	;corresponding "series" where "series" is the completed 'matrix' for the corresponding action_features and derived_action_features.
	;{long_running (true) statistically_idempotent (true) read_only (true)}
	#react_series
	(declare
		;returns {ref "ReactSeriesResponse"}
		(assoc
			;{type "list" values "string"}
			;list of series ID features used to uniquely select a trained series.
			;	This list should contain all ID features, but the order can vary depending on the order of the
			;	features values given in series_id_values.
			series_id_features (list)
			;{type "list" values {type "list" min_size 1 values "any"}}
			;2d-list of values whose order corresponds to the list of features defined in series_id_features, used to identify trained series.
			series_id_values (null)
			;{type "list" values {type "assoc"} }
			;list of assocs of feature -> stop conditions:
			;	for continuous features:  { feature:  { "min" : val,  "max": val } } - stops series when feature value exceeds max or is smaller than min
			;	for nominal features:  { feature:  { "values" : ['val1', 'val2' ]} }  - stops series when feature value matches any of the values listed
			;	specifying ".series_progress" with a value between 0 and 1.0 corresponding to percent completion e.g., { ".series_progress" : .95 } -
			;		stops series when it progresses at or beyond 95%.
			; one assoc is used per series.
			series_stop_maps (list)
			;{type "list" values "number"}
			;list of maximum sizes each series is allowed to be.  Default is 3 * dataset_size, a 0 or less is no limit.
			;	If forecasting with 'continue_series', this defines the maximum length of the forecast.
			max_series_lengths (null)
			;{type "boolean"}
			;flag, if true series ids are replaced with unique values on output.
			output_new_series_ids (true)
			;{type "string" enum ["fixed" "dynamic" "no"]}
			;Controls how closely generated series should follow existing series (plural).
			;	Choices are: "fixed", "dynamic" or "no". If "fixed", tracks the particular relevant series ID. If "dynamic", tracks the particular
			;	relevant series ID, but is allowed to change the series ID that it tracks based on its current context. If "no", does not track any particular series ID.
			series_id_tracking "fixed"
			;{type "boolean"}
			;flag, default is false.  When true, react_series will do a forecast of a series.
			;	When true, either series_id_values or series_context_values must be specified.
			continue_series (false)
			;{type "list" values ["number" "string"]}
			;time step values at which to begin synthesis for each series, applicable only for time series.
			init_time_steps (null)
			;{type "list" values ["number" "string"]}
			;time step values at which to end synthesis for each series, applicable only for time series.
			final_time_steps (null)
			;{type "list" values "string"}
			;list of feature names corresponding to values in each row of action_values
			action_features (list)
			;{type "list" values "string"}
			;list of context features whose values should be computed from the entire series in the specified order.
			;	Must be different than context_features.
			derived_context_features (list)
			;{type "list" values "string"}
			;list of action features whose values should be computed from the resulting last row in series, in the specified
			;	order. Must be a subset of action_features.
			;	Note: both of these derived feature lists rely on the features' "derived_feature_code" attribute to compute the values.
			;	If 'derived_feature_code' attribute is undefined or references non-existing feature indices, the derived value will be null.
			derived_action_features (list)
			;{type "list" values "string"}
			;list of features corresponding to series_context_values
			series_context_features (list)
			;{type "list" values {type "list" min_size 1 values {type "list" min_size 1}}}
			;3d-list of values, context value for each feature for each row of each series. series_context_features must be specified if this parameter
			;is specified. If continue_series is true, then this data is forecasted. Otherwise this data conditions each row of the generated series.
			;	If specified and not using continue_series, then max_series_lengths are ignored.
			series_context_values (null)
			;{type "list" values "string"}
			;list of additional features to return with audit data from details
			extra_features (null)
			;{ref "UseCaseWeights"}
			;flag, whether to use case weights or not. If unspecified will automatically select based on cached parameters
			use_case_weights (null)
			;{type "string"}
			;name of the feature that stores case weights
			weight_feature ".case_weight"
			;{ref "DesiredConviction"}
			;If null, will do a discriminative react. If specified, will do a generative react
			;	For Generative React, value of desired avg conviction of generated cases, in the range of (0,infinity] with 1 as standard
			;	larger values will increase the variance (or creativity) of the generated case from the existing model
			;	smaller values will decrease the variance (or creativity) of the generated case from the existing model
			desired_conviction (null)
			;{type "boolean"}
			;flag, if set to true this changes generative output to use aggregation instead of selection before adding noise.
			;By default generative output uses selection.
			use_aggregation_based_differential_privacy (false)
			;{ref "GenerateNewCases"}
			;enum, acceptable values are:
			;	null or 'no' : output any generated case
			;	'always' : only output original cases, outputs null for all feature values if unable to generate a new case
			;	'attempt' : output any generated case only if generation fails all initial attempts to output original cases
			generate_new_cases "no"
			;{type "number"}
			;total number of series to generate, for generative reacts.
			;
			;	 All of the following parameters, if specified, must be either length of 1 or equal to the length of
			;	series_context_values for discriminative reacts, and num_series_to_generate for generative reacts.
			;
			num_series_to_generate (null)
			;{ref "ReactDetails"}
			;see the description for the details parameter of #react
			details (null)
			;{type "boolean"}
			;flag, if true order of generated feature values will match the order of features
			ordered_by_specified_features (null)
			;{type "boolean"}
			;If true will exclude sensitive features whose values will be
			;	replaced after synthesis from uniqueness check.
			exclude_novel_nominals_from_uniqueness_check (null)
			;{type "boolean"}
			;flag, if true will internally generate values for all trained features and derived features while generating a series.
			;if false, will only generate values for the features specified as action features and the features necessary to derive them, reducing
			;the expected runtime but possibly reducing accuracy.
			use_all_features (true)
			;{type "boolean"}
			;flag, if true will use differentially private approach to adding noise during generative reacts. Default is false.
			;Only used when desired_conviction is specified.
			use_differential_privacy (false)
			;{type "assoc" additional_indices {ref "FeatureBounds"}}
			;assoc of :
			;	{ feature : { "min": a, "max": b, "allow_null": false/true } }
			;	to ensure that specified features' generated values stay in bounds
			;	for nominal features instead of min/max it's a set of allowed values, ie:
			;	{ feature: { "allowed" : [ "value1", "value2" ... ] }, "allow_null": false/true }
			;	allow_null - default is true, if true nulls may be generated per their distribution in the data
			feature_bounds_map (assoc)
			;{ref "Condition"}
			;A mapping of conditions for features that will be used to constrain the queries used to find the most similar
			;trained cases to the given contexts.
			;assoc of feature->value(s).
			;	  no value or (null) = select cases where that feature is (null)/missing
			;	- for continuous or numeric ordinal features:
			;	  one value = must equal exactly the value or be close to it for fuzzy match
			;	  two values = inclusive between, supports (null) on either side for less than/greater than conditions
			;	  [(null) (null)] = select all non-null cases
			;	- for nominal or string ordinal features:
			;	  n values = must match any of these values exactly
			constraints (null)
			;{type "assoc" additional_indices {ref "GoalFeatures"}}
			; assoc of :
			;		{ feature : { "goal" : "min"/"max", "value" : value }}
			;		A mapping of feature name to the goals for the feature, which will cause the react to achieve the goals as appropriate
			;		for the context.  This is useful for conditioning responses when it is challenging or impossible to know appropriate
			;		values ahead of time, such as maximizing the reward or minimizing cost for reinforcement learning, or conditioning a
			;		forecast based on attempting to achieve some value.  Goal features will reevaluate the inference for the given context
			;		optimizing for the specified goals. Valid keys in the map are:
			;		"goal": "min" or "max", will make a prediction while minimizing or maximizing the value for the feature or
			;		"value" : value, will make a prediction while approaching the specified value
			;	note: nominal features only support 'value', 'goal' is ignored.
			;		  for non-nominals, if both are provided, only 'goal' is considered.
			goal_features_map (assoc)
			;{type "assoc" additional_indices "string"}
			;A mapping of feature name to custom code strings that will be evaluated to update the value of the feature they are mapped from after inference/derivation.
			;In the time-series synthesis, these custom codes are executed just after the original feature value is derived or synthed, but before
			;any other features would be derived or generated from the value. This means that the result of this custom code may be used as the
			;context in the generation or derivation of other feature values within a single timestep. Custom code will be able to access feature
			;values of the current time step as well as previously generated timesteps.
			feature_post_process_code_map (null)
			;{type "list" values "string"}
			;list of features that will preserve their values from the case specified by case_indices, appending and
			;	overwriting the specified context and context features as necessary.  For generative reacts, if case_indices isn't specified,
			;	will preserve feature values of a random case.
			preserve_feature_values (list)
			;{ref "NewCaseThreshold"}
			;distance to determine privacy cutoff. Used to query the local minimum distance used in the distance ratio
			; 	accepted values:
			; 		'max': the maximum local distance
			; 		'min': the minimum local distance
			; 		'most_similar': the closest distance of the most similar case
			; 		null: the minimum local distance
			new_case_threshold "min"
			;{ref "NewCaseDistanceRatio"}
			;Parameter that adjusts the required distance ratio for a newly generated case to be considered private.
			;	When unspecified, defaults to 1.0 and generated cases with a ratio of 1.0 or greater are considered private.
			; 	Larger values will increase strictness of privacy check.
			; 	Smaller values will loosen the privacy check. Must be a positive number, since 0 would function same as `generate_new_cases='no'`
			new_case_distance_ratio (null)
			;{type "boolean"}
			;flag, default is true, only applicable if a substitution value map has been set. If set to false, will not substitute categorical feature values.
			substitute_output (true)
			;{type "boolean"}
			;flag, if true and series IDs are specified with series_id_values, then that series' cases will be held out of queries made within the
			;react_series call.
			leave_series_out (false)
			;{type "boolean"}
			;flag, if set to true assumes provided categorical (nominal or ordinal) feature values already been substituted.
			input_is_substituted (false)
		)
		(call !ValidateParameters)
		(call !ValidateFeatures)
		(call !ValidateGoalFeaturesMap)
		(call !ValidateConstraints)

		;determine number of reacts to batch
		(declare (assoc
			num_reacts
				(max
					1
					(if (!= (null) desired_conviction)
						num_series_to_generate

						(!= (null) series_context_values)
						(size series_context_values)

						(!= (null) series_id_values)
						(size series_id_values)
					)
				)
		))

		;validate parameters
		(declare (assoc
			invalid_react_parameters (false)
			warnings (assoc)
			output_features action_features
		))

		(call !ValidateBatchReactParameter (assoc param series_id_values param_name "series_id_values"))
		(call !ValidateBatchReactParameter (assoc param series_stop_maps param_name "series_stop_maps"))
		(call !ValidateBatchReactParameter (assoc param max_series_lengths param_name "max_series_lengths"))

		(if series_stop_maps
			(assign (assoc
				invalid_react_parameters
					(call !ValidateSeriesStopMaps (assoc
						series_stop_maps series_stop_maps
						feature_bounds_map feature_bounds_map
					))
			))
		)

		(if invalid_react_parameters
			(conclude
				(call !Return (assoc
					errors (list (concat "Failed to react_series: invalid stopping condition specified for " invalid_react_parameters) )
				))
			)
		)

		(let
			(assoc invalid_ts_details (indices (remove (zip requested_details) !tsSupportedDetails) ) )

			(if (size invalid_ts_details)
				(accum (assoc
					warnings
						(associate
							(concat
								"The following details are not officially supported for react series: "
								(apply "concat" (map (lambda (concat (current_value) ",") ) invalid_ts_details) )
								". Behavior is experimental."
							)
						)
				))
			)
		)

		(if (and
				(size series_id_features)
				(!=
					(zip series_id_features)
					(zip (get !tsFeaturesMap "series_id_features"))
				)
			)
			(conclude
				(call !Return (assoc
					errors
						(list (concat
							"When using series_id_features, all ID features must be specified."
						))
				))
			)
		)

		(if (and
				continue_series
				(not (xor
					(size series_id_values)
					(size series_context_values)
				))
			)
			(conclude
				(call !Return (assoc
					errors
						(list (concat
							"When using the continue_series flag, either series_id_values or series_context_values "
							"must be specified, but not both."
						))
				))
			)
		)

		(if !hasDateTimeFeatures
			(call !ValidateDateTimeInputs (assoc single_series (false)))
		)

		(if (and
				(size series_context_values)
				(not (size series_context_features))
			)
			(conclude
				(call !Return (assoc
					errors (list "series_context_values is provided without series_context_features, please specify series_context_features.")
				))
			)
		)

		(call !ValidateDerivedActionFeaturesIsSubset)
		(declare (assoc
			post_process_needed_features_map (null)
			initial_features (list)
			initial_values (list)
			hyperparam_map
				(call !GetHyperparameters (assoc
					feature (null)
					context_features series_context_features
					weight_feature weight_feature
				))
		))

		(call !UpdateCaseWeightParameters (assoc set_valid_weight_feature (false) ))

		;check and update caches if necessary
		(call !PreReactCacheChecks)

		;prep time series parameters if it's a time series model
		(if !tsTimeFeature
			(call !PrepTimeSeriesFeatures (assoc n_samples num_reacts))
		)

		;if user passed in a series for continuing, create a temporary trainee to derive all the necessary values (lags, deltas, etc.)
		;and then overwrite the passed series_context_values with the additional derived feature values
		(if (and continue_series (size series_context_values))
			(let
				(assoc
					original_series_context_features series_context_features
					time_feature_index 0
					time_feature (retrieve_from_entity "!tsTimeFeature")
				)

				;use all the features including all the derived ones
				(assign (assoc series_context_features !trainedFeatures ))

				(assign (assoc
					series_context_values
						(map
							(lambda (let
								(assoc context_values (current_value 1) )

								(call !DeriveUntrainedSeriesData (assoc
									series_data context_values
									series_data_features original_series_context_features
									features_to_retrieve !trainedFeatures
									input_is_substituted input_is_substituted
								))
							))
							series_context_values
						)
				))
			)
		)

		(call !Return
			(call !BatchReactSeries (assoc
				series_id_features series_id_features
				series_id_values series_id_values
				series_stop_maps series_stop_maps
				max_series_lengths max_series_lengths
				output_new_series_ids output_new_series_ids
				series_id_tracking series_id_tracking
				output_features output_features
				continue_series continue_series

				initial_features initial_features
				initial_values initial_values
				action_features action_features
				derived_action_features derived_action_features
				derived_context_features derived_context_features
				series_context_features series_context_features
				series_context_values series_context_values
				details details
				extra_features extra_features
				substitute_output substitute_output
				input_is_substituted input_is_substituted
				use_case_weights use_case_weights
				leave_series_out leave_series_out
				weight_feature weight_feature
				rand_seed rand_seed
				num_reacts num_reacts

				desired_conviction desired_conviction
				use_differential_privacy use_differential_privacy
				feature_bounds_map feature_bounds_map
				goal_features_map goal_features_map
				ordered_by_specified_features ordered_by_specified_features
				exclude_novel_nominals_from_uniqueness_check exclude_novel_nominals_from_uniqueness_check
				generate_new_cases generate_new_cases
				preserve_feature_values preserve_feature_values
				new_case_threshold new_case_threshold
			))
		)
	)

	;private helper method that takes untrained series data and derives all the TS derived features,
	;and returns the same series sorted and derived properly using a temporary cloned subtrainee
	#!DeriveUntrainedSeriesData
	(declare
		(assoc
			series_data_features (null)
			series_data (null)
			features_to_retrieve !trainedFeatures
			input_is_substituted (false)
		)

		(declare (assoc trainee_clone (first (create_entities (null))) ))
		;create a shallow copy (no contained entities, just the trainee data)
		(assign_entity_roots trainee_clone (retrieve_entity_root ) )

		;train and derive all the lags and other features as necessary
		(call_entity trainee_clone "train" (assoc
			cases series_data
			features series_data_features
			session "temp"
			input_is_substituted input_is_substituted
			allow_training_reserved_features (true)
			skip_auto_analyze (true)
			skip_reduce_data (true)
		))

		(declare (assoc
			derived_data
				(get
					(call_entity trainee_clone "get_cases" (assoc
						features features_to_retrieve
						session "temp"
					))
					(list 1 "payload" "cases")
				)
			time_feature_index
				(get
					(zip features_to_retrieve (indices features_to_retrieve))
					time_feature
				)
		))
		(destroy_entities trainee_clone)

		;sort the passed in data by the time feature to ensure its order
		(call !MultiSortList (assoc
			data derived_data
			column_order_indices (list time_feature_index)
		))
	)

	;helper method that linearly interpolates a value given discrete samplings
	;used for evaluating error of forecasts at a specific time value that does
	;not generate the timestep at the exact time needed
	#!InterpolateSeriesValuesContinuous
	(declare
		(assoc
			;list of time values, must be increasing
			time_values (list)
			;the time value to interpolate to
			time (null)
			;list of feature values to interpolate
			feature_values (list)

			;value to return if 'time' is less than the first value of 'time_values'
			pre_domain_value (null)
			;value to return if 'time' is greater than the last value of 'time_values'
			post_domain_value (null)
		)

		(if (< time (first time_values))
			(conclude pre_domain_value)

			(> time (last time_values))
			(conclude post_domain_value)
		)

		(declare (assoc prev_index (null) ))

		;this "infinite" loop iterates using the incrementing (current_index) and assumes
		;time_values is sorted. it should always find a time_value greater than time
		;because of the checks above
		(while (true)
			(if (> (get time_values (current_index)) time)
				(conclude
					(assign (assoc prev_index (- (current_index 1) 1) ))
				)

				(= (get time_values (current_index)) time)
				;if find perfect match, just return value without interpolating
				(conclude (conclude (get feature_values (current_index))))

				(> (current_index) (size time_values))
				;this should never be reached unless time_values are not sorted
				;and no element is greater than time
				(conclude (conclude (last feature_values)))
			)
		)

		(+
			;value from previous time
			(get feature_values prev_index)
			(*
				;percent way through time-gap
				(/
					(- time (get time_values prev_index))
					(-
						(get time_values (+ prev_index 1))
						(get time_values prev_index)
					)
				)
				;y-delta within gap
				(-
					(get feature_values (+ prev_index 1))
					(get feature_values prev_index)
				)
			)
		)
	)

	;helper method that selects a nominal class given discrete samplings
	;used for evaluating error of forecasts at a specific time value that does
	;not generate the timestep at the exact time needed
	#!InterpolateSeriesValuesNominal
	(declare
		(assoc
			;list of time values, must be increasing
			time_values (list)
			;the time value to interpolate to
			time (null)
			;list of feature values to interpolate
			feature_values (list)

			;value to return if 'time' is less than the first value of 'time_values'
			pre_domain_value (null)
			;value to return if 'time' is greater than the last value of 'time_values'
			post_domain_value (null)
		)

		(if (< time (first time_values))
			(conclude pre_domain_value)

			(> time (last time_values))
			(conclude post_domain_value)
		)

		(declare (assoc prev_index (null) ))

		;this "infinite" loop iterates using the incrementing (current_index) and assumes
		;time_values is sorted. it should always find a time_value greater than time
		;because of the checks above
		(while (true)
			(if (> (get time_values (current_index)) time)
				(conclude
					(assign (assoc prev_index (- (current_index 1) 1) ))
				)

				(= (get time_values (current_index)) time)
				;if find perfect match, just return value without interpolating
				(conclude (conclude (get feature_values (current_index))))

				(> (current_index) (size time_values))
				;this should never be reached unless time_values are not sorted
				;and no element is greater than time
				(conclude (conclude (last feature_values)))
			)
		)

		(if (<=
				(- time (get time_values prev_index))
				(- (get time_values (+ 1 prev_index)) time)
			)
			;if the time is closer to the previous timestep than the next, return the
			;nominal class of the previous
			(get feature_values prev_index)

			(get feature_values (+ 1 prev_index))
		)
	)

	;helper method that interpolates the CAPs between the two timesteps around a specified point in time
	;used for evaluating error of forecasts at a specific time value that does
	;not generate the timestep at the exact time needed
	#!InterpolateSeriesCAPs
	(declare
		(assoc
			;list of time values, must be increasing
			time_values (list)
			;the time value to interpolate to
			time (null)
			;list of CAPs at each timestep to interpolate
			caps_values (list)

			;value to return if 'time' is less than the first value of 'time_values'
			pre_domain_value (null)
			;value to return if 'time' is greater than the last value of 'time_values'
			post_domain_value (null)
		)

		(if (< time (first time_values))
			(conclude pre_domain_value)

			(> time (last time_values))
			(conclude post_domain_value)
		)

		(declare (assoc prev_index (null) ))

		;this "infinite" loop iterates using the incrementing (current_index) and assumes
		;time_values is sorted. it should always find a time_value greater than time
		;because of the checks above
		(while (true)
			(if (> (get time_values (current_index)) time)
				(conclude
					(assign (assoc prev_index (- (current_index 1) 1) ))
				)

				(= (get time_values (current_index)) time)
				;if find perfect match, just return value without interpolating
				(conclude (conclude (get caps_values (current_index))))

				(> (current_index) (size time_values))
				;this should never be reached unless time_values are not sorted
				;and no element is greater than time
				(conclude (conclude (last caps_values)))
			)
		)

		(declare (assoc
			prev_caps (get caps_values prev_index)
			next_caps (get caps_values (+ 1 prev_index))
		))

		(declare (assoc
			all_represented_features_set (zip (append (indices prev_caps) (indices next_caps)))
			percent_way_through_time_gap
				(/
					(- time (get time_values prev_index))
					(-
						(get time_values (+ prev_index 1))
						(get time_values prev_index)
					)
				)
		))

		(map
			(lambda
				(+
					;value from previous time
					(or (get prev_caps (current_index)) 0)
					(*
						percent_way_through_time_gap
						;y-delta within gap
						(-
							(or (get next_caps (current_index)) 0)
							(or (get prev_caps (current_index)) 0)
						)
					)
				)
			)
			all_represented_features_set
		)
	)

)