(null
	;compute and output average feature surprisal for features
	;with respect to their respective mean absolute deviations
	;
	;parameters:
	; feature_residuals: list of feature residuals
	; mean_absolute_deviations: list of respective feature MAD values in the same order as feature_residuals
	#!ComputeAverageFeatureSurprisal
		(let
			(assoc
				action_feature_surprisals
					(map
						(lambda
							;if MAD is 0, just return 0
							(if (= 0 (last (current_value)))
								0

								(- 1
									(exp (/
										(- (first (current_value)))
										(last (current_value))
									))
								)
							)
						)
						feature_residuals
						mean_absolute_deviations
					)
			)

			(declare (assoc
				avg_surprisal (/ (apply "+" action_feature_surprisals) (size action_feature_surprisals))
			))

			;output the average surprisal
			avg_surprisal
		)

	#!ComputeFeatureMAD
		(if (contains_index !nominalsMap feature)
			(let
				(assoc
					counts_map (get !expectedValuesMap (list weight_feature feature "class_counts"))
					total_count 0
				)
				(assign (assoc total_count (apply "+" (values counts_map)) ))

				(list
					;nominal MAD is the sum of: each class's probability multiplied by probability of getting it wrong
					(apply "+"
						(map
							(lambda (let
								(assoc class_prob (* (/ (current_value 1) total_count)) )
								(* class_prob (- 1 class_prob))
							))
							(values counts_map)
						)
					)

					;largest possible incorrect probability is 1 - smallest probability
					(- 1 (/ (apply "min" (values counts_map)) total_count))
				)
			)

			;else continuous
			(let
				(assoc
					mean_value (get !expectedValuesMap (list weight_feature feature "expected_value"))
					feature_values
						(map
							(lambda (retrieve_from_entity (current_value) feature) )
							(contained_entities (list
								(query_not_equals feature (null))
							))
						)
					errors (list)
				)

				;list of absolute deviations for the whole dataset
				(assign (assoc
					errors
						(map
							(lambda (abs (- mean_value (current_value))) )
							feature_values
						)
				))

				(list
					;Mean Absolute Deviation
					(/ (apply "+" errors) (size errors))
					;max error
					(apply "max" errors)
				)
			)
		)

	;helper method for CalculateFeatureResiduals to calculate 'superfull' accurate residuals
	#!RunAccurateResiduals
		(seq
			;keep a copy of all originally specified features
			(assign (assoc case_features features))

			;if we only collected residuals for this one feature, set the residuals features list to have only target_residual_feature
			(if target_residual_feature
				(assign (assoc features (list target_residual_feature) ))
			)

			;create a map of feature -> flag, set to true if the feature has any null values
			;that way there's no need to explicitly filter nulls out when querying for a feature that no nulls
			(declare (assoc
				feature_may_have_nulls_map
					(map
						(lambda (!= (false) (get !featureNullRatiosMap (list (current_index 1) "has_nulls")) ) )
						(zip
							(if target_residual_feature
								(list target_residual_feature)
								features
							)
						)
					)
			))

			;iterate over each case and accumulate residuals for all the feature(s)
			#!AccumulateAccurateFeatureResiduals
			(assign (assoc
				case_residuals_lists
					||(map
						(lambda (let
							(assoc
								;assoc of all features to their residual values
								feature_residual_map (assoc)
								local_cases_map (assoc)
								case_id (current_value 1)
								;map of feature -> value for all the case values
								case_values_map (zip case_features (retrieve_from_entity (current_value 1) case_features) )
							)

							(assign (assoc
								local_cases_map
									(compute_on_contained_entities (append
										(if focal_case
											(query_not_in_entity_list (list case_id focal_case))
											(query_not_in_entity_list (list case_id))
										)
										(query_nearest_generalized_distance
											k_parameter
											case_features
											(unzip case_values_map case_features)
											(get hyperparam_map "featureWeights")
											!queryDistanceTypeMap
											query_feature_attributes_map
											(get hyperparam_map "featureDeviations")
											p_parameter
											dt_parameter
											(if valid_weight_feature weight_feature (null))
											tie_break_random_seed
											(null) ;radius
											!numericalPrecision
										)
									))
							))

							;create a map of feature -> residual value for each feature
							(assign (assoc
								feature_residual_map
									(map
										(lambda (let
											(assoc
												feature (get_value (current_index 1))
												case_feature_value (get case_values_map (current_index 1))
												feature_is_nominal (contains_index !nominalsMap (current_index 1))
												interpolated_value 0
												diff 0
												output_categorical_action_probabilities (true)
												categorical_action_probabilities_map (assoc)
											)
											;create the feature-specific candidate_cases_lists tuple for intepolation
											(declare (assoc
												candidate_cases_lists
													(if (!= (null) local_cases_map)
														(list
															(indices local_cases_map)
															(values local_cases_map)
															(map (lambda (retrieve_from_entity (current_value) feature)) (indices local_cases_map))
														)
													)
											))
											(if (get feature_may_have_nulls_map feature)
												(let
													(assoc
														null_indices
															(filter
																(lambda (= (null) (get candidate_cases_lists (list 2 (current_value 1))) ) )
																(indices (last candidate_cases_lists))
															)
													)
													(if (size null_indices)
														(assign (assoc
															candidate_cases_lists
																;only remove cases with null values if there are going to be some remaining
																(if (< (size null_indices) (size (first candidate_cases_lists)))
																	(list
																		(remove (first candidate_cases_lists) null_indices)
																		(remove (get candidate_cases_lists 1) null_indices)
																		(remove (last candidate_cases_lists) null_indices)
																	)
																)
														))
													)
												)
											)

											(call !InterpolateAndComputeDiffToCase)
										))
										(zip features)
									)
							))

							;return the computed values as a list
							(unzip feature_residual_map features)
						))
						case_ids
					)
			))


			;transpose (turn columns into rows) case_residuals_lists into a list the length of features
			;where each value matches a feature, and is comprised of each feature's residuals, then filter out nulls
			(assign (assoc
				feature_residuals_lists (call !TransposeResidualLists)
				;need to have at least 2.5% (that's a value of 50 using default sample of 2000) non-null values for a feature
				min_value_count (ceil (* 0.025 (size case_ids)))
			))

			;determine if any of the lists in feature_residuals_lists are too short (< 50 values), if so keep feature as needing to be resampled
			;applicable only to global models
			(if (!= (true) regional_model_only)
				(let
					(assoc
						num_valid_values_per_feature_map
							(filter
								(lambda (< (current_value) min_value_count) )
								(zip
									features
									(map (lambda (size (current_value))) feature_residuals_lists)
								)
							)
					)

					;some features did not have 50 values, accrue case_ids, then call the main method agan
					(if (size num_valid_values_per_feature_map)
						(seq
							;create the resampled case_ids list that contains cases with enough necessary non-null feature values
							(assign  (assoc
								case_ids
									;append all the lists of cases ids for each feature into one list
									(apply "append"
										;for each (current_index) feature, need to find 50 - (current_value) cases to have enough values for those features
										(values (map
											(lambda (contained_entities
												(query_not_equals (current_index) (null))

												(if valid_weight_feature
													(query_weighted_sample weight_feature (- min_value_count (current_value)) (rand))
													(query_sample (- min_value_count (current_value)) (rand))
												)
											))
											num_valid_values_per_feature_map
										))
									)
							))

							;re-compute residuals on these case_ids, store into case_residuals_lists
							(call !AccumulateAccurateFeatureResiduals)

							;transpose case_residuals_lists into a list the length of features and append the results into feature_residuals_lists
							(assign (assoc
								feature_residuals_lists
									(map
										(lambda (append (first (current_value)) (last (current_value))))
										feature_residuals_lists
										(call !TransposeResidualLists)
									)
							))
						)
					)
				)
			)
		)

	#!InitMIA
		(seq
			(if (< num_training_cases 2)
				(conclude (assoc))
			)

			;need 2x as many default robust samples since on average half the features won't have computations
			(if (= (null) num_samples)
				(assign (assoc
					num_samples (if robust 2000 1000)
				))
			)

			;if user doesn't want to use case weights, change weight_feature to '.none'
			(if (not use_case_weights)
				(assign (assoc weight_feature ".none"))

				(assign (assoc valid_weight_feature (or hasPopulatedCaseWeight (!= weight_feature ".case_weight")) ))
			)

			;if features aren't specified, assume all defaultFeatures will need to have their mae calculated
			; (if (= (null) features)
			; 	(assign (assoc features defaultFeatures))
			; )

			;if for some reason expected values haven't been cached, do that here
			(if (= 0 (size expectedValuesMap))
				(call CacheExpectedValuesAndProbabilities (assoc
					features (append context_features action_feature)
					weight_feature weight_feature
					use_case_weights use_case_weights
				))
			)

			;set the passed in one as the hyperparam map to use if specified
			(assign (assoc hyperparam_map custom_hyperparam_map))

			(if (= (null) hyperparam_map)
				(assign (assoc
					hyperparam_map
						(call GetHyperparameters (assoc
							feature action_feature
							mode "full"
							weight_feature weight_feature
						))
				))
			)

			(assign (assoc
				k_parameter (get hyperparam_map "k")
				p_parameter (get hyperparam_map "p")
				dt_parameter (get hyperparam_map "dt")
                query_feature_attributes_map (get hyperparam_map "featureDomainAttributes")
			))

			;if case_ids weren't specified either, use a random num_samples sampling of cases from the whole model
			(if (= 0 (size case_ids))
				(assign (assoc
					case_ids
						;if there are more cases than the sample size, randomly select that many cases, by default cases are in random order
						(if (and (> num_training_cases num_samples) (> num_training_cases 1000))
							(if robust
								(call SampleCases (assoc
									num num_samples
									rand_seed (rand)
									case_weight_feature (if valid_weight_feature weight_feature)
								))
								;grab samples from the model
								(call AllCases (assoc num num_samples rand_seed (rand)))
							)

							;else the model is small, use the smaller of num_samples or (num_cases * 2^f) because that's the amount of all possible combinations
							(if robust
								(call SampleCases (assoc
									num (min num_samples (* num_training_cases (pow 2 (size features))))
									case_weight_feature (if valid_weight_feature weight_feature)
								))
								;else just use all the case ids because the model size is <= num_samples or the model is small
								(call AllCases)
							)
						)
				))
			)
		)

	;Mean Increase In Accuracy
	;outputs: an assoc of feature -> normalized increase in accuracy delta
	;	where the delta is MAD of action feature - MAE of action feature being predicted by this feature
	#MIA
		(declare
			(assoc
				context_features (null)
				action_feature (null)
				case_ids (list)
				num_samples (null)
				robust (false)
				focal_case (null) ;todo: applicable?

				hyperparameter_feature ".targetless"
				use_case_weights (false)
				weight_feature ".case_weight"
				custom_hyperparam_map (null)
			)

			(declare (assoc
				k_parameter (null)
				p_parameter (null)
				dt_parameter (null)
                query_feature_attributes_map (null)
				case_weights (null)
				case_features (null)
				has_case_weights (false)
				ordinal_features_map (zip ordinalFeatures)
				hyperparam_map (assoc)
				residuals_map (assoc)
				ordinal_residuals_map (assoc)

				;list, length of case_ids, each item will be a list of residual values, one per feature
				case_residuals_lists (list)
				;list, length of features, each item will be a list of residuals, one per case
				feature_residuals_lists (list)

				feature_weight_scales (null)
				num_training_cases (call GetNumTrainingCases)
				valid_weight_feature (false)
				feature_is_nominal (contains_index nominalsMap action_feature)

				num_robust_reacts_per_case 200
			))

			(call !InitMIA)

			(declare (assoc
				action_mad_pair (if action_feature (call !ComputeFeatureMAD (assoc feature action_feature)) )
				action_min_mae
					(if action_feature
						(get hyperparam_map (list "featureDeviations" action_feature))
					)
			))

			;compute map of MIA deltas from feature MAD for each feature
			(declare (assoc
				mia_mae_map (call !RunFullMIA)
				total_value 0
			))

			(declare (assoc
				max_mad (first action_mad_pair)
				min_mad (min action_min_mae (apply "min" (values mia_mae_map)))
				smallest_value (get cachedFeatureMinResidualMap action_feature)
			))

			(assign (assoc
				mia_mae_map
					(map
						(lambda
							(/
								(- max_mad min_mad)
								;prevent divide by 0
								(max (- (current_value) min_mad) smallest_value)
							)
						)
						mia_mae_map
					)
					; (map
					; 	(lambda (/ max_mad (current_value)))
					; 	mia_mae_map
					; )
			))

			(accum (assoc mia_mae_map (associate action_feature 1) ))

			mia_mae_map
		)

	#!RunFullMIA
		(map
			(lambda (let
				(assoc
					feature (get_value (current_index 1) )
					maes (list)
				)

				(assign (assoc
					maes
						||(map
							(lambda (let
								(assoc
									local_cases_map (assoc)
									case_feature_value (null)
									case_id (current_value 1)
									case_values_map (zip (list feature action_feature) (retrieve_from_entity (current_value 1) (list feature action_feature)))
									interpolated_value 0
									diff 0
									output_categorical_action_probabilities (true)
									categorical_action_probabilities_map (assoc)
								)

								(assign (assoc
									local_cases_map
										(compute_on_contained_entities (append
											(if focal_case
												(query_not_in_entity_list (list case_id focal_case))
												(query_not_in_entity_list (list case_id))
											)
											(query_nearest_generalized_distance
												k_parameter
												(list feature)
												(unzip case_values_map (list feature))
												(null) ;no weight since only one feature
												queryDistanceTypeMap
												query_feature_attributes_map
												(null) ; no deviations since only one feature (if (get hyperparam_map "useDeviations") (get hyperparam_map "featureDeviations") )
												1 ;p_parameter is not relevant since only one feature
												dt_parameter
												(if valid_weight_feature weight_feature (null))
												tie_break_random_seed
												(null) ;radius
												numericalPrecision
											)
										))
									case_feature_value (get case_values_map action_feature)
								))

								(assign (assoc
									interpolated_value
										;null local_cases_map means we use expected feature value
										(if (= (null) local_cases_map)
											;global nominal probabilities will pulled below
											(if feature_is_nominal
												(null)
												;else get continuous expected value
												(call CalculateFeatureExpectedValue (assoc
													feature action_feature
													allow_nulls (false)
												))
											)

											;else interpolate the feature value from the local model
											(call InterpolateActionValues (assoc
												action_feature action_feature
												neighbor_weights_map local_cases_map
												allow_nulls (false)
												has_perfect_matches (contains_value local_cases_map .infinity)
											))
										)
								))

								(if (= (null) case_feature_value)
									(null)

									feature_is_nominal
									(associate
										case_feature_value
											(if (= case_feature_value interpolated_value )
												0
												;else output the delta
												1
												; (- 1
												; 	(+ (or
												; 		(get categorical_action_probabilities_map (list action_feature case_feature_value))
												; 	))
												; )
											)
									)

									;else continuous
									(abs (- case_feature_value interpolated_value))
								)
							))
							case_ids
						)
				))

				#!AverageMIAMeanAbsoluteErrors
				(if feature_is_nominal
					(seq
						;maes for nominal are in the format of (list (assoc "f1" 3) (assoc "f2" 12.5) ... )
						;class_counts_map will be an assoc of feature -> count of maes
						;class_mae_map will be an assoc of feature -> total mae value
						(assign (assoc
							; class_counts_map
							; 	(reduce
							; 		(lambda  (let
							; 			(assoc
							; 				old_assoc (current_value 2)
							; 				key (first (indices (current_value 1)))
							; 				next_assoc (current_value 1)
							; 			)
							; 			(if (contains_index old_assoc key)
							; 				(set old_assoc key (+ (get old_assoc key) 1) )
							; 				(append old_assoc (associate key 1))
							; 			)
							; 		))
							; 		maes
							; 	)
							class_mae_map
								(reduce
									(lambda  (let
										(assoc
											old_assoc (previous_result 1)
											key (first (indices (current_value 1)))
											next_assoc (current_value 1)
										)
										(if (contains_index old_assoc key)
											(set old_assoc key (+ (get old_assoc key) (get next_assoc key)) )
											(append old_assoc next_assoc)
										)
									))
									maes
								)
						))

						; (assign (assoc
						; 	maes
						; 		(map
						; 			(lambda (/ (last (current_value)) (first (current_value)) )  )
						; 			class_counts_map
						; 			class_mae_map
						; 		)
						; ))

						;balanced average between all classes
						(declare (assoc
							;mae (/ (apply "+" (values maes)) (size maes))
							mae (/ (apply "+" (values class_mae_map)) (size case_ids))
						))

						(if (= .nan mae)
							0

							;MIA mae
							mae
						)
					)

					;else continuous
					(seq
						(assign (assoc maes (filter maes) ))
						(declare (assoc mae (/ (apply "+" maes) (size maes)) ))

						(if (= .nan mae)
							0

							;MIA mae
							mae
						)
					)
				)
			))
			(zip context_features)
		)

)