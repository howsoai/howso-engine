(null

	;helper method for CalculateFeatureResiduals to calculate 'superfull' accurate residuals
	#!RunAccurateResiduals
	(seq
		;keep a copy of all originally specified features
		(assign (assoc case_features features))

		;if we only collected residuals for this one feature, set the residuals features list to have only target_residual_feature
		(if target_residual_feature
			(assign (assoc features (list target_residual_feature) ))
		)

		;create a map of feature -> flag, set to true if the feature has any null values
		;that way there's no need to explicitly filter nulls out when querying for a feature that no nulls
		(declare (assoc
			feature_may_have_nulls_map
				(map
					(lambda (!= (false) (get !featureNullRatiosMap (list (current_index 1) "has_nulls")) ) )
					(zip
						(if target_residual_feature
							(list target_residual_feature)
							features
						)
					)
				)
			series_id_features (if !tsTimeFeature (get !tsModelFeaturesMap "series_id_features") )
		))

		;iterate over each case and accumulate residuals for all the feature(s)
		#!AccumulateAccurateFeatureResiduals
		(assign (assoc
			case_residuals_lists
				||(map
					(lambda (let
						(assoc
							;assoc of all features to their residual values
							feature_residual_map (assoc)
							local_cases_map (assoc)
							case_id (current_value 1)
							;map of feature -> value for all the case values
							case_values_map (zip case_features (retrieve_from_entity (current_value 1) case_features) )
							time_series_filter_query (list)
						)

						(if !tsTimeFeature
							(if (contains_index case_values_map !tsTimeFeature)
								(assign (assoc
									time_series_filter_query (call !ComputeTimeSeriesFilterQuery (assoc context_map case_values_map))
								))
							)
						)

						(assign (assoc
							local_cases_map
								(compute_on_contained_entities (append
									(if focal_case
										(query_not_in_entity_list (list case_id focal_case))
										(query_not_in_entity_list (list case_id))
									)
									time_series_filter_query
									(query_nearest_generalized_distance
										k_parameter
										case_features
										(unzip case_values_map case_features)
										(get hyperparam_map "featureWeights")
										!queryDistanceTypeMap
										query_feature_attributes_map
										(get hyperparam_map "featureDeviations")
										p_parameter
										dt_parameter
										(if valid_weight_feature weight_feature (null))
										tie_break_random_seed
										(null) ;radius
										!numericalPrecision
									)
								))
						))

						;create a map of feature -> residual value for each feature
						(assign (assoc
							feature_residual_map
								(map
									(lambda (let
										(assoc
											feature (get_value (current_index 1))
											case_feature_value (get case_values_map (current_index 1))
											feature_is_nominal (contains_index !nominalsMap (current_index 1))
											interpolated_value 0
											diff 0
											output_categorical_action_probabilities (true)
											categorical_action_probabilities_map (assoc)\
											max_gap (null)
										)
										;create the feature-specific candidate_cases_lists tuple for intepolation
										(declare (assoc
											candidate_cases_lists
												(if (!= (null) local_cases_map)
													(list
														(indices local_cases_map)
														(values local_cases_map)
														(map (lambda (retrieve_from_entity (current_value) feature)) (indices local_cases_map))
													)
												)
										))

										(if (get feature_may_have_nulls_map feature)
											(let
												(assoc
													null_indices
														(filter
															(lambda (= (null) (get candidate_cases_lists (list 2 (current_value 1))) ) )
															(indices (last candidate_cases_lists))
														)
												)
												(if (size null_indices)
													(assign (assoc
														candidate_cases_lists
															;only remove cases with null values if there are going to be some remaining
															(if (< (size null_indices) (size (first candidate_cases_lists)))
																(list
																	(remove (first candidate_cases_lists) null_indices)
																	(remove (get candidate_cases_lists 1) null_indices)
																	(remove (last candidate_cases_lists) null_indices)
																)
															)
													))
												)
											)
										)

										;stores error into diff
										(call !InterpolateAndComputeDiffToCase)

									))
									(zip features)
								)
						))

						;return the computed values as a list
						(unzip feature_residual_map features)
					))
					case_ids
				)
		))


		;transpose (turn columns into rows) case_residuals_lists into a list the length of features
		;where each value matches a feature, and is comprised of each feature's residuals, then filter out nulls
		(assign (assoc
			feature_residuals_lists (call !TransposeResidualLists)
			;need to have at least 2.5% (that's a value of 50 using default sample of 2000) non-null values for a feature
			min_value_count (ceil (* 0.025 (size case_ids)))
		))

		;determine if any of the lists in feature_residuals_lists are too short (< 50 values), if so keep feature as needing to be resampled
		;applicable only to global models
		(if (!= (true) regional_model_only)
			(let
				(assoc
					num_valid_values_per_feature_map
						(filter
							(lambda (< (current_value) min_value_count) )
							(zip
								features
								(map (lambda (size (current_value))) feature_residuals_lists)
							)
						)
				)

				;some features did not have 50 values, accrue case_ids, then call the main method agan
				(if (size num_valid_values_per_feature_map)
					(seq
						;create the resampled case_ids list that contains cases with enough necessary non-null feature values
						(assign  (assoc
							case_ids
								;append all the lists of cases ids for each feature into one list
								(apply "append"
									;for each (current_index) feature, need to find 50 - (current_value) cases to have enough values for those features
									(values (map
										(lambda (contained_entities
											(query_not_equals (current_index) (null))

											(if valid_weight_feature
												(query_weighted_sample weight_feature (- min_value_count (current_value)) (rand))
												(query_sample (- min_value_count (current_value)) (rand))
											)
										))
										num_valid_values_per_feature_map
									))
								)
						))

						;re-compute residuals on these case_ids, store into case_residuals_lists
						(call !AccumulateAccurateFeatureResiduals)

						;transpose case_residuals_lists into a list the length of features and append the results into feature_residuals_lists
						(assign (assoc
							feature_residuals_lists
								(map
									(lambda (append (first (current_value)) (last (current_value))))
									feature_residuals_lists
									(call !TransposeResidualLists)
								)
						))
					)
				)
			)
		)
	)


	#!ComputeRobustTargetlessMDA
	(declare
		(assoc
			features features
			case_residuals_lists case_residuals_lists
		)

		;transpose (turn columns into rows) case_residuals_lists into a list the length of features
		;where each value matches a feature, and is comprised of each feature's residuals
		(declare (assoc
			feature_residuals_lists
				(map
					(lambda (let
						(assoc feature_index (current_index 1) )
						;get each column
						(map
							(lambda (get (current_value) feature_index) )
							case_residuals_lists
						)
					))
					features
				)
		))

		;for each feature, create a list, also length of features, where each column value is the mda
		;for the column feature computed with and without the row feature
		(declare (assoc
			mda_matrix
				(map
					(lambda (let
						(assoc
							feature (current_value 1)
							;all the residual values for this feature
							feature_residuals (get feature_residuals_lists (current_index 1))
						)

						(declare (assoc
							;keep only indices of cases where feature was used in query and its residual is null
							case_indices_with_feature
								(filter
									(lambda (= (null) (get feature_residuals (current_value))) )
									(indices feature_residuals)
								)
							;keep only indices of cases where feature was not used in query and has a residual value
							case_indices_without_feature
								(filter
									(lambda (!= (null) (get feature_residuals (current_value))) )
									(indices feature_residuals)
								)
						))
						(map
							(lambda (let
								(assoc
									mda_feature (current_value 1)
									mda_feature_residuals (get feature_residuals_lists (current_index 1))
								)
								(if (= mda_feature feature) (conclude 0) )

								(declare (assoc
									with_feature_residuals (filter (unzip mda_feature_residuals case_indices_with_feature))
									without_feature_residuals (filter (unzip mda_feature_residuals case_indices_without_feature))
								))

								(declare (assoc
									avg_without_residuals
										(max
											(get !cachedFeatureMinResidualMap mda_feature)
											(/ (apply "+" without_feature_residuals) (size without_feature_residuals))
											(get !userSpecifiedFeatureErrorsMap mda_feature)
										)
									avg_with_residuals
										(max
											(get !cachedFeatureMinResidualMap mda_feature)
											(/ (apply "+" with_feature_residuals) (size with_feature_residuals))
											(get !userSpecifiedFeatureErrorsMap mda_feature)
										)
								))
								;output ratio of the (expectedly) larger residual computed without this feature / residual computed with this feature
								(if (= 0 avg_without_residuals avg_with_residuals)
									0

									(max
										(- avg_without_residuals avg_with_residuals)
										(get !cachedFeatureMinResidualMap mda_feature)
									)
								)
							))
							features
						)
					))
					features

				)
			num_features_m_one (- (size features) 1)
		))

		;create an assoc MDA maps per feature
		;eg, if there are three features, A[0-10], B[0-100], C[0-1000] with the following mda_matrix of residuals:
		; [
		;  	[0	20	300]
		;	[4	0	100]
		;	[-2	40	0  ]
		; ]
		;it would be transposed into:
		; {
		;	"A"	{ "A" 0   "B" 4   "C" -2 }
		;	"B" { "A" 20  "B" 0   "C" 40 }
		;	"C"	{ "A" 300 "B" 100 "C" 0  }
		; }
		(declare (assoc
			individual_features_mda_map
				(zip
					features
					;transpose the matrix, so every feature has its own (column) MDA values
					(map
						(lambda (let
							(assoc feature_index (current_index 1))
							(zip
								features
								(map
									(lambda (get (current_value) feature_index))
									mda_matrix
								)
							)
						))
						mda_matrix
					)
				)
		))

		(declare (assoc
			feature_mda_map
				(map
					(lambda (let
						(assoc
							target_feature (current_index 1)
							mda_map (current_value 1)
							;alternatively, to use robust residual as baseline: (get residuals_map (current_index 1))
							target_feature_residual (get hyperparam_map ["featureResiduals" (current_index 2)])
						)

						(declare (assoc
							probabilities_of_contribution_map
								(map
									(lambda (let
										(assoc mda (current_value 1) )

										;skip if mda_feature = target_feature
										(if (= (current_index) target_feature) (conclude 0) )

										;LK metric
										;mda + 0.5 * e(-mda/residual) * (3 * residual + mda)
										(declare (assoc
											lk_value
												(+
													mda
													(*
														0.5
														(exp (- (/ mda target_feature_residual)) )
														(+ (* 3 target_feature_residual) mda)
													)
												)
										))

										;surprisal =  lk_value / target_feature_residual
										;Surprisal (surprisal - assumption) = surprisal - 1.5
										;prob of observation = e^(-Surprisal)
										;prob of contribution = 1 - prob of observation
										(-
											1
											(exp (- (- (/ lk_value target_feature_residual) 1.5)))
										)
									))
									mda_map
								)
						))

						(declare (assoc total_probs (apply "+" (values probabilities_of_contribution_map)) ))

						;normalize probabilities for use as feature weights
						(map
							(lambda (/ (current_value) total_probs))
							probabilities_of_contribution_map
						)
					))
					individual_features_mda_map
				)
		))

		feature_mda_map
	)


)