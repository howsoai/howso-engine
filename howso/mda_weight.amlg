(null

	;helper method for CalculateFeatureResiduals to calculate 'superfull' local accurate residuals
	#!ComputeDeviations
	(seq
		;keep a copy of all needed features
		(assign (assoc case_features (values (append features context_features) (true)) ))

		;if we only collected residuals for this one feature, set the residuals features list to have only target_residual_feature
		(if target_residual_feature
			(assign (assoc features (list target_residual_feature) ))
		)

		;create a map of feature -> flag, set to true if the feature has any null values
		;that way there's no need to explicitly filter nulls out when querying for a feature that no nulls
		(declare (assoc
			feature_may_have_nulls_map
				(map
					(lambda (!= (false) (get !featureNullRatiosMap (list (current_index 1) "has_nulls")) ) )
					(zip
						(if target_residual_feature
							(list target_residual_feature)
							features
						)
					)
				)
			series_id_features (if !tsTimeFeature (get !tsModelFeaturesMap "series_id_features") )
			;this variable is used in the derivation logic branch of InterpolateAndComputeDiff
			react_context_features context_features
		))

		;if all 'features' are also context features, then we can do one query per case,
		;otherwise we must do multiple queries per case where the query to predict each
		;feature includes all context features and the specific feature being predicted,
		;excluding all other 'features' that are not contexts
		(declare (assoc
			single_query_per_case
				(and
					(not (size features_for_derivation_map))
					(=
						0
						(size (remove
							(zip features)
							context_features
						))
					)
				)
		))

		;iterate over each case and accumulate residuals for all the feature(s)
		#!AccumulateLocalFeatureDeviations
		(assign (assoc
			case_residuals_lists
				||(map
					(lambda (let
						(assoc
							;assoc of all features to their residual values
							feature_residual_map (assoc)
							local_cases_map (assoc)
							case_id (current_value 1)
							;map of feature -> value for all the case values
							case_values_map (zip case_features (retrieve_from_entity (current_value 1) case_features) )
							time_series_filter_query (list)
						)

						(if !tsTimeFeature
							(if (contains_index case_values_map !tsTimeFeature)
								(assign (assoc
									time_series_filter_query (call !ComputeTimeSeriesFilterQuery (assoc context_map case_values_map))
								))
							)
						)

						;see comment where 'single_query_per_case' is defined above.
						;all features are also context features, so only the one query is needed.
						(if single_query_per_case
							(assign (assoc
								local_cases_map
									(compute_on_contained_entities (append
										(if focal_case
											(query_not_in_entity_list (list case_id focal_case))
											(query_not_in_entity_list (list case_id))
										)
										time_series_filter_query
										(if (size context_condition_filter_query)
											context_condition_filter_query
											(list)
										)
										(query_nearest_generalized_distance
											k_parameter
											context_features
											(unzip case_values_map context_features)
											(get hyperparam_map "featureWeights")
											!queryDistanceTypeMap
											query_feature_attributes_map
											(get hyperparam_map "featureDeviations")
											p_parameter
											dt_parameter
											(if valid_weight_feature weight_feature (null))
											tie_break_random_seed
											(null) ;radius
											!numericalPrecision
										)
									))
							))
						)

						;create a map of feature -> residual value for each feature
						(assign (assoc
							feature_residual_map
								(map
									(lambda (let
										(assoc
											feature (get_value (current_index 1))
											case_feature_value (get case_values_map (current_index 1))
											feature_is_nominal (contains_index !nominalsMap (current_index 1))
											interpolated_value 0
											diff 0
											output_categorical_action_probabilities (true)
											categorical_action_probabilities_map (assoc)
										)

										;see comment where 'single_query_per_case' is defined above.
										;there must be one query for each action feature where it alone is added to the contexts.
										(if (not single_query_per_case)
											(assign (assoc
												local_cases_map
													(let
														(assoc
															query_context_features
																;context features + feature being predicted
																(values (append
																	(if (contains_index features_for_derivation_map feature)
																		;if this feature should be derived, need to hold out the features that will be used to derive it
																		(filter
																			(lambda (or
																				(not (contains_value (get features_for_derivation_map feature) (current_value)))
																				(!= feature (get !derivedFeaturesMap (current_value)))
																				(contains_value (get !tsModelFeaturesMap "lag_features") (current_value))
																			))
																			context_features
																		)

																		context_features
																	)
																	feature
																) (true))
														)

														(compute_on_contained_entities (append
															(if focal_case
																(query_not_in_entity_list (list case_id focal_case))
																(query_not_in_entity_list (list case_id))
															)
															time_series_filter_query
															(if (size context_condition_filter_query)
																context_condition_filter_query
																(list)
															)
															(query_nearest_generalized_distance
																k_parameter
																query_context_features
																(unzip case_values_map query_context_features)
																(get hyperparam_map "featureWeights")
																!queryDistanceTypeMap
																query_feature_attributes_map
																(get hyperparam_map "featureDeviations")
																p_parameter
																dt_parameter
																(if valid_weight_feature weight_feature (null))
																tie_break_random_seed
																(null) ;radius
																!numericalPrecision
															)
														))
													)
											))
										)

										;create the feature-specific candidate_cases_lists tuple for intepolation
										(declare (assoc
											candidate_cases_lists
												(if (!= (null) local_cases_map)
													(list
														(indices local_cases_map)
														(values local_cases_map)
														(map (lambda (retrieve_from_entity (current_value) feature)) (indices local_cases_map))
													)
												)
										))

										(if (get feature_may_have_nulls_map feature)
											(let
												(assoc
													null_indices
														(filter
															(lambda (= (null) (get candidate_cases_lists (list 2 (current_value 1))) ) )
															(indices (last candidate_cases_lists))
														)
												)
												(if (size null_indices)
													(assign (assoc
														candidate_cases_lists
															;only remove cases with null values if there are going to be some remaining
															(if (< (size null_indices) (size (first candidate_cases_lists)))
																(list
																	(remove (first candidate_cases_lists) null_indices)
																	(remove (get candidate_cases_lists 1) null_indices)
																	(remove (last candidate_cases_lists) null_indices)
																)
															)
													))
												)
											)
										)

										;stores error into diff
										(call !InterpolateAndComputeDiffToCase)

									))
									(zip features)
								)
						))

						;return the computed values as a list
						(unzip feature_residual_map features)
					))
					case_ids
				)
		))


		;transpose (turn columns into rows) case_residuals_lists into a list the length of features
		;where each value matches a feature, and is comprised of each feature's residuals, then filter out nulls
		(assign (assoc
			feature_residuals_lists (call !TransposeResidualLists)
			;need to have at least 2.5% (that's a value of 50 using default sample of 2000) non-null values for a feature
			min_value_count (ceil (* 0.025 (size case_ids)))
		))

		;determine if any of the lists in feature_residuals_lists are too short (< 50 values), if so keep feature as needing to be resampled
		;applicable only to global models
		(if (and
				(!= (true) regional_model_only)
				(not strict_case_ids)
			)
			(let
				(assoc
					num_valid_values_per_feature_map
						(filter
							(lambda (< (current_value) min_value_count) )
							(zip
								features
								(map (lambda (size (current_value))) feature_residuals_lists)
							)
						)
				)

				;some features did not have 50 values, accrue case_ids, then call the main method agan
				(if (size num_valid_values_per_feature_map)
					(let
						;create the resampled case_ids list that contains cases with enough necessary non-null feature values
						(assoc
							case_ids_without_nulls
								;append all the lists of cases ids for each feature into one list
								(apply "append"
									;for each (current_index) feature, need to find 50 - (current_value) cases to have enough values for those features
									(values (map
										(lambda
											(contained_entities (append
												(query_not_equals (current_index) (null))

												(if valid_weight_feature
													(query_sample (- min_value_count (current_value)) weight_feature (rand))
													(query_sample (- min_value_count (current_value)) (null) (rand))
												)
											))
										)
										num_valid_values_per_feature_map
									))
								)
						)

						;re-compute residuals on these case_ids, store into case_residuals_lists
						(call !AccumulateLocalFeatureDeviations (assoc case_ids case_ids_without_nulls))

						;transpose case_residuals_lists into a list the length of features and append the results into feature_residuals_lists
						(assign (assoc
							feature_residuals_lists
								(map
									(lambda (append (first (current_value)) (last (current_value))))
									feature_residuals_lists
									(call !TransposeResidualLists)
								)
						))
					)
				)
			)
		)
	)


	#!ComputeRobustTargetlessMDA
	(declare
		(assoc features features)

		;for each feature, create a list, also length of features, where each column value is the mda
		;for the column feature computed with and without the row feature
		(declare (assoc
			mda_matrix
				(map
					(lambda (let
						(assoc
							feature (current_value 1)

							;keep only indices of cases where feature was used in query and its residual is null
							case_indices_with_feature
								(filter
									(lambda (= (null) (get feature_residuals_lists [(current_index 3) (current_value 1)])) )
									;indices of all residual values for this feature
									(indices (get feature_residuals_lists (current_index 1)))
								)

							;keep only indices of cases where feature was not used in query and has a residual value
							case_indices_without_feature
								(filter
									(lambda (!= (null) (get feature_residuals_lists [(current_index 3) (current_value 1)])) )
									;indices of all residual values for this feature
									(indices (get feature_residuals_lists (current_index 1)))
								)
						)

						(map
							(lambda (let
								(assoc
									mda_feature (current_value 1)
									mda_feature_index (current_index 1)
								)
								(if (= mda_feature feature) (conclude 0) )

								(declare (assoc
									with_feature_residuals (filter (unzip (get feature_residuals_lists mda_feature_index) case_indices_with_feature))
									without_feature_residuals (filter (unzip (get feature_residuals_lists mda_feature_index) case_indices_without_feature))
								))

								(declare (assoc
									avg_without_residuals
										(/ (apply "+" without_feature_residuals) (size without_feature_residuals))
									avg_with_residuals
										(/ (apply "+" with_feature_residuals) (size with_feature_residuals))
								))
								;output ratio of the (expectedly) larger residual computed without this feature / residual computed with this feature
								(if (= 0 avg_without_residuals avg_with_residuals)
									0

									(max
										(- avg_without_residuals avg_with_residuals)
										(get !cachedFeatureMinResidualMap mda_feature)
									)
								)
							))
							features
						)
					))
					features
				)
			num_features_m_one (- (size features) 1)
		))

		;iterate over an assoc of MDA maps per feature and convert to a normalized probability feature mda matrix
		(map
			(lambda (let
				(assoc
					target_feature (current_index 1)
					mda_map (current_value 1)
					target_feature_residual (get baseline_hyperparameter_map ["featureResiduals" (current_index 2)])
				)

				(declare (assoc
					probabilities_of_contribution_map
						(map
							(lambda (let
								(assoc mda (current_value 1) )

								;skip if mda_feature = target_feature
								(if (= (current_index) target_feature) (conclude 0) )

								;LK metric
								;mda + 0.5 * e(-mda/residual) * (3 * residual + mda)
								(declare (assoc
									lk_value
										(+
											mda
											(*
												0.5
												(exp (- (/ mda target_feature_residual)) )
												(+ (* 3 target_feature_residual) mda)
											)
										)
								))

								;surprisal =  lk_value / target_feature_residual
								;Surprisal (surprisal - assumption) = surprisal - 1.5
								;prob of observation = e^(-Surprisal)
								;prob of contribution = 1 - prob of observation
								(-
									1
									(exp (- (- (/ lk_value target_feature_residual) 1.5)))
								)
							))
							mda_map
						)
				))

				(declare (assoc total_probs (apply "+" (values probabilities_of_contribution_map)) ))

				(if total_probs
					;normalize probabilities for use as feature weights
					(map
						(lambda (/ (current_value) total_probs))
						probabilities_of_contribution_map
					)
					;else set them all to 1 because this feature had no affect on others
					(map 1 probabilities_of_contribution_map)
				)
			))

			;iterate over an assoc of MDA maps per feature
			;eg, if there are three features, A[0-10], B[0-100], C[0-1000] with the following mda_matrix of residuals:
			; [
			;  	[0	20	300]
			;	[4	0	100]
			;	[-2	40	0  ]
			; ]
			;it would be transposed into:
			; {
			;	"A"	{ "A" 0   "B" 4   "C" -2 }
			;	"B" { "A" 20  "B" 0   "C" 40 }
			;	"C"	{ "A" 300 "B" 100 "C" 0  }
			; }
			(zip
				features
				;transpose the matrix, so every feature has its own (column) MDA values
				(map
					(lambda (let
						(assoc feature_index (current_index 1))
						(zip
							features
							(map
								(lambda (get (current_value) feature_index))
								mda_matrix
							)
						)
					))
					mda_matrix
				)
			)
		)
	)


	#!ComputeFeatureMAD
	(if (contains_index !nominalsMap feature)
		(let
			(assoc
				counts_map (get !expectedValuesMap (list weight_feature feature "class_counts"))
				total_count 0
			)
			(assign (assoc total_count (apply "+" (values counts_map)) ))


			;nominal MAD is the sum of: each class's probability multiplied by probability of getting it wrong
			(apply "+"
				(map
					(lambda (let
						(assoc class_prob (* (/ (current_value 1) total_count)) )
						(* class_prob (- 1 class_prob))
					))
					(values counts_map)
				)
			)

			;largest possible incorrect probability is 1 - smallest probability
			;	(- 1 (/ (apply "min" (values counts_map)) total_count))

		)

		;else continuous
		(let
			(assoc
				mean_value (get !expectedValuesMap (list weight_feature feature "expected_value"))
				feature_values
					(map
						(lambda (get (current_value) feature))
						(values
							;outputs a list of assoc of feature -> value, [ { feature value1 } { feature value2 } ... ]
							(compute_on_contained_entities (list
								(query_not_equals feature (null))
								(query_exists feature)
							))
						)
					)
				errors (list)
			)

			;list of absolute deviations for the whole dataset
			(assign (assoc
				errors
					(map
						(lambda (abs (- mean_value (current_value))) )
						feature_values
					)
			))

			;Mean Absolute Deviation
			(/ (apply "+" errors) (size errors))
		)
	)

)