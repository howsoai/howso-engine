(null
	#!ComputeResponsibleACValues
	(declare
		(assoc
			action_feature (null)
			focus_features (null)
			features []
		)

		(declare (assoc
			context_features (filter (lambda (not (contains_value (append action_feature focus_features) (current_value)))) features)
			case_features (values (append features (if !tsTimeFeature [".series_index"] [])) .true)
		))

		;create a map of feature -> flag, set to true if the feature has any null values
		;that way there's no need to explicitly filter nulls out when querying for a feature that no nulls
		;or if it's inactive
		(declare (assoc
			ignore_null_action_feature
				(and
					(!= .false (get !featureNullRatiosMap (list action_feature "has_nulls")) )
					(not (contains_index !inactiveFeaturesMap action_feature) )
				)
			;create a backup of context_features for time series flows
			original_context_features (if !tsTimeFeature (replace context_features))
			num_features (size context_features)
		))
		(assign (assoc
			hyperparam_map
				(call !GetHyperparameters (assoc
					context_features features
					weight_feature weight_feature
					use_case_weights use_case_weights
				))
		))

		(call !UpdateCaseWeightParameters)

		(assign (assoc
			k_parameter (get hyperparam_map "k")
			p_parameter (get hyperparam_map "p")
			dt_parameter (get hyperparam_map "dt")
			query_feature_attributes_map (get hyperparam_map "featureDomainAttributes")

			;store an assoc of lag/rate/delta feature -> lag/order amount for time series flows
			ts_feature_lag_amount_map (if !tsTimeFeature (call !BuildTSFeatureLagAmountMap))
		))

		(declare (assoc
			enabled_num_features_probability_map (call !ComputeNumEnabledFeaturesProbabilitiesMap (assoc num_features num_features))
			all_features_map (zip features)
			feature_deviations (get hyperparam_map "featureDeviations")
		))

		(declare (assoc
			case_acs
				||(map
					(lambda (let
						(assoc
							case_id (current_value 1)
							;map of feature -> value for all the case values
							case_values_map (zip case_features (retrieve_from_entity (current_value 1) case_features) )
							time_series_filter_query (list)
							feature_weights (get hyperparam_map "featureWeights")
							context_features context_features
						)
						(declare (assoc case_feature_value (get case_values_map action_feature) ))

						(if !tsTimeFeature
							(assign (assoc
								context_features
									(call !FilterContextsBySeriesIndex (assoc
										all_context_features original_context_features
										series_index (get case_values_map ".series_index")
									))
							))
						)

						(declare (assoc
							;filter out a random number of context features
							react_context_features
								(rand
									context_features
									;number of features to enable is probabilistically weighted
									(if (and !tsTimeFeature (!= (size context_features) num_features))
										(rand
											(call !ComputeNumEnabledFeaturesProbabilitiesMap (assoc num_features (size context_features) ))
										)

										(rand enabled_num_features_probability_map)
									)
									;unique random features (not with replacement)
									.true
								)
						))

						;assoc of all removed features to their residual values, filter the action features to be those that are not context features
						(declare (assoc removed_features_map (remove all_features_map react_context_features) ))

						(if !tsTimeFeature
							(let
								(assoc context_map (keep case_values_map react_context_features) )
								(if (contains_index context_map !tsTimeFeature)
									(assign (assoc time_series_filter_query (call !ComputeTimeSeriesFilterFutureCasesQuery) ))
								)
							)
						)

						;use dynamic deviations subtrainee if present
						(if (get hyperparam_map "subtraineeName")
							(call !UseDynamicDeviationsAndWeights (assoc
								context_features react_context_features
								context_values (unzip case_values_map react_context_features)
								hyperparam_map hyperparam_map
							))
						)

						(declare (assoc
							dependent_queries_list
								;if any of the features being predicted are dependent to any of the contexts, then
								;append all the dependencies together for the query
								(if (and !hasDependentFeatures (size (keep !dependentFeatureMap (indices removed_features_map))) )
									(apply "append" (map
										(lambda
											(call !ComputeDependentQueries (assoc
												context_features react_context_features
												context_values (unzip case_values_map react_context_features)
												action_feature (current_value 1)
											))
										)
										;just the features to be predicted that have dependencies defined
										(indices (keep !dependentFeatureMap (indices removed_features_map)))
									))
								)
						))

						;do a num_reacts_per_case of robust reacts without any of the focus features
						(declare (assoc
							without_focus_features_action_diff
								(call !InterpolateAndComputeDiffToCase (assoc
									candidate_cases_lists
										(if (= 0 (size  react_context_features))
											[[][][]]
											(compute_on_contained_entities
												(query_not_in_entity_list [(replace case_id)])
												(if ignore_null_action_feature (query_not_equals action_feature (null)))
												(if (size context_condition_filter_query) context_condition_filter_query)
												dependent_queries_list
												time_series_filter_query
												(query_nearest_generalized_distance
													k_parameter
													(replace react_context_features)
													(replace (unzip case_values_map react_context_features))
													p_parameter
													feature_weights
													!queryDistanceTypeMap
													query_feature_attributes_map
													feature_deviations
													(null)
													dt_parameter
													(if valid_weight_feature weight_feature(null))
													tie_break_random_seed
													(null) ;radius
													!numericalPrecision
													action_feature
												)
											)
										)
								))
						))

						;append focus features
						(accum (assoc react_context_features focus_features ))
						(assign (assoc removed_features_map (remove removed_features_map focus_features) ))

						(if !tsTimeFeature
							(let
								(assoc context_map (keep case_values_map react_context_features) )
								(if (contains_index context_map !tsTimeFeature)
									(assign (assoc time_series_filter_query (call !ComputeTimeSeriesFilterFutureCasesQuery) ))
								)
							)
						)

						;use dynamic deviations subtrainee if present
						(if (get hyperparam_map "subtraineeName")
							(call !UseDynamicDeviationsAndWeights (assoc
								context_features react_context_features
								context_values (unzip case_values_map react_context_features)
								hyperparam_map hyperparam_map
							))
						)

						;if any of the features being predicted are dependent to any of the contexts, then
						;append all the dependencies together for the query
						(if (and !hasDependentFeatures (size (keep !dependentFeatureMap (indices removed_features_map))) )
							(assign (assoc
								dependent_queries_list
									(apply "append" (map
										(lambda
											(call !ComputeDependentQueries (assoc
												context_features react_context_features
												context_values (unzip case_values_map react_context_features)
												action_feature (current_value 1)
											))
										)
										;just the features to be predicted that have dependencies defined
										(indices (keep !dependentFeatureMap (indices removed_features_map)))
									))
							))
						)

						(declare (assoc
							with_focus_features_action_diff
								(call !InterpolateAndComputeDiffToCase (assoc
									candidate_cases_lists
										(compute_on_contained_entities
											(query_not_in_entity_list [(replace case_id)])
											(if ignore_null_action_feature (query_not_equals action_feature (null)))
											(if (size context_condition_filter_query) context_condition_filter_query)
											dependent_queries_list
											time_series_filter_query
											(query_nearest_generalized_distance
												k_parameter
												(replace react_context_features)
												(replace (unzip case_values_map react_context_features))
												p_parameter
												feature_weights
												!queryDistanceTypeMap
												query_feature_attributes_map
												feature_deviations
												(null)
												dt_parameter
												(if valid_weight_feature weight_feature(null))
												tie_break_random_seed
												(null) ;radius
												!numericalPrecision
												action_feature
											)
										)
								))
						))

						;output a pair of : [ AC for the focus feature, focus values ]
						[
							(-
								without_focus_features_action_diff
								with_focus_features_action_diff
							)
							(unzip case_values_map focus_features)
						]
					))
					case_ids
				)
		))

		;Iterate over the focus features, outputing the responsible values, sorted in order of largest accuracy contribution
		;process each feature in the order of focus_features, such that for each value of feature 1, it outputs the sorted values of feature 2, etc.
		(call !RecursivelyProcessFocusFeatures (assoc
			remaining_focus_features (tail focus_features)
			feature_case_ac_map
				(if (contains_index !nominalsMap (first focus_features))
					(call !ResponsibleNominalAC (assoc
						case_acs
							(map
								(lambda [ (first (current_value 1)) (get (current_value 1) [1 0]) ])
								case_acs
							)
					))
					(call !ResponsibleContinuousAC (assoc
						case_acs
							(map
								(lambda [ (first (current_value 1)) (get (current_value 1) [1 0]) ])
								case_acs
							)
					))
				)
			next_focus_index 1
			feature_indices [0]
			feature_values []
		))
	)

	;sort the class/buckets descending by AC, and output the corresponding values to the class/bucket
	;if there are remaining focus features, process them recursively
	;
	;parameters:
	; feature_case_ac_map: the current feature's case_ac_map of class/bucket -> values
	; remaininy_focus_features: remaining focus features if there were multiple features
	; next_focus_index: the index of the next focus feature (relative to the original focus_features parameter), if there are any remaining focus features
	; feature_indices: list of the previous focus feature indices, if there are remaining focus features
	; feature_values: list of previous focus feature values, if there are remaining focus features
	#!RecursivelyProcessFocusFeatures
	;iterate over the sorted classes/buckets (by descending AC)
	(map
		(lambda
			;sort the classes/buckets of the next remaining feature
			(if (size remaining_focus_features)
				(let
					(assoc
						;flag if current focus feature being processed is continuous
						is_continuous (not (contains_index !nominalsMap (get focus_features (- next_focus_index 1)) ))
					)

					;if this feature is continuous, get the min-max values for this bucket
					(declare (assoc
						previous_feature_values
							(append
								feature_values
								(if is_continuous
									;for continuous accumulate the pair of min/max of values this bucket
									(let
										(assoc
											min (get feature_case_ac_map [(current_value 3) 4 2] )
											max (get feature_case_ac_map [(current_value 3) 4 3] )
										)
										;output as a nested pair to ensure it accumulates to the list as a pair
										[[ min max ]]
									)

									;for nominal accumulate the class value itself
									(current_value 1)
								)
							)
					))

					(declare (assoc
						next_feature_acs
							(map
								(lambda [
									(first (current_value 1))
									(get (current_value 1) [1 next_focus_index])
								])

								(if (> (size previous_feature_values) 1)
									(filter
										(lambda
											(apply "and" (map
												(lambda
													;continuous values will be a pair of [min max] for a value to fall between
													(if (~ [] (first (current_value)))
														(and
															(<= (get (current_value) [0 0] ) (last (current_value)) )
															(>= (get (current_value) [0 1] ) (last (current_value)) )
														)

														;else nominal, must match exactly
														(= (first (current_value)) (last (current_value)))
													)
												)
												;grab the values to filter by
												previous_feature_values
												;grab the values for this case's ac
												(unzip (last (current_value)) feature_indices)
											))
										)
										case_acs
									)

									;same code but optimized for the one current feature
									(if is_continuous
										(filter
											(lambda (and
												;continuous values will be a pair of [min max] for a value to fall between
												(<= (get previous_feature_values [0 0] ) (first (last (current_value))) )
												(>= (get previous_feature_values [0 1] ) (first (last (current_value))) )
											))
											case_acs
										)

										;else optimized if current focus feature is nominal
										(filter
											(lambda
												(= (first previous_feature_values) (first (last (current_value))) )
											)
											case_acs
										)
									)
								)
							)
					))

					(associate
						(current_value 1)
							(call !RecursivelyProcessFocusFeatures (assoc
								remaining_focus_features (tail remaining_focus_features)
								feature_case_ac_map
									(if (contains_index !nominalsMap (first remaining_focus_features))
										(call !ResponsibleNominalAC (assoc case_acs next_feature_acs ))
										(call !ResponsibleContinuousAC (assoc case_acs next_feature_acs ))
									)
								next_focus_index (+ 1 next_focus_index)
								feature_indices (append feature_indices next_focus_index)
								feature_values previous_feature_values
							))
					)
				)

				;else output the AC values for this class/bucket
				(associate (current_value 1) (get feature_case_ac_map (current_value 1) ) )
			)
		)
		;sort classes/buckets by mean AC in descending order
		(sort
			(lambda (<
				(first (get feature_case_ac_map (current_value)))
				(first (get feature_case_ac_map (current_value 1)))
			))
			(indices feature_case_ac_map)
		)
	)

	;given a case_acs for a continuous feature, bin them into buckets by quantiles
	;outputs map of bucket -> values tuple of: [mean, median, min, max]
	;
	;parameters:
	; case_acs: list of pairs of [ ac_value feature_value ]
	#!DetermineContinuousBuckets
	(let
		(assoc
			sorted_unique_values
				;sort is descending order
				(sort
					(lambda (< (current_value) (current_value 1)) )
					(values
						(map (lambda (last (current_value))) case_acs)
						.true
					)
				)
		)

		(declare (assoc
			num_buckets (min 30 (size sorted_unique_values))
			total_num (size sorted_unique_values)
		))

		(declare (assoc
			;num_buckets list of pairs, specifying the min and max percentage range for each bucket.
			;e.g., if there were two buckets, this would output: [ [0 0.5] [0.5 1] ]
			bucket_percent_range_pairs
				(range
					(lambda [
						(* (/ 1 num_buckets) (- (current_index 1) 1))
						(* (/ 1 num_buckets) (current_index 1))
					])
					1 num_buckets 1
				)
		))

		;assoc of bucket -> values tuple of: [mean, median, min, max] of all the unique values that go into that bucket
		(zip
			(range 0 (- num_buckets 1))
			(map
				(lambda (let
					(assoc
						index_quantile_low (floor (* total_num  (first (current_value 1))))
						index_quantile_high (- (floor (* total_num (last (current_value 1)))) 1)
					)
					(declare (assoc
						sorted_bucket_values (unzip sorted_unique_values (range index_quantile_low index_quantile_high))
					))

					;values tuple of [mean, median, min, max]
					[
						(generalized_mean sorted_bucket_values)
						(get
							sorted_bucket_values
							(/ (size sorted_bucket_values) 2)
						)
						;min
						(last sorted_bucket_values)
						;max
						(first sorted_bucket_values)
					]
				))
				bucket_percent_range_pairs
			)
		)
	)

	;output responsible values for a continuous feature
	;output map of bucket -> tuple of: [ mean ac, median ac, min ac, max ac,  [ mean value, median value, min value, max value ] ]
	;
	;parameters:
	; case_acs: list of pairs of [ac_value feature_value ]
	#!ResponsibleContinuousAC
	(map
		(lambda (let
			(assoc
				bucket (current_index 1)
				min (get (current_value 1) 2)
				max (last (current_value 1))
			)

			;all the ac values for this bucket of continuous values inbetween [min, max]
			(declare (assoc
				bucket_acs
					(map
						(lambda (first (current_value)))
						(filter
							(lambda  (and
								(>= (last (current_value)) min)
								(<= (last (current_value)) max)
							))
							case_acs
						)
					)
			))

			;output a tuple of:  [ mean ac, median ac, min ac, max ac [values tuple]]
			[
				(generalized_mean bucket_acs)
				(get (sort bucket_acs) (/ (size bucket_acs) 2))
				(apply "min" bucket_acs)
				(apply "max" bucket_acs)
				;values tuple of [mean, median, min, max]
				(current_value 1)
			]
		))
		(call !DetermineContinuousBuckets)
	)

	;output responsible values for a nominal feature
	;output an assoc of class -> pair [ mean ac, median ac ]
	;
	;parameters:
	; case_acs: list of pairs of [ac_value feature_value ]
	#!ResponsibleNominalAC
	(map
		(lambda
			;output mean and median ac values
			(if (~ [] (current_value))
				[
					(generalized_mean (current_value 1))
					(get (sort (current_value 1)) (/ (size (current_value 1)) 2))
				]

				[ (current_value 1) (current_value 1)]
			)
		)
		;accumulate the AC values for each class to create an assoc of class -> list of ac values
		(zip
			(lambda
				(append (current_value) (current_value 1))
			)
			(map (lambda (last (current_value))) case_acs)
			(map (lambda (first (current_value))) case_acs)
		)
	)

	;assoc of value -> bucket for all unique continuous values
	#!ResponsibleContinuousValueBucketMap
	(apply "append"
	 	(values (map
			(lambda (zip (current_value) (current_index)))
			(call !DetermineContinuousBuckets)
		))
	)

)