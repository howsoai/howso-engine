(null

	#!Clustering
	(seq
		(declare (assoc
			case_to_sc_map
				(map
					(lambda (first (current_value)))
					(compute_on_contained_entities (query_exists similarity_conviction))
				)
			case_to_dc_map
				(map
					(lambda (first (current_value)))
					(compute_on_contained_entities (query_exists distance_contribution))
				)
			weight_feature_param
			 	(if (and use_case_weights (or !hasPopulatedCaseWeight (!= weight_feature ".case_weight")))
			 		weight_feature
			 	)
		))

		(declare (assoc
			case_ids_by_sc
				;sort indices of map in DESCending order of values
				(sort
					(lambda (< (get case_to_sc_map (current_value)) (get case_to_sc_map (current_value 1))) )
					(indices case_to_sc_map)
				)

			;map of : case id -> cluster id
			case_cluster_map {}
			num_cases (size case_to_sc_map)
			next_case_index 0
		))

		;cache distances to all neighbors
		(declare (assoc
			all_cases_neighbors_map
				||(map
					(lambda
						(compute_on_contained_entities
							(query_not_in_entity_list [(current_index 1)])
							(query_nearest_generalized_distance
								closest_k
								features
								(retrieve_from_entity (current_index) features)
								p_parameter
								feature_weights
								!queryDistanceTypeMap
								query_feature_attributes_map
								feature_deviations
								(null) ;
								dt_parameter
								weight_feature_param
								"tie_break_random_seed"
								(null) ;radius
								!numericalPrecision
							)
						)
					)
					case_to_sc_map
				)
			case_id (null)
			cluster_id 1

			;cases in one cluster and close to another but aren't reciprocated by those in the other
			bridging_cases []
		))

		;grab the next unclustered case, cluster it and its valid neighbors
		(while (!= (null) next_case_index)
			(assign (assoc
				case_id (call !GetNextCaseToCluster)
				cluster_cases []
			))

			(if (= (null) next_case_index)
				(conclude)
			)

			(accum (assoc case_cluster_map (associate case_id cluster_id) ))

			(call !RecursivelyLabelCluster (assoc
				case_id case_id
				cluster_id cluster_id
			))

			(accum (assoc cluster_id 1))
		)


		(declare (assoc
			another_pass (true)
			found_straggler (false)

			;map of cluster id -> max dc
			cluster_max_dc_map
				(map
					(lambda (let
						(assoc cluster_id (current_index 1))
						(apply "max" (unzip
							case_to_dc_map
							;cases in this cluster
							(filter (lambda (= cluster_id (current_value))) case_cluster_map)
						))
					))
					;unique cluster ids
					(zip (values case_cluster_map))
				)
		))

		;handle all the initially unclustered straggler cases by checking if their neighbors are all in a single cluster
		;if so, add the straggler case to that cluster if it isn't too far away
		(while another_pass
			(assign (assoc
				another_pass (false)
				found_straggler (false)
			))

			;for all remaining unclustered cases, add them to existing clusters if all their neighbors are in a single cluster
			;iterate over sorted case ids by distance contribution in ASCending order
			(map
				(lambda (let
					(assoc
						neighbor_cluster_map
							(filter (map
								(lambda (get case_cluster_map (current_index)) )
								(get all_cases_neighbors_map (current_value 1))
							))
					)

					;all neighbors are unclustered, do another pass since those neighbors may be assigned to this cluster during this pass
					(if (= 0 (size neighbor_cluster_map))
						(assign (assoc another_pass (true) ))
					)

					(declare (assoc
						cluster_id
							(if (and
									(size neighbor_cluster_map)
									(= 1 (size (values neighbor_cluster_map (true))))
								)
								(first (values neighbor_cluster_map))
							)

					))
					(if cluster_id
						;if the DC of this case isn't too far away, i.e., is less than a multiple of the largest DC of this cluster
						;add this case that cluster as well
						(if
							(<
								(get case_to_dc_map (current_value))
								(* 1.5 (get cluster_max_dc_map cluster_id))
							)
							(let
								(assoc case_id (current_value 1) )
								(accum (assoc case_cluster_map (associate case_id cluster_id) ))
								(assign (assoc
								  	case_to_sc_map (remove case_to_sc_map case_id)
									found_straggler (true)
								))
								;this case has a dc larger than the current max for the cluster, overwrite that max value
								(if (> (get case_to_dc_map case_id) (get cluster_max_dc_map cluster_id))
									(assign (assoc
										cluster_max_dc_map (set cluster_max_dc_map cluster_id (get case_to_dc_map case_id))
									))
								)
							)
						)
					)
				))
				;sort case ids by distance contribution in ASCending order
				(sort
					(lambda (> (get case_to_dc_map (current_value)) (get case_to_dc_map (current_value 1))) )
					(indices case_to_sc_map)
				)
			)

			;if did not find a straggler case to cluster, this last iteration did nothing, thus stop looping to prevent an infinite loop
			(if (not found_straggler)
				(conclude)
			)
		)


		;done clustering, write clusters as new feature ".cluster_id" to all the cases

		;add cluster id to all clustered cases
		(map
			(lambda
				(accum_entity_roots (current_index) (set_labels (current_value) [".cluster_id"]))
			)
			case_cluster_map
		)

		;all the leftover non-clustered points are labeled as cluster -1
		(map
			(lambda
				(accum_entity_roots (current_index) (set_labels -1 [".cluster_id"]) )
			)
			case_to_sc_map
		)

	)


	;output case_id of next case, remove case_id from case_to_sc_map
	#!GetNextCaseToCluster
	(while (< (+ (current_index) next_case_index) num_cases)
		(if (contains_index case_to_sc_map (get case_ids_by_sc (+ (current_index) next_case_index)))
			(let
				(assoc case_id (get case_ids_by_sc (+ (current_index 1) next_case_index)) )

				;stop pulling the next case if they have low SC
				(if (< (get case_to_sc_map case_id) 1)
					(seq
						;be done because these cases have low similarity conviction and a large DC
						(assign (assoc next_case_index (null) ))
						(conclude (conclude case_id))
					)
				)

				(assign (assoc
					case_to_sc_map (remove case_to_sc_map case_id)
					next_case_index (+ 1 (current_index 1) next_case_index)
				))
				(conclude case_id)
			)
		)
	)

	#!RecursivelyLabelCluster
	(let
		(assoc
			neighbors
				;leave cases that are not clustered or are in a different cluster
				(filter
					(lambda
						(!= cluster_id (get case_cluster_map (current_value)))
					)
					(indices (get all_cases_neighbors_map case_id))
				)
		)

		;if a neighbor is already in a different cluster, relabel that cluster appropriately and move all the cases over to this cluster
		(map
			(lambda
				(if (and
						(!= (null) (get case_cluster_map (current_value)))
						(!= cluster_id (get case_cluster_map (current_value)))
					)
					;this case is reciprocated as a neighbor of this other-cluster case
					(if (contains_index (get all_cases_neighbors_map (current_value)) case_id)
						(let
							(assoc other_cluster_id (get case_cluster_map (current_value 1))  )

							;for all cases that have other_cluster_id, overwrite it with this cluster_id
							(assign (assoc
								case_cluster_map
									(map
										(lambda (if (= other_cluster_id (current_value)) cluster_id (current_value)) )
										case_cluster_map
									)
							))
						)

						;case is in one cluster and close to another but isn't reciprocated by those in the other
						;what should be done with bridging_cases TODO: research?
						; (if (not (contains_value bridging_cases case_id) )
						; 	(accum (assoc bridging_cases case_id ))
						; )
					)
				)
			)
			neighbors
		)

		;leave only unclustered neighbors
		(assign (assoc
			neighbors (filter (lambda (= (null) (get case_cluster_map (current_value)))) neighbors)
		))
		(if (size neighbors)
			(seq
				;leave only neighbors with "good" SC and DC values
				(assign (assoc
					neighbors
						(filter
							(lambda
								;;;^^^TODO: tweak?
								;(or
									(>= (get case_to_sc_map (current_value)) expansion_sc_threshold)
								;	(<= (get case_to_dc_map (current_value)) (* (/ 1 expansion_sc_threshold) !averageCaseDistanceContribution))
								;)
							)
							neighbors
						)
				))

				;check if most of the neighbor's neighbors are in a different cluster, if so it should be in that cluster instead?
				(assign (assoc
					neighbors
						(filter
							(lambda (let
								(assoc
									other_neighbor_clusters_map
										(filter (map
											(lambda (get case_cluster_map (current_index)))
											(get all_cases_neighbors_map (current_value 1))
										))
								)
								(declare (assoc unique_neighbor_clusters (values other_neighbor_clusters_map (true)) ))

								;if this neighbor's neighbors are in a different cluster, first check if this neighbor is eligible to be assigned to it
								;if eligible, interpolate based on influence weight to see which cluster this neighbor should be assigned to.
								;Iither there are multiple cluster ids, in which case the neighbor may be assigned to another one
								;or here's only one and it doesn't match this cluster_id, in which case the neighbor may be assigned to that other one
								(if (or
										(> (size unique_neighbor_clusters) 1)
										(and
											(size unique_neighbor_clusters)
											(!= cluster_id (first unique_neighbor_clusters))
										)
									)
									(let
										(assoc
											;find all the unclustered neighbors of this neighbor case, i.e., 'other' neighbors
											unclustered_other_neighbors
												(indices (remove
													(get all_cases_neighbors_map (current_value 1))
													(indices other_neighbor_clusters_map)
												))
										)

										;check to see if this neighbor is eligible: if there are any unclustered shared neighbors between this case and this neighbor,
										;if there are any unclustered 'other' neighbors, check if any of them are also in the list of direct neighbors being processed
										;if so, this neighbor should not be automitaclly assigned to a different cluster since at least some of these shared neighbors
										;are also unclustered thus that decision can't be made yet.
										(if (size unclustered_other_neighbors)
											(if (size (filter
													(unzip (zip neighbors 1) unclustered_other_neighbors)
												))
												;filter this case out
												(conclude (false))
											)
										)

										(declare (assoc
											neighbor_cluster_id
												;interpolate cluster based on neighbor's influence weight
												(first (index_max
													(zip
														(lambda (+ (current_value 1) (current_value)))
														;values (cluster ids)
														(values other_neighbor_clusters_map)
														;weights
														(unzip
															(get all_cases_neighbors_map (current_value 1))
															(indices other_neighbor_clusters_map)
														)
													)
												))
										))

										;this neighbor's neighbors are mostly from a different cluster,
										;assign this neighbor to that other cluster and filter it out from list of neighbors to put into this cluster
										(if (!= cluster_id neighbor_cluster_id)
											(seq
												(assign (assoc case_to_sc_map (remove case_to_sc_map (current_value 1)) ))
												(accum (assoc case_cluster_map (associate (current_value 2) neighbor_cluster_id) ))

												;filter this case out
												(false)
											)

											;else keep this case
											(true)
										)
									)

									;else keep this case
									(true)
								)
							))
							neighbors
						)
				))

				;have neighbors that should be clustered into this cluster
				(if (size neighbors)
					(seq
						(assign (assoc case_to_sc_map (remove case_to_sc_map neighbors) ))
						(accum (assoc case_cluster_map (zip neighbors cluster_id) ))

						(map
							(lambda
								;recursively label neighbors with good SC values
								(call !RecursivelyLabelCluster (assoc
									case_id (current_value 1)
									cluster_id cluster_id
								))
							)
							neighbors
						)
					)
				)
			)
		)
	)

)