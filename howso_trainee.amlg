(null

	;create a return response object in the format of:
	; {
	;	'status' : 'ok', # string 'ok' or 'error'
	;	'errors' : [ {'detail': 'Some error message'} ], # list of error dicts
	;	'warnings' : [ {'detail': 'Some warning message'} ], # list of warning dicts
	;	'payload' : whatever # json response payload
	; }
	;
	;parameters:
	; errors: optional, list of error strings to output
	; warnings: optional, list of warning strings to output
	; payload: any value or object
	#!Return
	(if errors
		(assoc "status" "error"	"errors" (map (lambda (assoc "detail" (current_value 1))) errors) "warnings" (null)	"payload" payload)

		warnings
		(assoc "status" "ok"	"errors" (null) "warnings" (map (lambda (assoc "detail" (current_value 1))) warnings) "payload" payload)

		(assoc "status" "ok"	"errors" (null)	"warnings" (null) 	"payload" payload)
	)

	;returns the total number of training cases
	#get_num_training_cases
	(call !Return (assoc
		payload (assoc "count" (call !GetNumTrainingCases))
	))


	;creates a new instance of a trainee as specified by the entity label "subtrainee"
	;parameters:
	;	subtrainee: name of contained trainee to create
	#create_trainee
	(seq
		(declare (assoc
			child_trainee_path (first (create_entities (list traineeContainer subtrainee) (null)))
		))

		;create a shollow copy (no contained entities, just the trainee data)
		(if (assign_entity_roots child_trainee_path (retrieve_entity_root ) )
			(seq
				(call_entity child_trainee_path "Initialize")
				(call !Return)
			)

			(call !Return (assoc
				errors (list (concat "Failed to create trainee: " subtrainee))
			))
		)
	)

	;Destroyes the instance of the subtrainee specified by the parameter "subtrainee".
	#delete
	(seq
		(destroy_entities (list traineeContainer subtrainee))
		(call !Return)
	)

	;Attempts to load a trainee with the following optional parameters.
	;If a parameter is not specified, it will look to this entity's own label of the same name.
	;If the saved instance does not exist the existing trainee will remain unmodified and the function will return null.
	;assumes loaded trainee filenames need to be escaped
	;returns the trainee name if successful, null if not
	;
	;parameters:
	; filepath: base path to load from
	; filename: name to load (without extension)
	; trainee: name to refer to this instance by
	; separate_files: flag, default to false. if set to true will load each case from its individual file
	#load
	(seq
		(declare (assoc
			loaded_trainee
				(if (and separate_files (= "amlg" !file_extension))
					(seq
						;attempt to load the entity to a temporary label
						(load_entity (concat filepath filename "." !file_extension) (list traineeContainer trainee) (true))
						(if (contains_entity (list traineeContainer trainee))
							trainee
						)
					)

					;else load one flattened entity trainee and parse it out by 'call'ing its code to create all the contained entities
					(let
						(assoc temptrainee (call (load (concat filepath filename "." !file_extension))) )

						(if (and (!= (null) temptrainee) (contains_entity temptrainee))
							(seq
								;destroy the previously existing trainee
								(destroy_entities (list traineeContainer trainee))

								;move the trainee under the temporary label to the trainee label;
								(move_entities temptrainee (list traineeContainer trainee))

								;return the name of the trainee to indicate a successful load attempt
								trainee
							)
						)
					)
				)
		))

		(if loaded_trainee
			(call !Return (assoc payload (assoc "name" loaded_trainee) ))

			(call !Return (assoc errors (list (concat "Failed to load trainee " filename))  ))
		)
	)

	;Saves a subtrainee with the following optional parameters.  If a parameter is not specified, it will look to this entity's own label of the same name.
	;escapes trainee filenames on save
	; filepath: base path to store to
	; filename: name to store (without extension)
	; subtrainee: contained subtrainee instance name to store
	; separate_files: flag, default to false. if set to true will save each case as an individual file
	;returns true on success, false on failure
	#save
	(let
		(assoc
			success
				(if (and separate_files (= "amlg" !file_extension))
					(store_entity (concat filepath filename "." !file_extension) (list traineeContainer subtrainee) (true))

					(store (concat filepath filename "." !file_extension) (flatten_entity (list traineeContainer subtrainee) (false)) )
				)
		)

		(declare (assoc
			trainee_version
				(concat
					(retrieve_from_entity (list traineeContainer subtrainee) "majorVersion") "."
					(retrieve_from_entity (list traineeContainer subtrainee) "minorVersion") "."
					(retrieve_from_entity (list traineeContainer subtrainee) "pointVersion")
				)
			amlg_version (system "version")
		))

		(if success
			(seq
				;outputs a txt file along the saved trainee containing trainee and amalgam versions
				(store
					(concat filepath filename "Version.txt")
					(concat "trainee:" trainee_version "\namalgam:" amlg_version)
				)
				(call !Return)
			)

			(call !Return (assoc errors (list (concat "Failed to save trainee as " filename)) ))
		)
	)

	;creates a copy of a trainee and returns the name of the copied trainee on success
	;parameters:
	; trainee: trainee instance to copy
	; target_trainee: trainee name of copy
	#copy
	(if (not (contains_entity (list traineeContainer target_trainee)))
		(call !Return (assoc
			payload
				(assoc
					"name" (first (clone_entities (list traineeContainer trainee) (list traineeContainer target_trainee) ))
				)
		))

		;else error
		(call !Return (assoc errors (list (concat "Failed to copy: " target_trainee " trainee already exists.")) ))
	)



	;return the list of loaded trainees
	#get_loaded_trainees
	(call !Return (assoc
		payload
			(filter
				(lambda (!= !breeder_manifest (current_value)))
				(contained_entities traineeContainer)
			)
	))

	;set the conviction threshold to (null), used by outside interfaces
	#clear_conviction_thresholds
	(seq
		(assign_to_entities (assoc convictionLowerThreshold (null) convictionUpperThreshold (null)))
		(accum_to_entities (assoc revision 1))
		(call !Return)
	)


	;set the thresholds on the trainee
	; parameters:
	; conviction_lower_threshold : optional lower bond, cases below this won't be trained on
	; conviction_upper_threshold : optional upper bound, cases above this won't be trained on
	#set_conviction_lower_threshold
	(seq
		(assign_to_entities (assoc convictionLowerThreshold conviction_lower_threshold))
		(accum_to_entities (assoc revision 1))
		(call !Return)
	)

	#set_conviction_upper_threshold
	(seq
		(assign_to_entities (assoc convictionUpperThreshold conviction_upper_threshold))
		(accum_to_entities (assoc revision 1))
		(call !Return)
	)


	;set metadata for model
	; parameters:
	; metadata: arbitary metadata to store in a trainee
	#set_metadata
	(seq
		(assign_to_entities (assoc metaData metadata))
		(accum_to_entities (assoc revision 1))
		(call !Return)
	)


	;get metadata for model
	#get_metadata
	(call !Return (assoc payload (retrieve_from_entity "metaData") ))


;returns all the ordered cases from the specified session from the specified trainee
	;parameters:
	; features: list of features to retrieve
	; indicate_imputed: if set to 1 will return the audit data of which features for each row were imputed (auto-filled)
	; session: optional session from which to get cases
	; case_indices: optional, list of pair (list) of session id and index, where index is the original 0-based session_training_index of the
	;		case as it was trained. If specified with session, ignores session.
	; condition: optional a query condition describing the cases to return
	; num_cases: optional, limit on the number of cases to retrieve; If set to zero there will be no limit.
	;		If null, will be set to k if precision is "similar" or no limit if precision is "exact". default is null
	; precision: optional string. default is 'exact', used only with 'condition' parameter, will find exact matches if 'exact' and similar cases if 'similar'.
	#get_cases
	(declare
		(assoc
			features (list)
			indicate_imputed 0
			num_cases (null)
			precision "exact"
		)
		(if indicate_imputed
			(accum (assoc features ".imputed"))
		)

		(call !Return (assoc
			payload
				(call !RetrieveAllCases (assoc
					features features
					case_indices case_indices
					session session
					condition condition
					num_cases num_cases
					precision precision
				))
		))
	)

	;React in a series until a series_stop_map condition is met. Aggregates rows of data corresponding to the specified context, action,
	;derived_context and derived_action features, utilizing previous rows to derive values as necessary. Outputs an assoc of "action_features" and
	;corresponding "series" where "series" is the completed 'matrix' for the corresponding action_features and derived_action_features.
	;
	;parameters: same as #react, except no 'into_series_store' parameter, react_series - specific parameters are listed here:
	; initial_features : optional list of features to condition just the first case in a series, overwrites context_features and
	;		derived_context_features for that first case. All specified initial features must be in one of: context_features, action_features,
	;		derived_context_features or derived_action_features. If provided a value that isn't in one of those lists, it will be ignored.
	; initial_values : optional list of values corresponding to the initial_features, used to condition just the first case in a series.
	; series_stop_map: assoc of feature -> stop conditions:
	;		for continuous features:  { feature:  { "min" : val,  "max": val } } - stops series when feature value exceeds max or is smaller than min
	;		for nominal features:  { feature:  { "values" : ['val1', 'val2' ]} }  - stops series when feature value matches any of the values listed
	;       specifying ".series_progress" with a value between 0 and 1.0 corresponding to percent completion e.g., { ".series_progress" : .95 } -
	;			stops series when it progresses at or beyond 95%.
	; max_series_length: optional, maximum size a series is allowed to be.  Default is 3 * model_size, a 0 or less is no limit.
	; derived_context_features: list of context features whose values should be computed from the entire series in the specified order.
	;		Must be different than context_features.
	; derived_action_features: list of action features whose values should be computed from the resulting last row in series, in the specified
	;		order. Must be a subset of action_features.
	;		Note: both of these derived feature lists rely on the features' "derived_feature_code" attribute to compute the values.
	;		If 'derived_feature_code' attribute is undefined or references non-existing feature indices, the derived value will be null.
	; output_new_series_ids: optional flag, default to True. If true, series ids are replaced with unique values on output.
	;		If False, will maintain or replace ids with existing trained values, but also allows output of series with duplicate existing ids.Â 
	; series_id_tracking : optional string, default "fixed".  Controls how closely generated series should follow existing series (plural).
	;		Choices are: "fixed", "dynamic" or "no". If "fixed", tracks the particular relevant series ID. If "dynamic", tracks the particular
	;		relevant series ID, but is allowed to change the series ID that it tracks based on its current context. If "no", does not track any particular series ID.
	; series_context_values: optional, 2d-list of values, context value for each feature for each row of the series.
	;		If specified, max_series_length is ignored.
	; series_context_features: optional, features corresponding to series_context_values
	; init_time_steps: optional, list of time step values at which to begin synthesis, applicable only for time series
	; final_time_steps:  optional, list time step values at which to end synthesis, applicable only for time series
	; continue_series: optional, flag. Default is false.  When true will attempt to continue existing series instead of starting new series.
	;		If initial_values provide series IDs, it will continue those explicitly specified IDs, otherwise it will randomly select series to continue.
	;		Note: terminated series with terminators cannot be continued and will result in null output.
	; continue_series_values: optional, list of lists of values, when specified will continue this specific untrained series as defined by these values.
	; 		continue_series flag will be ignored and treated as true if this value is specified.
	; continue_series_features: optional, list of features corresponding to the values in each row of continue_series_values.
	; 		This value is ignored if continue_series_values is not specified.
	#react_series
	(declare
		(assoc
			initial_features (list)
			initial_values (list)
			series_stop_map (assoc)
			output_new_series_ids (true)
			series_id_tracking "fixed"
			continue_series (false)
			continue_series_features (null)
			continue_series_values (null)

			context_features (list)
			context_values (list)
			action_features (list)
			action_values (list)
			derived_action_features (list)
			derived_context_features (list)
			series_context_features (list)
			series_context_values (list)
			extra_audit_features (list)
			case_access_count_label ""
			use_case_weights (false)
			weight_feature ".case_weight"

			;generate react specific parameters:
			use_regional_model_residuals (true)
			feature_bounds_map (assoc)
			preserve_feature_values (list)
			new_case_threshold "min"
			substitute_output (true)
			input_is_substituted (false)
		)

		(declare (assoc invalid_react_parameters (null)))

		(if series_stop_map
			(assign (assoc
				invalid_react_parameters
					(call ValidateSeriesStopMaps (assoc
						series_stop_maps (list series_stop_map)
						feature_bounds_map feature_bounds_map
					))
			))
		)

		(if invalid_react_parameters
			(conclude
				(call !Return (assoc
					errors (list (concat "Failed to react_series: invalid stopping condition specified for " invalid_react_parameters) )
				))
			)
		)

		;Don't allow duplicates/overlap of context features by checking if all the context features appended
		;together are more than just the uniques between them
		(if (>
				(size (append initial_features context_features series_context_features))
				(size (values (append initial_features context_features series_context_features) (true) ))
			)
			(conclude
				(call !Return (assoc
					errors (list "There must not be overlap between features specified in initial_features, context_features, and/or series_context_features.")
				))
			)
		)

		(declare (assoc
			time_series_prep_map
				;prep time series parameters if it's a time series model
				(if tsTimeFeature
					(call PrepTimeSeriesFeatures (assoc
						init_time_steps init_time_steps
						final_time_steps final_time_steps
						;wrap initial_values and series_stop_maps in lists since that's the format PrepTimeSeriesFeatures expects
						initial_values (if (size initial_values) (list initial_values) (list) )
						series_stop_maps (if (size series_stop_map) (list series_stop_map) )
						continue_series_values (if (size continue_series_values) (list continue_series_values) )
						continue_series_features continue_series_features
						;singular series
						n_samples 1
						context_features context_features
						series_context_features series_context_features
						initial_features initial_features
						derived_context_features derived_context_features
						derived_action_features derived_action_features
						single_series (true)
						output_new_series_ids output_new_series_ids
						series_id_tracking series_id_tracking
					))
				)
			output_features action_features
		))

		(call !ValidateDerivedActionFeaturesIsSubset)

		;if the preparation output is an assoc of variables, overwrite local parameters with these resulting values
		(if (= (assoc) (get_type time_series_prep_map))
			(assign time_series_prep_map)

			;if it's a string, return it as an error
			(= "" (get_type time_series_prep_map))
			(conclude (call !Return (assoc errors (list time_series_prep_map))) )
		)

		;if user passed in a series for continuing, create a temporary trainee to derive all the necessary values (lags, deltas, etc.)
		;and then overwrite the passed continue_series_values with the additonal derived feature values
		(if (size continue_series_values)
			(seq
				(if (= 0 (size continue_series_features))
					(conclude (conclude
						(call !Return (assoc
							errors (list "continue_series_values is provided without continue_series_features, please specify continue_series_features")
						))
					))
				)

				(declare (assoc trainee_clone (first (create_entities (null))) ))

				;create a shollow copy (no contained entities, just the trainee data)
				(assign_entity_roots trainee_clone (retrieve_entity_root ) )

				;train and derive all the lags and other features as necessary
				(call_entity trainee_clone "Train" (assoc
					input_cases continue_series_values
					features continue_series_features
					session "temp"
					input_is_substituted input_is_substituted
				))

				;include imputed features at the end
				(assign (assoc
					continue_series_features
						(append (retrieve_from_entity trainee_clone "defaultFeatures") (retrieve_from_entity trainee_clone "internalLabelImputed"))
				))

				(assign (assoc
					;explicitly set the continue_series flag to true since values are provided
					continue_series (true)
					continue_series_values
						(get
							(call_entity trainee_clone "!RetrieveAllCases" (assoc
								features continue_series_features
								session "temp"
							))
							"cases"
						)
				))

				(declare (assoc
					time_feature_index
						(get
							(zip continue_series_features (indices continue_series_features))
							(retrieve_from_entity "tsTimeFeature")
						)
				))

				;sort the passed in data by the time feature to ensure its order
				(assign (assoc
					continue_series_values
						(call_entity trainee_clone "MultiSortList" (assoc
							data continue_series_values
							column_order_indices (list time_feature_index)
						))
				))

				(destroy_entities trainee_clone)
			)
		)

		(call !Return
			(call ReactSeries (assoc
				initial_features initial_features
				initial_values initial_values
				series_stop_map series_stop_maps
				max_series_length max_series_length
				output_new_series_ids output_new_series_ids
				output_features output_features
				continue_series continue_series
				continue_series_features continue_series_features
				continue_series_values continue_series_values

				context_features context_features
				context_values context_values
				action_features action_features
				action_values action_values
				derived_action_features derived_action_features
				derived_context_features derived_context_features
				series_context_features series_context_features
				series_context_values series_context_values
				details details
				extra_audit_features extra_audit_features
				case_access_count_label case_access_count_label
				ignore_case ignore_case
				case_indices case_indices
				substitute_output substitute_output
				input_is_substituted input_is_substituted
				use_case_weights use_case_weights
				weight_feature weight_feature
				rand_seed rand_seed
				leave_case_out leave_case_out

				desired_conviction desired_conviction
				use_regional_model_residuals use_regional_model_residuals
				feature_bounds_map feature_bounds_map
				ordered_by_specified_features ordered_by_specified_features
				exclude_novel_nominals_from_uniqueness_check exclude_novel_nominals_from_uniqueness_check
				generate_new_cases generate_new_cases
				preserve_feature_values preserve_feature_values
				new_case_threshold new_case_threshold
			))
		)
	)


	;Run react_series in a batch, output a list of outputs from each individual react_series.
	;
	;parameters:  same as #react_series, unless listed here
	; rand_seed - optional, see #react for description.
	; series_context_values: optional, 3d-list of values, context value for each feature for each row of a series.
	;		If specified max_series_lengths are ignored.
	; init_time_steps: optional, time step value at which to begin synthesis, applicable only for time series.
	; final_time_steps: optional, time step value at which to end synthesis, applicable only for time series.
	; num_series_to_generate: optional, total number of series to generate, for generative reacts.
	;
	;	 All of the following parameters, if specified, must be either length of 1 or equal to the length of
	;	context_values/case_indices for discriminative reacts, and num_series_to_generate for generative reacts.
	;
	; initial_values - list of lists. see #react_series for description.
	; series_stop_maps - list of assocs. see #react_series for description.
	; max_series_lengths - list of values. see #react_series for description.
	; action_values - list of lists.  see #react for description.
	; continue_series_values - list of lists. see #react_series for description.
	#batch_react_series
	(declare
		(assoc
			initial_features (list)
			initial_values (list)
			series_stop_maps (list)
			max_series_lengths (null)
			output_new_series_ids (true)
			series_id_tracking "fixed"
			continue_series (false)
			continue_series_features (null)
			continue_series_values (null)

			context_features (list)
			action_features (list)
			derived_context_features (list)
			derived_action_features (list)
			series_context_features (list)
			series_context_values (list)
			extra_audit_features (list)
			case_access_count_label ""
			use_case_weights (false)
			weight_feature ".case_weight"

			;generate react specific parameters:
			use_regional_model_residuals (true)
			feature_bounds_map (assoc)
			preserve_feature_values (list)
			new_case_threshold "min"
			substitute_output (true)
			input_is_substituted (false)
		)

		;determine number of reacts to batch
		(declare (assoc
			num_reacts
				(max
					1
					(if (!= (null) desired_conviction)
						num_series_to_generate

						(!= (null) context_values)
						(size context_values)

						(!= (null) case_indices)
						(size case_indices)

						(!= (list) initial_values)
						(size initial_values)

						(!= (null) continue_series_values)
						(size continue_series_values)
					)
				)
			invalid_react_parameters (false)
		))

		(call !ValidateBatchReactParameter (assoc param context_values))
		(call !ValidateBatchReactParameter (assoc param case_indices))
		(call !ValidateBatchReactParameter (assoc param action_values))

		(call !ValidateBatchReactParameter (assoc param initial_values))
		(call !ValidateBatchReactParameter (assoc param series_stop_maps))
		(call !ValidateBatchReactParameter (assoc param max_series_lengths))

		(if (and (!= (null) rand_seed) (!= num_reacts (size rand_seed)) )
			(assign (assoc invalid_react_parameters (true)))
		)

		(if invalid_react_parameters
			(conclude
				(call !Return (assoc errors (list "Failed to react_series: invalid react parameters.") ))
			)
		)

		(if series_stop_maps
			(assign (assoc
				invalid_react_parameters
					(call ValidateSeriesStopMaps (assoc
						series_stop_maps series_stop_maps
						feature_bounds_map feature_bounds_map
					))
			))
		)

		(if invalid_react_parameters
			(conclude
				(call !Return (assoc
					errors (list (concat "Failed to react_series: invalid stopping condition specified for " invalid_react_parameters) )
				))
			)
		)

		;Don't allow duplicates/overlap of context features by checking if all the context features appended
		;together are more than just the uniques between them
		(if (>
				(size (append initial_features context_features series_context_features))
				(size (values (append initial_features context_features series_context_features) (true) ))
			)
			(conclude
				(call !Return (assoc
					errors (list "There must not be overlap between features specified in initial_features, context_features, and/or series_context_features.")
				))
			)
		)

		(declare (assoc
			time_series_prep_map
				;prep time series parameters if it's a time series model
				(if tsTimeFeature
					(call PrepTimeSeriesFeatures (assoc
						init_time_steps init_time_steps
						final_time_steps final_time_steps
						n_samples num_reacts
						context_features context_features
						series_context_features series_context_features
						initial_features initial_features
						initial_values initial_values
						series_stop_maps series_stop_maps
						derived_context_features derived_context_features
						derived_action_features derived_action_features
						output_new_series_ids output_new_series_ids
						series_id_tracking series_id_tracking
						continue_series_features continue_series_features
						continue_series_values (if (size continue_series_values) continue_series_values)
					))
				)
			output_features action_features
		))

		(call !ValidateDerivedActionFeaturesIsSubset)

		;if the preparation output is an assoc of variables, overwrite local parameters with these resulting values
		(if (= (assoc) (get_type time_series_prep_map))
			(assign time_series_prep_map)

			;if it's a string, return it as an error
			(= "" (get_type time_series_prep_map))
			(conclude (call !return (assoc errors (list time_series_prep_map))) )
		)

		;if user passed in a series for continuing, create a temporary trainee to derive all the necessary values (lags, deltas, etc.)
		;and then overwrite the passed continue_series_values with the additonal derived feature values
		(if (size continue_series_values)
			(let
				(assoc
					original_continue_series_features continue_series_features
					imputed_list_feature (retrieve_from_entity "internalLabelImputed")
					time_feature_index 0
					time_feature (retrieve_from_entity "tsTimeFeature")
				)

				(if (= 0 (size continue_series_features))
					(conclude (conclude
						(call !Return (assoc
							errors (list "continue_series_values is provided without continue_series_features, please specify continue_series_features")
						))
					))
				)

				(assign (assoc
					;explicitly set the continue_series flag to true since values are provided
					continue_series (true)
					continue_series_values
						(map
							(lambda (let
								(assoc continue_values (current_value 1) )
								(declare (assoc trainee_clone (first (create_entities (null))) ))

								;create a shallow copy (no contained entities, just the trainee data)
								(assign_entity_roots trainee_clone (retrieve_entity_root ) )

								;train and derive all the lags and other features as necessary
								(call_entity trainee_clone "Train" (assoc
									input_cases continue_values
									features original_continue_series_features
									session "temp"
									input_is_substituted input_is_substituted
								))

								(assign (assoc
									continue_series_features
										(append (retrieve_from_entity trainee_clone "defaultFeatures") imputed_list_feature)
								))

								(assign (assoc
									continue_values
										(get
											(call_entity trainee_clone "!RetrieveAllCases" (assoc
												features continue_series_features
												session "temp"
											))
											"cases"
										)
									time_feature_index
										(get
											(zip continue_series_features (indices continue_series_features))
											time_feature
										)
								))

								;sort the passed in data by the time feature to ensure its order
								(assign (assoc
									continue_values
										(call_entity trainee_clone "MultiSortList" (assoc
											data continue_values
											column_order_indices (list time_feature_index)
										))
								))

								(destroy_entities trainee_clone)

								continue_values
							))
							continue_series_values
						)
				))
			)
		)

		(call !Return
			(call BatchReactSeries (assoc
				initial_features initial_features
				initial_values initial_values
				series_stop_maps series_stop_maps
				max_series_lengths max_series_lengths
				output_new_series_ids output_new_series_ids
				series_id_tracking series_id_tracking
				output_features output_features
				continue_series continue_series
				continue_series_features continue_series_features
				continue_series_values continue_series_values

				context_features context_features
				context_values context_values
				action_features action_features
				action_values action_values
				derived_action_features derived_action_features
				derived_context_features derived_context_features
				series_context_features series_context_features
				series_context_values series_context_values
				details details
				extra_audit_features extra_audit_features
				case_access_count_label case_access_count_label
				ignore_case ignore_case
				case_indices case_indices
				substitute_output substitute_output
				input_is_substituted input_is_substituted
				use_case_weights use_case_weights
				weight_feature weight_feature
				rand_seed rand_seed
				leave_case_out leave_case_out
				num_reacts num_reacts

				desired_conviction desired_conviction
				use_regional_model_residuals use_regional_model_residuals
				feature_bounds_map feature_bounds_map
				ordered_by_specified_features ordered_by_specified_features
				exclude_novel_nominals_from_uniqueness_check exclude_novel_nominals_from_uniqueness_check
				generate_new_cases generate_new_cases
				preserve_feature_values preserve_feature_values
				new_case_threshold new_case_threshold
			))
		)
	)

	;TODO: between trainees? in-between trainees?
	#batch_react_group (null)

	;TODO: still needed?
	#simplify_model (null)
	#forget_irrelevant_data (null)


	;automatically analyze the model using stored parameters from previous analyze calls
	#auto_analyze
	(let
		(assoc saved_analyze_parameters_map (retrieve_from_entity "savedAnalyzeParameterMap"))

		;if this is called before regular analyze, analyze the model as targetless
		(if (= (null) saved_analyze_parameters_map)
			(call analyze (assoc
				context_features (retrieve_from_entity "defaultFeatures")
				analyze_level 2
			))

			;else call analyze with stored parameters
			(seq
				;if analysis should recalculate residuals, clear them from cache so they'll be overwritten
				(if (or
						(> (get saved_analyze_parameters_map "analyze_level") 1)
						(= (false) (get saved_analyze_parameters_map "bypass_calculate_feature_residuals"))
					)
					;iterate over hyperparameter_map and clear out weights and deviations for all
					(call UpdateHyperparameterMapFeatureParameter (assoc
						targeted_model "all"
						attribute_map
							(assoc
								"featureWeights" (null)
								"useDeviations" (false)
								"featureDeviations" (null)
								"allFeatureResidualsCached" (false)
							)
						use_case_weights (= (true) (get saved_analyze_parameters_map "use_case_weights"))
						weight_feature (get saved_analyze_parameters_map "weight_feature")
					))
				)
				(call analyze saved_analyze_parameters_map)
			)
		)
	)


	;Analyzes the data to compute the appropriate statistics, uncertainties, and select parameters as appropriate.
	;parameters:
	; context_features: list of context features to analyze for
	; action_features: list of action features to analyze for. applicable only to 'single_targeted' mode
	; k_folds: optional, (defaults to 6) number of cross validation folds to do. value of 1 does hold-one-out instead of k-fold
	; k_folds_by_indices : optional flag, default is false. if set to true will do k_folds ordered by session id indices, i.e., it'll hold out the
	;			first 1/6th of the trained cases, then the next 1/6th, etc. in the order they were trained.
	;			NOTE: if the dataset has been edited or has multiple trained sessions, the holdouts may be imbalanced due to multiple cases having
	;			the same session id index or missing session indices, therefore this flag should only be used internally for validation
	; bypass_hyperparameter_analysis : optional
	; bypass_calculate_feature_residuals : optional
	; bypass_calculate_feature_weights : optional
	; use_deviations: optional, default is null, will auto-determine whether to use deviations for LK metric in queries. When true forces the use
	;			of deviations , when false will not use deviations.
	; num_samples: used in calculating feature residuals
	; k_values: optional list used in hyperparameter search
	; p_values: optional list used in hyperparameter search
	; dt_values: optional list used in hyperparameter search
	; analyze_level: optional value, if specified will analyze for the following flows:
	;			1: predictions/accuracy (hyperparameters, by default does not analyze for p=0)
	;			2: data synth (level 1 + cache: global residuals)
	;			3: standard explanations (level 1 + cache: case prediction conviction)
	;			4: full analysis (levels 1,2,3 + cache: model feature prediction conviction)
	; targeted_model: enumeration, default is "single_targeted"
	;   "single_targeted" = analyze hyperparameters for the specified action_features
	;   "omni_targeted" = analyze hyperparameters for each action feature, using all other features as context_features. if action_features aren't specified, uses all context_features.
	;   "targetless" = analyze hyperparameters for all context features as possible action features, ignores action_features parameter
	; num_analysis_samples : optional. number of cases to sample during analysis. only applies for k_folds = 1
	; analysis_sub_model_size: optional. number of samples to use for analysis. the rest will be randomly held-out and not included in calculations
	; inverse_residuals_as_weights: optional, default is null, will be set to false for targeted and true for targetless
	;			when true will forcibly compute and use inverse of residuals as feature weights
	; use_case_weights: optional, default is false. when true will scale influence weights by each case's weight_feature weight
	; weight_feature: optional, default '.case_weight'.  name of feature whose values to use as case weights
	;
	; returns success when completed
	#analyze
	(declare
		(assoc
			context_features (list)
			action_features (list)
			k_folds 1
			weight_feature ".case_weight"
			use_case_weights (false)
			inverse_residuals_as_weights (null)
		)

		(if use_case_weights
			;CreateCaseWeights will find all cases missing weight_feature, then initialize
			;weight_feature with a value of 1.0 for each
			(call CreateCaseWeights (assoc
				feature_name weight_feature
			))
		)

		;if k_folds is not a number value, or it's less than 1, ensure that it's overwritten with the default value
		(if (or (not (= "number" (get_type_string k_folds))) (< k_folds 1))
			(assign (assoc k_folds 1))
		)

		(declare (assoc num_cases (call !GetNumTrainingCases)))

		;cap max k_folds to the number of cases in the model
		(if (> k_folds num_cases)
			(assign (assoc k_folds num_cases))
		)

		;save the parameters that analyze was called with
		(assign_to_entities (assoc
			savedAnalyzeParameterMap
				(assoc
					"context_features" context_features
						"action_features" action_features
						"k_folds" k_folds
						"k_folds_by_indices" k_folds_by_indices
						"bypass_hyperparameter_analysis" bypass_hyperparameter_analysis
						"bypass_calculate_feature_residuals" bypass_calculate_feature_residuals
						"bypass_calculate_feature_weights" bypass_calculate_feature_weights
						"use_deviations" use_deviations
						"num_samples" num_samples
						"k_values" k_values
						"p_values" p_values
						"dt_values" dt_values
						"analyze_level" analyze_level
						"targeted_model" targeted_model
						"num_analysis_samples" num_analysis_samples
						"analysis_sub_model_size" analysis_sub_model_size
						"inverse_residuals_as_weights" inverse_residuals_as_weights
						"use_case_weights" use_case_weights
						"weight_feature" weight_feature
				)
		))

		;prediction/accuracy: hyperparameters only
		(if (= 1 analyze_level)
			(assign (assoc
				bypass_hyperparameter_analysis (false)
				bypass_calculate_feature_residuals (true)
				bypass_calculate_feature_weights (false)
			))

			;data synth, hyperparameters + model residuals
			(= 2 analyze_level)
			(assign (assoc
				bypass_hyperparameter_analysis (false)
				bypass_calculate_feature_residuals (false)
				bypass_calculate_feature_weights (true)
			))

			;explanations, hyperparameters + case prediction conviction
			(= 3 analyze_level)
			(assign (assoc
				bypass_hyperparameter_analysis (false)
				bypass_calculate_feature_residuals (true)
				bypass_calculate_feature_weights (false)
			))

			;full analysis: everything
			(= 4 analyze_level)
			(assign (assoc
				bypass_hyperparameter_analysis (false)
				bypass_calculate_feature_residuals (false)
				bypass_calculate_feature_weights (false)
			))
		)

		(declare (assoc holdout_entity_name (null) ))

		;if user specified how many samples to use for analysis, randomly hold out the rest
		(if (!= (null) analysis_sub_model_size)
			(let
				(assoc model_size (call !GetNumTrainingCases))

				;analysis_sub_model_size must be at least 2 * number of k_folds otherwise there may be no cases in a fold
				(if (< analysis_sub_model_size (* 2 k_folds))
					(assign (assoc analysis_sub_model_size (* 2 k_folds)))
				)

				(if (> model_size analysis_sub_model_size)
					(assign (assoc
						holdout_entity_name (call HoldOutRandomCases (assoc num_samples (- model_size analysis_sub_model_size)))
					))
				)
			)
		)

		;if no action features were specified, and neither was targeted_model, set it to targetless
		(if (and
				(= 0 (size action_features))
				(or
					(= (null) targeted_model)
					(= "single_targeted" targeted_model)
				)
			)
			(assign (assoc targeted_model "targetless"))

			;else one or more action features specified but targeted_model wasn't, set it to single_targeted
			(and
				(>= 1 (size action_features))
				(= (null) targeted_model)
			)
			(assign (assoc targeted_model "single_targeted"))

			;if omni_targeted and didn't provide action_features, assume all features are action features
			(and
				(= "omni_targeted" targeted_model)
				(= 0 (size action_features))
			)
			(assign (assoc action_features context_features))

			;default is targetless if inputs are bad
			(not (contains_value (list "targetless" "single_targeted" "omni_targeted") targeted_model))
			(assign (assoc targeted_model "targetless"))
		)


		;if the bypass hyperparameter analysis flag is null or is false, analyze hyper parameters
		(if (not bypass_hyperparameter_analysis)
			(call Analyze (assoc
				context_features context_features
				action_features action_features
				k_folds k_folds
				k_values k_values
				p_values p_values
				dt_values dt_values
				use_deviations use_deviations
				k_folds_by_indices k_folds_by_indices
				targeted_model targeted_model
				num_analysis_samples num_analysis_samples
				inverse_residuals_as_weights inverse_residuals_as_weights
				residual_num_samples (if (> num_samples 0) num_samples 200)
				use_case_weights use_case_weights
				weight_feature weight_feature
			))
		)

		;only calculate feature residuals if they aren't being bypassed and haven't been calculated above
		(if (and
				(= (false) bypass_calculate_feature_residuals)
				(or bypass_hyperparameter_analysis (!= "targetless" targeted_model))
			)
			(let
				(assoc
					;remove possible duplicates from all_features while mantaining order of features
					all_features (values (append context_features action_features) (true))
				)

				;for targetless flows, there are no action features, so use ".targetless" as the hyperparameter action feature
				(if (= "targetless" targeted_model)
					(assign (assoc action_features (list ".targetless" )))
				)

				(map
					(lambda
						(call CalculateAndStoreFeatureResiduals (assoc
							features all_features
							;default the num_samples to 1000
							num_samples (if (> num_samples 0) num_samples 1000)
							robust_residuals (= "targetless" targeted_mode)
							;use the specific action feature's hyperparameters
							hyperparameter_feature (current_value 1)
							weight_feature weight_feature
							use_case_weights use_case_weights
						))
					)
					action_features
				)
			)
		)

		(if holdout_entity_name
			(call RestoreHeldOutCases (assoc holdout_entity_name holdout_entity_name))
		)

		(accum_to_entities (assoc revision 1))

		(call !Return)
	)


	;returns cached feature prediction stats for all features in the format of feature -> assoc stat -> value
	;parameters are optional, when not specified will output all stats, when specified will attempt to
	;output the cached stats best matching the requested parameters, null if none match.
	;
	;parameters:
	; stats: list of strings, optional.  Allowed values are:
	;	"mda" : mean decrease in accuracy when each feature is dropped from the model, applies to all features.
	;	"contribution": feature contribution to predicted value when each feature is dropped from the model, applies to all features.
	;	"mda_permutation": mean decrease in accuracy that used scrambling of feature values instead of dropping each feature, applies to all features.
	;	"mae" : Mean absolute error. For continuous features, this is calculated as the mean of absolute values of the difference
    ;		between the actual and predicted values. For nominal features, this is 1 - the average categorical action probability of each case's
    ;		correct classes. Categorical action probabilities are the probabilities for each class for the action feature.
	;	"r2": r-squared coefficient of determination, for continuous features only.
	;	"rmse": root mean squared error, for continuous features only.
	;	"spearman_coeff": Spearman's rank correlation coefficient, for continuous features only.
	;	"precision": precision (positive predictive) value for nominal features only.
	;	"recall": recall (sensitivity) value for nominal features only.
	;	"accuracy": The number of correct predictions divided by the total number of predictions.
	;   "confusion_matrix": A matrix showing the number of predicted values of each class
	;                       for each unique value of the predicted feature.
	;
	; robust: flag, optional. if specified will attempt to return stats that were computed with the specified robust or non-robust type.
	; action_feature: string, optional. if specified will attempt to return stats that were computed for this specified action_feature.
	;				  Note: ".targetless" is the action feature used during targetless analysis.
	; robust_hyperparameters: flag, optional. if specified, will attempt to return stats that were computed using hyperpparameters with the
	;						  specified robust or non-robust type.
	; weight_feature: string, optional. if specified, will attempt to return stats that were computed using this weight_feature.
	; condition: assoc of feature->value(s)
	;		no value = must have feature
	;   	- for continuous or numeric ordinal features:
	;			one value = must equal exactly the value or be close to it for fuzzy match
	;			two values = inclusive between
	;   	- for nominal or string ordinal features:
	;			n values = must match any of these values exactly
	; precision: optional string,  default is 'exact', used only with 'condition' parameter, will find exact matches if 'exact' and similar cases if 'similar'.
	; num_cases: optional, limit on the number of cases to use in calculating conditional prediction stats; If set to zero there will be no limit.
	;		If null, will be set to k if precision is "similar" or no limit if precision is "exact". default is null
	; num_robust_influence_samples_per_case: optional, Specifies the number of robust samples to use for each case for robust contribution computations.
	;				  Defaults to 300 + 2 * (number of features).
	#get_prediction_stats
	(declare
		(assoc
			stats (list)
			robust (null)
			action_feature (null)
			robust_hyperparameters (null)
			weight_feature (null)
			condition (null)
			precision "exact"
			num_cases (null)
		)

		;if there are specified stats remaining after all the supported stats have been removed, that means unsupported ones were provided
		(if (> (size (remove (zip stats) supportedPredictionStats)) 0)
			(conclude
				(call !Return (assoc
					errors
						(list (concat
							"Specified an unsupported stat. Supported stats are: "
							(apply "concat" (trunc (weave supportedPredictionStats ", ")))
						))
				))
			)
		)

		(call !Return
			(if (= condition (null))
				(call GetFeaturePredictionStats (assoc
					stats stats
					robust robust
					action_feature action_feature
					robust_hyperparameters robust_hyperparameters
					weight_feature weight_feature
				))

				;else condition is present
				(call CalculateConditionalPredictionStats (assoc
					stats stats
					robust robust
					action_feature action_feature
					robust_hyperparameters robust_hyperparameters
					weight_feature weight_feature
					condition condition
					precision precision
					num_cases num_cases
					num_robust_influence_samples_per_case num_robust_influence_samples_per_case
				))
			)
		)
	)

	;set the random seed on a trainee
	; parameters:
	; seed : optional, the value of the random seed to set on the trainee, defaults to a system-provided 64-bit random number
	#set_random_seed
	(declare
		(assoc
			seed (system "rand" 16)
		)

		(set_entity_rand_seed (null) seed)
		(accum_to_entities (assoc revision 1))
		(call !Return)
	)

	;set the minimum size of the model before ablatement kicks in, value must be above 0
	#set_min_ablatement_model_size
		(if (> min_ablatement_model_size 0)
			(seq
				(assign_to_entities (assoc minAblatementModelSize min_ablatement_model_size))
				(accum_to_entities (assoc revision 1))
				(call !Return)
			)

			(call !Return (assoc errors (list "Failed to set min ablatement size: invalid min_ablatement_model_size specified.")))
		)


	;set the influence weight threshold for outputting only the K neighbors whose inflence weight is <= to this threshold
	;default value is 0.99
	#set_influence_weight_threshold
		(seq
			(assign_to_entities (assoc influenceWeightThreshold influenceWeightThreshold))
			(accum_to_entities (assoc revision 1))
			(call !Return)
		)






)