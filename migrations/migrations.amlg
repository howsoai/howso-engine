;custom code for conversions that need to be done for a specifid core version, assuming the upgrade is from the previous one
;that way if a trainee has to be upgraded several versions, it will execute all the intermediary conversions in order
(lambda (assoc

"0.0.0"
	;all previous trainee labels are accessed via 'import_metadata_map'
	(seq (print "Version 0.0.0: This code can access and do any operations on contained entity 'trainee'.\n") )

"100.1.1"
	(call !UpdateDefinedFeatures)
"106.0.0"
	(seq
		;method to convert old derived code to new format
		;eg: "(+ #feat_a 0  #feat_b 2)" converts to "(+ (call value {feature \"feat_a\"}) (call value {feature \"feat_b\" lag 2}) )"
		(declare (assoc
			update_code_method
				(lambda (let
					;create an assoc of feature -> lag value
					(assoc feature_lag_map (get_all_labels (parse code_string)) )
					(unparse
						(rewrite
							(lambda (let
								(assoc label (first (get_labels (current_value 1))) )

								;if this node is a label, replace it with the new code that is in the format  (call value {feature feature lag lag_value})
								(if (contains_index feature_lag_map label)
									(parse (concat
										"(call value {feature \"" label
										(if (> (get feature_lag_map label) 0)
											(concat "\" lag " (get feature_lag_map label) )
											"\""
										)
										" })"
									))
									(current_value)
								)
							))
							(parse code_string)
						)
					)
				))
		))

		;overwrite all the derived code in feature attributes by calling the update_code_method on any code that is found
		(assign_to_entities (assoc
			!featureAttributes
				(map
					(lambda (if
						;rewrite old label-based code into the method-based format
						(or
							(!= (null) (get (current_value) ["auto_derive_on_train" "code"]))
							(!= (null) (get (current_value) "derived_feature_code"))
							(!= (null) (get (current_value) "post_process"))
						)
						(let
							(assoc attributes (current_value 1))
							(if (!= (null) (get attributes ["auto_derive_on_train" "code"]))
								(assign (assoc
									attributes
										(set
											attributes
											["auto_derive_on_train" "code_features"]
												(indices (get_all_labels
													(parse (get attributes ["auto_derive_on_train" "code"]))
												))
											["auto_derive_on_train" "code"]
												(call update_code_method (assoc
													code_string (get attributes ["auto_derive_on_train" "code"])
												))
										)
								))
							)
							(if (!= (null) (get attributes "derived_feature_code"))
								(assign (assoc
									attributes
										(set
											attributes
											"code_features"
												(indices (get_all_labels
													(parse (get attributes "derived_feature_code"))
												))
											"derived_feature_code"
												(call update_code_method (assoc
													code_string (get attributes "derived_feature_code")
												))
										)
								))
							)
							(if (!= (null) (get attributes "post_process"))
								(assign (assoc
									attributes
										(set attributes "post_process"
											(call update_code_method (assoc
												code_string (get attributes "post_process")
											))
										)
								))
							)
							attributes
						)

						;else leave attributes alone
						(current_value)
					))
					!featureAttributes
				)
		))
	)
"106.0.1"
	(seq
		;refactors time series built-in features
		(if !tsTimeFeature
			(let
				(assoc
					;original trained features are all the non built-in features that don't start with a period
					features (filter (lambda (!= "." (first (current_value)))) !trainedFeatures)
				)
				;re-assign feature attributes to create the synchronous counter feature attributes
				(call set_feature_attributes (assoc
					feature_attributes
						(keep
							(get (call get_feature_attributes) (list 1 "payload"))
							features
						)
				))

				;remove the no-longer used ".series_progress" and ".series_progress_delta" features
				(assign_to_entities (assoc
					!trainedFeatures
						(filter (lambda (not (contains_value [".series_progress" ".series_progress_delta"] (current_value)))) !trainedFeatures)
				))

				;remove those two features from all cases
				||(map
					(lambda (assign_entity_roots
						(current_value)
						(filter
							(lambda
								(and
									(!= (current_index) "#.series_progress")
									(!= (current_index) "#.series_progress_delta")
									(!= (current_index) "#.series_index")
									(not (contains_value (get_labels (current_value)) "#.series_progress"))
									(not (contains_value (get_labels (current_value)) "#.series_progress_delta"))
									(not (contains_value (get_labels (current_value)) "#.series_index"))
								)
							)
							(retrieve_entity_root (current_value))
						)
					))
					(call !AllCases)
				)

				(assign_to_entities (assoc
					!trainedFeatures (sort (values (append !trainedFeatures (indices !featureAttributes)) .true) )
					!trainedFeaturesContextKey
						(call !BuildContextFeaturesKey (assoc
							context_features (values (append !trainedFeatures (indices !featureAttributes)) .true)
						))
				))
				(call !UpdateDefinedFeatures)

				(call !DeriveTrainFeatures (assoc
					features features
					derived_features (get !tsFeaturesMap "ts_derived_features")
					separate_delta_and_rates .true
				))

				;all old time series datasets should be re-analized due to the new built-in features being added
				(print "\n===\nWARNING: This Dataset should be re-Analyzed.\n===\n\n")
			)
		)
	)
"107.2.0"
	(seq
		;must assign .next_trained_index label to each session entity
		(map
			(lambda
				(accum_entity_roots (current_value) (zip_labels
					[".next_trained_index"] [(retrieve_from_entity (current_value 1) ".total_instance_count")]
				))
			)
			(call !GetSessionIds)
		)
	)
"107.2.3"
	(seq
		;remove booleans, leaving only numbers in the map
		(assign_to_entities (assoc
			!numericNominalFeaturesMap
				(filter
					(lambda (= "number" (current_value)))
					!numericNominalFeaturesMap
				)
		))
	)

"108.2.1"
	;updates !inactiveFeaturesMap to store the feature value and not just 0
	(call !UpdateInactiveFeatures)

"110.2.0"
	(assign_to_entities (assoc
		!codeFeatureDomainAttributesMap
			;rebuild the map here from the existing feature attributes map
			(call !ComposeCodeFeatureDomainAttributesMap (assoc
				code_features_map (call !ComposeNonNumberContinuousMap (assoc feature_attributes !featureAttributesMap))
			))
	))
))