;custom code for conversions that need to be done for a specifid core version, assuming the upgrade is from the previous one
;that way if a trainee has to be upgraded several versions, it will execute all the intermediary conversions in order
(lambda (assoc

"0.0.0"
	;all previous trainee labels are accessed via 'import_metadata_map'
	(seq (print "Version 0.0.0: This code can access and do any operations on contained entity 'trainee'.\n") )

"100.1.1"
	(call !UpdateDefinedFeatures)
"106.0.0"
	(seq
		;method to convert old derived code to new format
		;eg: "(+ #feat_a 0  #feat_b 2)" converts to "(+ (call value {feature \"feat_a\"}) (call value {feature \"feat_b\" lag 2}) )"
		(declare (assoc
			update_code_method
				(lambda (let
					;create an assoc of feature -> lag value
					(assoc feature_lag_map (get_all_labels (parse code_string)) )
					(unparse
						(rewrite
							(lambda (let
								(assoc label (first (get_labels (current_value 1))) )

								;if this node is a label, replace it with the new code that is in the format  (call value {feature feature lag lag_value})
								(if (contains_index feature_lag_map label)
									(parse (concat
										"(call value {feature \"" label
										(if (> (get feature_lag_map label) 0)
											(concat "\" lag " (get feature_lag_map label) )
											"\""
										)
										" })"
									))
									(current_value)
								)
							))
							(parse code_string)
						)
					)
				))
		))

		;overwrite all the derived code in feature attributes by calling the update_code_method on any code that is found
		(assign_to_entities (assoc
			!featureAttributes
				(map
					(lambda (if
						;rewrite old label-based code into the method-based format
						(or
							(!= (null) (get (current_value) ["auto_derive_on_train" "code"]))
							(!= (null) (get (current_value) "derived_feature_code"))
							(!= (null) (get (current_value) "post_process"))
						)
						(let
							(assoc attributes (current_value 1))
							(if (!= (null) (get attributes ["auto_derive_on_train" "code"]))
								(assign (assoc
									attributes
										(set
											attributes
											["auto_derive_on_train" "code_features"]
												(indices (get_all_labels
													(parse (get attributes ["auto_derive_on_train" "code"]))
												))
											["auto_derive_on_train" "code"]
												(call update_code_method (assoc
													code_string (get attributes ["auto_derive_on_train" "code"])
												))
										)
								))
							)
							(if (!= (null) (get attributes "derived_feature_code"))
								(assign (assoc
									attributes
										(set
											attributes
											"code_features"
												(indices (get_all_labels
													(parse (get attributes "derived_feature_code"))
												))
											"derived_feature_code"
												(call update_code_method (assoc
													code_string (get attributes "derived_feature_code")
												))
										)
								))
							)
							(if (!= (null) (get attributes "post_process"))
								(assign (assoc
									attributes
										(set attributes "post_process"
											(call update_code_method (assoc
												code_string (get attributes "post_process")
											))
										)
								))
							)
							attributes
						)

						;else leave attributes alone
						(current_value)
					))
					!featureAttributes
				)
		))
	)
"106.0.1"
	(seq
		(if !tsTimeFeature
			(seq
				;re-assign feature attributes to create the synchronous counter feature attributes
				(call set_feature_attributes (assoc
					feature_attributes (get (call get_feature_attributes) (list 1 "payload"))
				))

				;create the synchronous counter feature and populate its values
				(call !CreateSynchronousCounterFeature (assoc
					time_feature !tsTimeFeature
					time_feature_delta (concat "." !tsTimeFeature "_delta_1")
					series_ordered_by_features [!tsTimeFeature !internalLabelSessionTrainingIndex]
					series_id_features (get !tsFeaturesMap "series_id_features")
				))
			)
		)
	)
"107.2.0"
	(seq
		;must assign .next_trained_index label to each session entity
		(map
			(lambda
				(accum_entity_roots (current_value) (zip_labels
					[".next_trained_index"] [(retrieve_from_entity (current_value 1) ".total_instance_count")]
				))
			)
			(call !GetSessionIds)
		)
	)
"107.2.3"
	(seq
		;remove booleans, leaving only numbers in the map
		(assign_to_entities (assoc
			!numericNominalFeaturesMap
				(filter
					(lambda (= "number" (current_value)))
					!numericNominalFeaturesMap
				)
		))
	)
))